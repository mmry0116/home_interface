{"version":3,"file":"index.min.js","sources":["../src/model/types.js","../src/model/video-track.js","../src/model/audio-track.js","../src/model/video-sample.js","../src/model/audio-sample.js","../src/model/metadata-track.js","../src/utils/exp-golomb.js","../src/utils/logger.js","../src/utils/utf8.js","../src/utils/env.js","../src/utils/index.js","../src/codec/nalu.js","../src/codec/avc.js","../src/codec/aac.js","../src/codec/hevc.js","../src/flv/fixer.js","../src/flv/amf.js","../src/flv/index.js","../src/mpeg-ts/fixer.js","../src/mpeg-ts/index.js","../src/mp4/mp4-parser.js","../src/mp4/fmp4-demuxer.js","../src/mp4/buffer.js","../src/mp4/mp4.js","../src/mp4/logger.js","../../../node_modules/crypto-es/lib/md5.js","../src/mp4/fmp4-remuxer.js","../../../node_modules/crypto-es/lib/core.js","../../../node_modules/crypto-es/lib/enc-base64.js","../../../node_modules/crypto-es/lib/evpkdf.js","../../../node_modules/crypto-es/lib/cipher-core.js","../../../node_modules/crypto-es/lib/aes.js","../../../node_modules/crypto-es/lib/mode-ctr.js","../../../node_modules/crypto-es/lib/pad-nopadding.js","../src/mp4/crypto/crypto.js","../src/mp4/mp4-demuxer.js","../src/mp4/mp4-remuxer.js","../src/index.umd.js"],"sourcesContent":["/** @enum {string} */\nexport const TrackType = {\n  VIDEO: 'video',\n  AUDIO: 'audio',\n  METADATA: 'metadata'\n}\n\n/** @enum {string} */\nexport const VideoCodecType = {\n  AVC: 'avc',\n  HEVC: 'hevc'\n}\n\n/** @enum {string} */\nexport const AudioCodecType = {\n  AAC: 'aac',\n  G711PCMA: 'g7110a',\n  G711PCMU: 'g7110m'\n}\n\n/** @enum {string} */\nexport const WarningType = {\n  LARGE_AV_SHIFT: 'LARGE_AV_SHIFT',\n  LARGE_VIDEO_GAP: 'LARGE_VIDEO_GAP',\n  LARGE_VIDEO_GAP_BETWEEN_CHUNK: 'LARGE_VIDEO_GAP_BETWEEN_CHUNK',\n  LARGE_AUDIO_GAP: 'LARGE_AUDIO_GAP',\n  AUDIO_FILLED: 'AUDIO_FILLED',\n  AUDIO_DROPPED: 'AUDIO_DROPPED'\n}\n","import { TrackType, VideoCodecType } from './types'\n\nexport class VideoTrack {\n  id = 1\n\n  /** @readonly */\n  type = TrackType.VIDEO\n\n  codecType = VideoCodecType.AVC\n\n  pid = -1 // ts use\n\n  /** @type {Uint8Array | Object} */\n  hvcC = undefined\n\n  codec = ''\n\n  timescale = 0\n\n  formatTimescale = 0\n\n  sequenceNumber = 0\n\n  baseMediaDecodeTime = 0\n\n  baseDts = 0\n\n  duration = 0\n\n  warnings = []\n\n  /** @type {import('./video-sample').VideoSample[]} */\n  samples = []\n\n  /** @type {Uint8Array[]} */\n  pps = []\n\n  /** @type {Uint8Array[]} */\n  sps = []\n\n  /** @type {Uint8Array[]} */\n  vps = []\n\n  fpsNum = 0\n\n  fpsDen = 0\n\n  /** @type {[number, number]} */\n  sarRatio = [] // [hSpacing, vSpacing]\n\n  width = 0\n\n  height = 0\n\n  nalUnitSize = 4\n\n  present = false\n\n  isVideoEncryption = false\n\n  isAudioEncryption = false\n\n  isVideo = true\n\n  kid = null\n\n  pssh = null\n\n  /** @type {any} */\n  ext\n\n  reset () {\n    this.sequenceNumber =\n    this.width =\n    this.height =\n    this.fpsDen =\n    this.fpsNum =\n    this.duration =\n    this.baseMediaDecodeTime =\n    this.timescale = 0\n    this.codec = ''\n    this.present = false\n    this.pid = -1\n    this.pps = []\n    this.sps = []\n    this.vps = []\n    this.sarRatio = []\n    this.samples = []\n    this.warnings = []\n    this.hvcC = null\n  }\n\n  get firstDts () {\n    return this.samples.length ? this.samples[0].dts : null\n  }\n\n  get firstPts () {\n    return this.samples.length ? this.samples[0].pts : null\n  }\n\n  get samplesDuration () {\n    if (this.samples.length > 0) {\n      const first = this.samples[0]\n      const last = this.samples[this.samples.length - 1]\n      return last.dts - first.dts + last.duration\n    }\n    return 0\n  }\n\n  /**\n   * @returns {boolean}\n   */\n  exist () {\n    return !!(this.pps.length && this.sps.length && this.codec)\n  }\n\n  /**\n   * @returns {boolean}\n   */\n  hasSample () {\n    return !!this.samples.length\n  }\n\n  get isEncryption (){\n    return this.isVideoEncryption\n  }\n}\n","import { TrackType, AudioCodecType } from './types'\n\nexport class AudioTrack {\n  id = 2\n\n  /** @readonly */\n  type = TrackType.AUDIO\n\n  codecType = AudioCodecType.AAC\n\n  pid = -1\n\n  codec = ''\n\n  sequenceNumber = 0\n\n  sampleDuration = 0\n\n  timescale = 0\n\n  formatTimescale = 0\n\n  baseMediaDecodeTime = 0\n\n  duration = 0\n\n  warnings = []\n\n  /** @type {import('./audio-sample').AudioSample[]} */\n  samples = []\n\n  baseDts = 0\n\n  sampleSize = 16\n\n  sampleRate = 0\n\n  channelCount = 0\n\n  objectType = 0\n\n  sampleRateIndex = 0\n\n  /** @type {number[]} */\n  config = []\n\n  present = false\n\n  isVideoEncryption = false\n\n  isAudioEncryption = false\n\n  kid = null\n\n  /** @type {any} */\n  ext\n\n  reset () {\n    this.sequenceNumber = 0\n    this.timescale = 0\n    this.sampleDuration = 0\n    this.sampleRate = 0\n    this.channelCount = 0\n    this.baseMediaDecodeTime = 0\n    this.present = false\n    this.pid = -1\n    this.codec = ''\n    this.samples = []\n    this.config = []\n    this.warnings = []\n  }\n\n  /**\n   * @returns {boolean}\n   */\n  exist () {\n    return !!(this.sampleRate && this.channelCount && this.codec && this.codecType === AudioCodecType.AAC)\n  }\n\n  /**\n   * @returns {boolean}\n   */\n  hasSample () {\n    return !!this.samples.length\n  }\n\n  get isEncryption () {\n    return this.isAudioEncryption\n  }\n\n  get firstDts () {\n    return this.samples.length ? this.samples[0].dts : null\n  }\n\n  get firstPts () {\n    return this.samples.length ? this.samples[0].pts : null\n  }\n\n  get samplesDuration () {\n    if (this.samples.length > 0) {\n      const first = this.samples[0]\n      const last = this.samples[this.samples.length - 1]\n      return last.dts - first.dts + last.duration\n    }\n    return 0\n  }\n}\n","/**\n * @typedef {Object} VideoFlag\n * @property {number} [isLeading=0]\n * @property {number} [dependsOn=1]\n * @property {number} [isDependedOn=0]\n * @property {number} [hasRedundancy=0]\n * @property {number} [paddingValue=0]\n * @property {number} [degradationPriority=0]\n * @property {number} [isNonSyncSample=1]\n */\n\nexport class VideoSample {\n  /** @type {VideoFlag} */\n  flag = {}\n\n  keyframe = false\n\n  gopId = 0\n\n  duration = 0\n\n  size = 0\n\n  units = []\n\n  chromaFormat = 420\n\n  // sampleOffset = 0\n\n  /**\n   * @param {number} pts\n   * @param {number} dts\n   * @param {Uint8Array[]} [units]\n   */\n  constructor (pts, dts, units) {\n    this.originPts = this.pts = pts\n    this.originDts = this.dts = dts\n    if (units) this.units = units\n  }\n\n  /**\n   * @returns {number}\n   */\n  get cts () {\n    return this.pts - this.dts\n  }\n\n  setToKeyframe () {\n    this.keyframe = true\n    this.flag.dependsOn = 2\n    this.flag.isNonSyncSample = 0\n  }\n}\n","export class AudioSample {\n  duration = 1024\n\n  flag = { dependsOn: 2, isNonSyncSample: 0 }\n  keyframe = true\n\n  /**\n   * @param {number} pts\n   * @param {Uint8Array} data\n   * @param {number} [duration=1024]\n   */\n  constructor (pts, data, duration, sampleOffset) {\n    this.originPts = this.pts = this.dts = pts\n    this.data = data\n    this.size = data.byteLength\n    this.sampleOffset = sampleOffset\n    if (duration) this.duration = duration\n  }\n}\n","import { TrackType } from './types'\n\nclass Sample {\n  time = 0 // second\n\n  /**\n   * @param {Object} data\n   * @param {number} pts\n   */\n  constructor (data, pts) {\n    this.data = data\n    this.originPts = this.pts = pts\n  }\n}\n\nexport class FlvScriptSample extends Sample {}\n\nexport class SeiSample extends Sample {}\n\nexport class MetadataTrack {\n  /** @readonly */\n  id = 3\n\n  /** @readonly */\n  type = TrackType.METADATA\n\n  timescale = 0\n\n  /** @type {FlvScriptSample[]} */\n  flvScriptSamples = []\n\n  /** @type {SeiSample[]} */\n  seiSamples = []\n\n  /**\n   * @returns {boolean}\n   */\n  exist () {\n    return !!((this.flvScriptSamples.length || this.seiSamples.length) && this.timescale)\n  }\n\n  reset () {\n    this.timescale = 0\n    this.flvScriptSamples = []\n    this.seiSamples = []\n  }\n\n  /**\n   * @returns {boolean}\n   */\n  hasSample () {\n    return !!(this.flvScriptSamples.length || this.seiSamples.length)\n  }\n}\n","export class ExpGolomb {\n  _bytesAvailable\n\n  _bitsAvailable = 0\n\n  _word = 0\n\n  constructor (data) {\n    if (!data) throw new Error('ExpGolomb data params is required')\n    this._data = data\n    this._bytesAvailable = data.byteLength\n    if (this._bytesAvailable) this._loadWord()\n  }\n\n  get bitsAvailable () {\n    return this._bitsAvailable\n  }\n\n  _loadWord () {\n    const position = this._data.byteLength - this._bytesAvailable\n    const availableBytes = Math.min(4, this._bytesAvailable)\n    if (availableBytes === 0) throw new Error('No bytes available')\n\n    const workingBytes = new Uint8Array(4)\n    workingBytes.set(this._data.subarray(position, position + availableBytes))\n\n    this._word = new DataView(workingBytes.buffer).getUint32(0)\n    this._bitsAvailable = availableBytes * 8\n    this._bytesAvailable -= availableBytes\n  }\n\n  skipBits (count) {\n    if (this._bitsAvailable > count) {\n      this._word <<= count\n      this._bitsAvailable -= count\n    } else {\n      count -= this._bitsAvailable\n      const skipBytes = Math.floor(count / 8)\n      count -= (skipBytes * 8)\n      this._bytesAvailable -= skipBytes\n      this._loadWord()\n      this._word <<= count\n      this._bitsAvailable -= count\n    }\n  }\n\n  readBits (size) {\n    if (size > 32) {\n      throw new Error('Cannot read more than 32 bits')\n    }\n\n    let bits = Math.min(this._bitsAvailable, size)\n    const val = this._word >>> (32 - bits)\n\n    this._bitsAvailable -= bits\n    if (this._bitsAvailable > 0) {\n      this._word <<= bits\n    } else if (this._bytesAvailable > 0) {\n      this._loadWord()\n    }\n\n    bits = size - bits\n    if (bits > 0 && this._bitsAvailable) {\n      return (val << bits) | this.readBits(bits)\n    }\n    return val\n  }\n\n  skipLZ () {\n    let leadingZeroCount\n    for (\n      leadingZeroCount = 0;\n      leadingZeroCount < this._bitsAvailable;\n      ++leadingZeroCount\n    ) {\n      if ((this._word & (0x80000000 >>> leadingZeroCount)) !== 0) {\n        this._word <<= leadingZeroCount\n        this._bitsAvailable -= leadingZeroCount\n        return leadingZeroCount\n      }\n    }\n    this._loadWord()\n    return leadingZeroCount + this.skipLZ()\n  }\n\n  skipUEG () {\n    this.skipBits(1 + this.skipLZ())\n  }\n\n  readUEG () {\n    const clz = this.skipLZ()\n    return this.readBits(clz + 1) - 1\n  }\n\n  readEG () {\n    const val = this.readUEG()\n    if (1 & val) {\n      return (1 + val) >>> 1\n    }\n    return -1 * (val >>> 1)\n  }\n\n  readBool () {\n    return this.readBits(1) === 1\n  }\n\n  readUByte () {\n    return this.readBits(8)\n  }\n\n  skipScalingList (count) {\n    let lastScale = 8\n    let nextScale = 8\n    let deltaScale\n    for (let j = 0; j < count; j++) {\n      if (nextScale !== 0) {\n        deltaScale = this.readEG()\n        nextScale = (lastScale + deltaScale + 256) % 256\n      }\n      lastScale = nextScale === 0 ? lastScale : nextScale\n    }\n  }\n}\n","export class Logger {\n  constructor (name) {\n    this.name = name || ''\n    this._prefix = `[${this.name}]`\n  }\n\n  warn (...args) {\n    if (Logger.disabled) return\n    console.warn(this._prefix, ...args)\n  }\n\n  static disabled = true\n\n  static enable () {\n    Logger.disabled = false\n  }\n\n  static disable () {\n    Logger.disabled = true\n  }\n}\n","export class UTF8 {\n  /**\n   *\n   * @param {Uint8Array} uint8array\n   * @return {string}\n   */\n  static decode (uint8array) {\n    const out = []\n    const input = uint8array\n    let i = 0\n    const length = uint8array.length\n\n    while (i < length) {\n      if (input[i] < 0x80) {\n        out.push(String.fromCharCode(input[i]))\n        ++i\n        continue\n      } else if (input[i] < 0xC0) {\n        // fallthrough\n      } else if (input[i] < 0xE0) {\n        if (UTF8._checkContinuation(input, i, 1)) {\n          const ucs4 = (input[i] & 0x1F) << 6 | (input[i + 1] & 0x3F)\n          if (ucs4 >= 0x80) {\n            out.push(String.fromCharCode(ucs4 & 0xFFFF))\n            i += 2\n            continue\n          }\n        }\n      } else if (input[i] < 0xF0) {\n        if (UTF8._checkContinuation(input, i, 2)) {\n          const ucs4 = (input[i] & 0xF) << 12 | (input[i + 1] & 0x3F) << 6 | input[i + 2] & 0x3F\n          if (ucs4 >= 0x800 && (ucs4 & 0xF800) !== 0xD800) {\n            out.push(String.fromCharCode(ucs4 & 0xFFFF))\n            i += 3\n            continue\n          }\n        }\n      } else if (input[i] < 0xF8) {\n        if (UTF8._checkContinuation(input, i, 3)) {\n          let ucs4 = (input[i] & 0x7) << 18 | (input[i + 1] & 0x3F) << 12 |\n                    (input[i + 2] & 0x3F) << 6 | (input[i + 3] & 0x3F)\n          if (ucs4 > 0x10000 && ucs4 < 0x110000) {\n            ucs4 -= 0x10000\n            out.push(String.fromCharCode((ucs4 >>> 10) | 0xD800))\n            out.push(String.fromCharCode((ucs4 & 0x3FF) | 0xDC00))\n            i += 4\n            continue\n          }\n        }\n      }\n      out.push(String.fromCharCode(0xFFFD))\n      ++i\n    }\n\n    return out.join('')\n  }\n\n  static _checkContinuation (uint8array, start, checkLength) {\n    const array = uint8array\n    if (start + checkLength < array.length) {\n      while (checkLength--) {\n        if ((array[++start] & 0xC0) !== 0x80) {\n          return false\n        }\n      }\n      return true\n    } else {\n      return false\n    }\n  }\n}\n","export const isBrowser = typeof window !== 'undefined'\n\nconst ua = isBrowser && navigator.userAgent.toLocaleLowerCase()\n\n// eslint-disable-next-line no-lookahead-lookbehind-regexp/no-lookahead-lookbehind-regexp\nexport const isSafari = isBrowser && /^((?!chrome|android).)*safari/.test(ua)\nexport const isFirefox = isBrowser && ua.includes('firefox')\nexport const isAndroid = isBrowser && ua.includes('android')\n","/* c8 ignore next 4 */\nexport { ExpGolomb } from './exp-golomb'\nexport { Logger } from './logger'\nexport { UTF8 } from './utf8'\nexport * from './env'\n\nexport function concatUint8Array (...arr) {\n  arr = arr.filter(Boolean)\n  const data = new Uint8Array(arr.reduce((p, c) => p + c.byteLength, 0))\n  let prevLen = 0\n  arr.forEach((d) => {\n    data.set(d, prevLen)\n    prevLen += d.byteLength\n  })\n  return data\n}\n\nexport const MAX_SIZE = Math.pow(2, 32)\n\nexport function readBig16 (data, i = 0) {\n  return (data[i] << 8) + (data[i + 1] || 0)\n}\n\nexport function readBig24 (data, i = 0) {\n  return (data[i] << 16) + (data[i + 1] << 8) + (data[i + 2] || 0)\n}\n\nexport function readBig32 (data, i = 0) {\n  return (data[i] << 24 >>> 0) + (data[i + 1] << 16) + (data[i + 2] << 8) + (data[i + 3] || 0)\n}\n\nexport function readBig64 (data, i = 0) {\n  return readBig32(data, i) * MAX_SIZE + readBig32(data, i + 4)\n}\n\nexport function getAvcCodec (codecs) {\n  let codec = 'avc1.'\n  let h\n  for (let i = 0; i < 3; i++) {\n    h = codecs[i].toString(16)\n    if (h.length < 2) h = `0${h}`\n    codec += h\n  }\n  return codec\n}\n\nexport function formatIV (arr) {\n  let iv = ''\n  arr.forEach(value => {\n    iv += bufferToString(value)\n  })\n  if (iv.length <= 32) {\n    const len = 32 - iv.length\n    for (let i = 0; i < len; i++) {\n      iv += '0'\n    }\n  }\n  return iv\n}\n\nexport function parse (a) {\n  if (!Array.isArray(a)) {\n    const arr = []\n    let value = ''\n    for (let i = 0; i < a.length; i++) {\n      if (i % 2) {\n        value = a[i - 1] + a[i]\n        arr.push(parseInt(value, 16))\n        value = ''\n      }\n    }\n    return arr\n  }\n  return a.map(item => { return parseInt(item, 16) })\n}\nfunction bufferToString (value) {\n  return ('0' + (Number(value).toString(16))).slice(-2).toUpperCase()\n}\n\nexport function hashVal (str) {\n  let hash = 0; let i; let chr\n  if (str.length === 0) return hash\n  for (i = 0; i < str.length; i++) {\n    chr = str.charCodeAt(i)\n    hash = ((hash << 5) - hash) + chr\n    hash |= 0\n  }\n  return hash\n}\n","import { readBig32 } from '../utils'\n\nexport class NALu {\n  static parseAnnexB (data) {\n    const len = data.length\n    let start = 2\n    let end = 0\n    while (data[start] !== null && data[start] !== undefined && data[start] !== 1) {\n      start++\n    }\n    start++\n    end = start + 2\n\n    if (end >= len) return []\n\n    const units = []\n\n    while (end < len) {\n      switch (data[end]) {\n        case 0:\n          if (data[end - 1] !== 0) {\n            end += 2\n            break\n          } else if (data[end - 2] !== 0) {\n            end++\n            break\n          }\n\n          if (start !== end - 2) units.push(data.subarray(start, end - 2))\n\n          do {\n            end++\n          } while (data[end] !== 1 && end < len)\n          start = end + 1\n          end = start + 2\n          break\n        case 1:\n          if (data[end - 1] !== 0 || data[end - 2] !== 0) {\n            end += 3\n            break\n          }\n          if (start !== end - 2) units.push(data.subarray(start, end - 2))\n          start = end + 1\n          end = start + 2\n          break\n        default:\n          end += 3\n          break\n      }\n    }\n\n    if (start < len) units.push(data.subarray(start))\n\n    return units\n  }\n\n  static parseAvcC (data, size = 4) {\n    if (data.length < 4) return\n    const dataLen = data.length\n    const units = []\n\n    let offset = 0\n    let length\n    while ((offset + size) < dataLen) {\n      length = readBig32(data, offset)\n      if (size === 3) length >>>= 8\n      offset += size\n\n      if (!length) continue\n      if (offset + length > dataLen) {\n        break\n      }\n\n      units.push(data.subarray(offset, offset + length))\n      offset += length\n    }\n\n    return units\n  }\n\n  static parseSEI (unit, isHevc) {\n    const len = unit.length\n    let i = isHevc ? 2 : 1\n    let type = 0\n    let size = 0\n    let uuid = ''\n\n    while (unit[i] === 255) {\n      type += 255\n      i++\n    }\n\n    type += unit[i++]\n\n    while (unit[i] === 255) {\n      size += 255\n      i++\n    }\n    size += unit[i++]\n\n    if (type === 5 && len > i + 16) {\n      for (let j = 0; j < 16; j++) {\n        uuid += unit[i].toString(16)\n        i++\n      }\n    }\n\n    return {\n      payload: unit.subarray(i, i + size), type, size, uuid\n    }\n  }\n\n  static removeEPB (uint) {\n    const length = uint.byteLength\n    const emulationPreventionBytesPositions = []\n    let i = 1\n\n    while (i < length - 2) {\n      if (uint[i] === 0 && uint[i + 1] === 0 && uint[i + 2] === 0x03) {\n        emulationPreventionBytesPositions.push(i + 2)\n        i += 2\n      } else {\n        i++\n      }\n    }\n\n    if (!emulationPreventionBytesPositions.length) return uint\n\n    const newLength = length - emulationPreventionBytesPositions.length\n    const newData = new Uint8Array(newLength)\n\n    let sourceIndex = 0\n    for (i = 0; i < newLength; sourceIndex++, i++) {\n      if (sourceIndex === emulationPreventionBytesPositions[0]) {\n        sourceIndex++\n        emulationPreventionBytesPositions.shift()\n      }\n      newData[i] = uint[sourceIndex]\n    }\n\n    return newData\n  }\n}\n","import { NALu } from './nalu'\nimport { ExpGolomb, getAvcCodec } from '../utils'\n\nexport class AVC {\n  static parseAVCDecoderConfigurationRecord (data) {\n    if (data.length < 7) return\n    const nalUnitSize = (data[4] & 3) + 1\n\n    let spsParsed\n    const spsArr = []\n    const ppsArr = []\n\n    let offset = 6\n    const spsCount = data[5] & 0x1f\n    let spsSize\n    for (let i = 0; i < spsCount; i++) {\n      spsSize = (data[offset] << 8) | data[offset + 1]\n      offset += 2\n      if (!spsSize) continue\n\n      const sps = data.subarray(offset, offset + spsSize)\n      offset += spsSize\n      spsArr.push(sps)\n\n      if (!spsParsed) {\n        spsParsed = AVC.parseSPS(NALu.removeEPB(sps))\n      }\n    }\n\n    const ppsCount = data[offset]\n    offset++\n    let ppsSize\n    for (let i = 0; i < ppsCount; i++) {\n      ppsSize = (data[offset] << 8) | data[offset + 1]\n      offset += 2\n      if (!ppsSize) continue\n      ppsArr.push(data.subarray(offset, offset + ppsSize))\n      offset += ppsSize\n    }\n\n    return {\n      sps: spsParsed,\n      spsArr,\n      ppsArr,\n      nalUnitSize\n    }\n  }\n\n  static parseSPS (unit) {\n    const eg = new ExpGolomb(unit)\n    eg.readUByte()\n\n    const profileIdc = eg.readUByte()\n    const profileCompatibility = eg.readUByte()\n    const levelIdc = eg.readUByte()\n    eg.skipUEG()\n\n    let chromaFormat = 420\n    if (\n      profileIdc === 100 ||\n      profileIdc === 110 ||\n      profileIdc === 122 ||\n      profileIdc === 244 ||\n      profileIdc === 44 ||\n      profileIdc === 83 ||\n      profileIdc === 86 ||\n      profileIdc === 118 ||\n      profileIdc === 128 ||\n      profileIdc === 138 ||\n      profileIdc === 144\n    ) {\n      const chromaFormatIdc = eg.readUEG()\n      if (chromaFormatIdc <= 3) chromaFormat = [0, 420, 422, 444][chromaFormatIdc]\n      if (chromaFormatIdc === 3) eg.skipBits(1)\n      eg.skipUEG()\n      eg.skipUEG()\n      eg.skipBits(1)\n      if (eg.readBool()) {\n        const scalingListCount = chromaFormatIdc !== 3 ? 8 : 12\n        for (let i = 0; i < scalingListCount; i++) {\n          if (eg.readBool()) {\n            if (i < 6) {\n              eg.skipScalingList(16)\n            } else {\n              eg.skipScalingList(64)\n            }\n          }\n        }\n      }\n    }\n\n    eg.skipUEG()\n    const picOrderCntType = eg.readUEG()\n    if (picOrderCntType === 0) {\n      eg.readUEG()\n    } else if (picOrderCntType === 1) {\n      eg.skipBits(1)\n      eg.skipUEG()\n      eg.skipUEG()\n      const numRefFramesInPicOrderCntCycle = eg.readUEG()\n      for (let i = 0; i < numRefFramesInPicOrderCntCycle; i++) {\n        eg.skipUEG()\n      }\n    }\n\n    eg.skipUEG()\n    eg.skipBits(1)\n    const picWidthInMbsMinus1 = eg.readUEG()\n    const picHeightInMapUnitsMinus1 = eg.readUEG()\n    const frameMbsOnlyFlag = eg.readBits(1)\n    if (frameMbsOnlyFlag === 0) eg.skipBits(1)\n    eg.skipBits(1)\n\n    let frameCropLeftOffset = 0\n    let frameCropRightOffset = 0\n    let frameCropTopOffset = 0\n    let frameCropBottomOffset = 0\n\n    if (eg.readBool()) {\n      frameCropLeftOffset = eg.readUEG()\n      frameCropRightOffset = eg.readUEG()\n      frameCropTopOffset = eg.readUEG()\n      frameCropBottomOffset = eg.readUEG()\n    }\n\n    let sarRatio\n    let fixedFrame\n    let fpsNum\n    let fpsDen\n    let fps\n    if (eg.readBool()) {\n      if (eg.readBool()) {\n        const aspectRatioIdc = eg.readUByte()\n        switch (aspectRatioIdc) {\n          case 1: sarRatio = [1, 1]; break\n          case 2: sarRatio = [12, 11]; break\n          case 3: sarRatio = [10, 11]; break\n          case 4: sarRatio = [16, 11]; break\n          case 5: sarRatio = [40, 33]; break\n          case 6: sarRatio = [24, 11]; break\n          case 7: sarRatio = [20, 11]; break\n          case 8: sarRatio = [32, 11]; break\n          case 9: sarRatio = [80, 33]; break\n          case 10: sarRatio = [18, 11]; break\n          case 11: sarRatio = [15, 11]; break\n          case 12: sarRatio = [64, 33]; break\n          case 13: sarRatio = [160, 99]; break\n          case 14: sarRatio = [4, 3]; break\n          case 15: sarRatio = [3, 2]; break\n          case 16: sarRatio = [2, 1]; break\n          case 255: {\n            sarRatio = [\n              (eg.readUByte() << 8) | eg.readUByte(),\n              (eg.readUByte() << 8) | eg.readUByte()\n            ]\n            break\n          }\n          default:\n        }\n      }\n\n      if (eg.readBool()) eg.readBool()\n\n      if (eg.readBool()) {\n        eg.readBits(4)\n        if (eg.readBool()) eg.readBits(24)\n      }\n\n      if (eg.readBool()) {\n        eg.readUEG()\n        eg.readUEG()\n      }\n\n      if (eg.readBool()) {\n        const numUnitsInTick = eg.readBits(32)\n        const timeScale = eg.readBits(32)\n        fixedFrame = eg.readBool()\n\n        fpsNum = timeScale\n        fpsDen = numUnitsInTick * 2\n        fps = fpsNum / fpsDen\n      }\n    }\n\n    return {\n      codec: getAvcCodec(unit.subarray(1, 4)),\n      profileIdc,\n      profileCompatibility,\n      levelIdc,\n      chromaFormat,\n      width: Math.ceil(\n        (picWidthInMbsMinus1 + 1) * 16 -\n          2 * (frameCropLeftOffset + frameCropRightOffset)\n      ),\n      height:\n        (2 - frameMbsOnlyFlag) * (picHeightInMapUnitsMinus1 + 1) * 16 -\n        (frameMbsOnlyFlag ? 2 : 4) *\n          (frameCropTopOffset + frameCropBottomOffset),\n      sarRatio,\n      fpsNum,\n      fpsDen,\n      fps,\n      fixedFrame\n    }\n  }\n}\n","import { isFirefox, isAndroid } from '../utils'\n\nexport class AAC {\n  static FREQ = [\n    96000,\n    88200,\n    64000,\n    48000,\n    44100,\n    32000,\n    24000,\n    22050,\n    16000,\n    12000,\n    11025,\n    8000,\n    7350\n  ];\n\n  static getRateIndexByRate (rate) {\n    return AAC.FREQ.indexOf(rate)\n  }\n\n  static parseADTS (data, pts) {\n    const len = data.length\n    let i = 0\n\n    while ((i + 2) < len) {\n      if (data[i] === 0xff && (data[i + 1] & 0xf6) === 0xf0) {\n        break\n      }\n      i++\n    }\n\n    if (i >= len) return\n\n    const skip = i\n    const frames = []\n    const samplingFrequencyIndex = (data[i + 2] & 0x3c) >>> 2\n    const sampleRate = AAC.FREQ[samplingFrequencyIndex]\n    if (!sampleRate) throw new Error(`Invalid sampling index: ${samplingFrequencyIndex}`)\n    const objectType = ((data[i + 2] & 0xc0) >>> 6) + 1\n    const channelCount = ((data[i + 2] & 1) << 2) | ((data[i + 3] & 0xc0) >>> 6)\n    const { config, codec } = AAC._getConfig(samplingFrequencyIndex, channelCount, objectType)\n\n    let protectionSkipBytes\n    let frameLength\n    let frameIndex = 0\n    const duration = AAC.getFrameDuration(sampleRate)\n\n    while ((i + 7) < len) {\n      if ((data[i] !== 0xff) || (data[i + 1] & 0xF6) !== 0xf0) {\n        i++\n        continue\n      }\n\n      frameLength = ((data[i + 3] & 0x03) << 11) | (data[i + 4] << 3) | ((data[i + 5] & 0xe0) >> 5)\n      if ((len - i) < frameLength) break\n\n      protectionSkipBytes = (~data[i + 1] & 0x01) * 2\n      frames.push({\n        pts: pts + frameIndex * duration,\n        data: data.subarray(i + 7 + protectionSkipBytes, i + frameLength)\n      })\n\n      frameIndex++\n      i += frameLength\n    }\n\n    return {\n      skip,\n      remaining: i >= len ? undefined : data.subarray(i),\n      frames,\n      samplingFrequencyIndex,\n      sampleRate,\n      objectType,\n      channelCount,\n      codec,\n      config,\n      originCodec: `mp4a.40.${objectType}`\n    }\n  }\n\n  static parseAudioSpecificConfig (data) {\n    if (!data.length) return\n    const objectType = data[0] >>> 3\n    const samplingFrequencyIndex = ((data[0] & 0x07) << 1) | (data[1] >>> 7)\n    const channelCount = (data[1] & 0x78) >>> 3\n    const sampleRate = AAC.FREQ[samplingFrequencyIndex]\n    // play as no audio track stream\n    if (!sampleRate) return\n    const { config, codec } = AAC._getConfig(samplingFrequencyIndex, channelCount, objectType)\n\n    return {\n      samplingFrequencyIndex,\n      sampleRate,\n      objectType,\n      channelCount,\n      config,\n      codec,\n      originCodec: `mp4a.40.${objectType}`\n    }\n  }\n\n  static getFrameDuration (rate, timescale = 90000) {\n    return 1024 * timescale / rate\n  }\n\n  static _getConfig (samplingIndex, channelCount, originObjectType) {\n    const config = []\n    let objectType\n    let extensionSamplingIndex\n    if (isFirefox) {\n      if (samplingIndex >= 6) { // use SBR (HE-AAC)\n        objectType = 5\n        extensionSamplingIndex = samplingIndex - 3\n      } else { // use LC-AAC\n        objectType = 2\n        extensionSamplingIndex = samplingIndex\n      }\n    } else if (isAndroid) { // use LC-AAC\n      objectType = 2\n      extensionSamplingIndex = samplingIndex\n    } else { // use HE-AAC\n      objectType = (originObjectType === 2 || originObjectType === 5) ? originObjectType : 5\n      extensionSamplingIndex = samplingIndex\n\n      if (samplingIndex >= 6) {\n        extensionSamplingIndex = samplingIndex - 3\n      } else if (channelCount === 1) { // Mono channel, use LC-AAC\n        objectType = 2\n        extensionSamplingIndex = samplingIndex\n      }\n    }\n\n    config[0] = objectType << 3\n    config[0] |= (samplingIndex & 0x0e) >> 1\n    config[1] = (samplingIndex & 0x01) << 7\n    config[1] |= channelCount << 3\n    if (objectType === 5) {\n      config[1] |= ((extensionSamplingIndex & 0x0e) >> 1)\n      config[2] = (extensionSamplingIndex & 0x01) << 7\n      config[2] |= (2 << 2)\n      config[3] = 0\n    }\n\n    return {\n      config,\n      codec: `mp4a.40.${objectType}`\n    }\n  }\n\n  /* c8 ignore next 65 */\n  static getSilentFrame (codec, channelCount) {\n    switch (codec) {\n      case 'mp4a.40.2':\n        if (channelCount === 1) {\n          return new Uint8Array([0x00, 0xc8, 0x00, 0x80, 0x23, 0x80])\n        } if (channelCount === 2) {\n          return new Uint8Array([\n            0x21, 0x00, 0x49, 0x90, 0x02, 0x19, 0x00, 0x23, 0x80\n          ])\n        } if (channelCount === 3) {\n          return new Uint8Array([\n            0x00, 0xc8, 0x00, 0x80, 0x20, 0x84, 0x01, 0x26, 0x40, 0x08, 0x64,\n            0x00, 0x8e\n          ])\n        } if (channelCount === 4) {\n          return new Uint8Array([\n            0x00, 0xc8, 0x00, 0x80, 0x20, 0x84, 0x01, 0x26, 0x40, 0x08, 0x64,\n            0x00, 0x80, 0x2c, 0x80, 0x08, 0x02, 0x38\n          ])\n        } if (channelCount === 5) {\n          return new Uint8Array([\n            0x00, 0xc8, 0x00, 0x80, 0x20, 0x84, 0x01, 0x26, 0x40, 0x08, 0x64,\n            0x00, 0x82, 0x30, 0x04, 0x99, 0x00, 0x21, 0x90, 0x02, 0x38\n          ])\n        } if (channelCount === 6) {\n          return new Uint8Array([\n            0x00, 0xc8, 0x00, 0x80, 0x20, 0x84, 0x01, 0x26, 0x40, 0x08, 0x64,\n            0x00, 0x82, 0x30, 0x04, 0x99, 0x00, 0x21, 0x90, 0x02, 0x00, 0xb2,\n            0x00, 0x20, 0x08, 0xe0\n          ])\n        }\n        break\n      default:\n        if (channelCount === 1) {\n          return new Uint8Array([\n            0x1, 0x40, 0x22, 0x80, 0xa3, 0x4e, 0xe6, 0x80, 0xba, 0x8, 0x0, 0x0,\n            0x0, 0x1c, 0x6, 0xf1, 0xc1, 0xa, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a,\n            0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a,\n            0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a,\n            0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a,\n            0x5a, 0x5e\n          ])\n        } if (channelCount === 2) {\n          return new Uint8Array([\n            0x1, 0x40, 0x22, 0x80, 0xa3, 0x5e, 0xe6, 0x80, 0xba, 0x8, 0x0, 0x0,\n            0x0, 0x0, 0x95, 0x0, 0x6, 0xf1, 0xa1, 0xa, 0x5a, 0x5a, 0x5a, 0x5a,\n            0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a,\n            0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a,\n            0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a,\n            0x5a, 0x5e\n          ])\n        } if (channelCount === 3) {\n          return new Uint8Array([\n            0x1, 0x40, 0x22, 0x80, 0xa3, 0x5e, 0xe6, 0x80, 0xba, 0x8, 0x0, 0x0,\n            0x0, 0x0, 0x95, 0x0, 0x6, 0xf1, 0xa1, 0xa, 0x5a, 0x5a, 0x5a, 0x5a,\n            0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a,\n            0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a,\n            0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a,\n            0x5a, 0x5e\n          ])\n        }\n        break\n    }\n  }\n}\n","import { NALu } from './nalu'\nimport { ExpGolomb } from '../utils'\n\nexport class HEVC {\n  static parseHEVCDecoderConfigurationRecord (data, hvcC = {}) {\n    if (data.length < 23) return\n    hvcC = hvcC || {}\n    const nalUnitSize = (data[21] & 3) + 1\n\n    let vpsParsed\n    let spsParsed\n    const spsArr = []\n    const ppsArr = []\n    const vpsArr = []\n\n    let offset = 23\n    const numOfArrays = data[22]\n\n    let nalUnitType\n    let numNalus\n    let nalSize\n    for (let i = 0; i < numOfArrays; i++) {\n      nalUnitType = data[offset] & 0x3f\n      numNalus = (data[offset + 1] << 8) | data[offset + 2]\n\n      offset += 3\n\n      for (let j = 0; j < numNalus; j++) {\n        nalSize = (data[offset] << 8) | data[offset + 1]\n        offset += 2\n        if (!nalSize) continue\n        switch (nalUnitType) {\n          case 32: {\n            const vps = data.subarray(offset, offset + nalSize)\n            if (!vpsParsed) vpsParsed = HEVC.parseVPS(NALu.removeEPB(vps), hvcC)\n            vpsArr.push(vps)\n          }\n            break\n          case 33: {\n            const sps = data.subarray(offset, offset + nalSize)\n            if (!spsParsed) spsParsed = HEVC.parseSPS(NALu.removeEPB(sps), hvcC)\n            spsArr.push(sps)\n          }\n            break\n          case 34:\n            ppsArr.push(data.subarray(offset, offset + nalSize))\n            break\n          default:\n        }\n\n        offset += nalSize\n      }\n    }\n\n    return {\n      hvcC,\n      sps: spsParsed,\n      spsArr,\n      ppsArr,\n      vpsArr,\n      nalUnitSize\n    }\n  }\n\n  static parseVPS (unit, hvcC) {\n    hvcC = hvcC || {}\n    const eg = new ExpGolomb(unit)\n    eg.readUByte()\n    eg.readUByte()\n\n    eg.readBits(12)\n    const vpsMaxSubLayersMinus1 = eg.readBits(3)\n    hvcC.numTemporalLayers = Math.max(hvcC.numTemporalLayers || 0, vpsMaxSubLayersMinus1 + 1)\n    eg.readBits(17)\n    HEVC._parseProfileTierLevel(eg, vpsMaxSubLayersMinus1, hvcC)\n\n    return hvcC\n  }\n\n  static parseSPS (unit, hvcC = {}) {\n    hvcC = hvcC || {}\n    const eg = new ExpGolomb(unit)\n    eg.readUByte()\n    eg.readUByte()\n\n    eg.readBits(4)\n    const spsMaxSubLayersMinus1 = eg.readBits(3)\n    hvcC.numTemporalLayers = Math.max(spsMaxSubLayersMinus1 + 1, hvcC.numTemporalLayers || 0)\n    hvcC.temporalIdNested = eg.readBits(1)\n    HEVC._parseProfileTierLevel(eg, spsMaxSubLayersMinus1, hvcC)\n\n    eg.readUEG() // sps_seq_parameter_set_id\n\n    const chromaFormatIdc = hvcC.chromaFormatIdc = eg.readUEG()\n    let chromaFormat = 420\n    if (chromaFormatIdc <= 3) chromaFormat = [0, 420, 422, 444][chromaFormatIdc]\n\n    let separateColourPlaneFlag = 0\n    if (chromaFormatIdc === 3) {\n      separateColourPlaneFlag = eg.readBits(1)\n    }\n\n    let width = eg.readUEG() // pic_width_in_luma_samples\n    let height = eg.readUEG() // pic_height_in_luma_samples\n\n    const conformanceWindowFlag = eg.readBits(1)\n\n    let confWinLeftOffset\n    let confWinRightOffset\n    let confWinTopOffset\n    let confWinBottomOffset\n    if (conformanceWindowFlag === 1) {\n      confWinLeftOffset = eg.readUEG() // conf_win_left_offset\n      confWinRightOffset = eg.readUEG() // conf_win_right_offset\n      confWinTopOffset = eg.readUEG() // conf_win_top_offset\n      confWinBottomOffset = eg.readUEG() // conf_win_bottom_offset\n    }\n\n    hvcC.bitDepthLumaMinus8 = eg.readUEG() // bit_depth_luma_minus8\n    hvcC.bitDepthChromaMinus8 = eg.readUEG() // bit_depth_chroma_minus8\n\n    if (conformanceWindowFlag === 1) {\n      const subWidthC = (((chromaFormatIdc === 1) || (chromaFormatIdc === 2)) && (separateColourPlaneFlag === 0)) ? 2 : 1\n      const subHeightC = ((chromaFormatIdc === 1) && (separateColourPlaneFlag === 0)) ? 2 : 1\n      width -= (subWidthC * (confWinRightOffset + confWinLeftOffset))\n      height -= (subHeightC * (confWinBottomOffset + confWinTopOffset))\n    }\n\n    return {\n      codec: 'hev1.1.6.L93.B0',\n      width,\n      height,\n      chromaFormat,\n      hvcC\n    }\n  }\n\n  static _parseProfileTierLevel (eg, maxSubLayersMinus1, hvcC) {\n    const generalTierFlag = hvcC.generalTierFlag || 0\n    hvcC.generalProfileSpace = eg.readBits(2)\n    hvcC.generalTierFlag = Math.max(eg.readBits(1), generalTierFlag)\n    hvcC.generalProfileIdc = Math.max(eg.readBits(5), hvcC.generalProfileIdc || 0)\n    hvcC.generalProfileCompatibilityFlags = eg.readBits(32)\n    hvcC.generalConstraintIndicatorFlags = [eg.readBits(8), eg.readBits(8), eg.readBits(8), eg.readBits(8), eg.readBits(8), eg.readBits(8)]\n    const generalLevelIdc = eg.readBits(8)\n    if (generalTierFlag < hvcC.generalTierFlag) {\n      hvcC.generalLevelIdc = generalLevelIdc\n    } else {\n      hvcC.generalLevelIdc = Math.max(generalLevelIdc, hvcC.generalLevelIdc || 0)\n    }\n\n    const subLayerProfilePresentFlag = []\n    const subLayerLevelPresentFlag = []\n\n    if (maxSubLayersMinus1 > eg.bitsAvailable) {\n      throw new Error(`maxSubLayersMinus inavlid size ${maxSubLayersMinus1}`)\n    }\n\n    for (let j = 0; j < maxSubLayersMinus1; j++) {\n      subLayerProfilePresentFlag[j] = eg.readBits(1)\n      subLayerLevelPresentFlag[j] = eg.readBits(1)\n    }\n\n    if (maxSubLayersMinus1 > 0) {\n      eg.readBits((8 - maxSubLayersMinus1) * 2)\n    }\n\n    for (let i = 0; i < maxSubLayersMinus1; i++) {\n      if (subLayerProfilePresentFlag[i] !== 0) {\n        eg.readBits(2)\n        eg.readBits(1)\n        eg.readBits(5)\n\n        eg.readBits(16)\n        eg.readBits(16)\n\n        eg.readBits(4)\n\n        eg.readBits(16)\n        eg.readBits(16)\n        eg.readBits(12)\n      }\n      if (subLayerLevelPresentFlag[i] !== 0) {\n        eg.readBits(8)\n      }\n    }\n  }\n}\n","import { AudioCodecType, AudioSample, WarningType } from '../model'\nimport { AAC } from '../codec'\nimport { isSafari } from '../utils'\n\nconst LARGE_AV_FIRST_FRAME_GAP = 500 // ms\nconst AUDIO_GAP_OVERLAP_THRESHOLD_COUNT = 3\nconst MAX_SILENT_FRAME_DURATION = 1000 // ms\nconst AUDIO_EXCETION_LOG_EMIT_DURATION = 5000 // 5s\nconst MAX_VIDEO_FRAME_DURATION = 1000 // ms\nconst MAX_DTS_DELTA_WITH_NEXT_CHUNK = 200 // ms\nconst VIDEO_EXCETION_LOG_EMIT_DURATION = 5000 // 5s\nconst TRACK_BREACKED_CHECK_TIME = 5\n\nexport class FlvFixer {\n  constructor (videoTrack, audioTrack, metadataTrack) {\n    this.videoTrack = videoTrack\n    this.audioTrack = audioTrack\n    this.metadataTrack = metadataTrack\n\n    this._baseDts = -1\n    this._baseDtsInited = false\n\n    this._audioNextPts = undefined\n    this._videoNextDts = undefined\n\n    this._audioTimestampBreak = 0\n    this._videoTimestampBreak = 0\n    this._lastVideoDuration = 0\n\n    // 在视频帧遇到下一个关键帧之前，如果音频时间戳发生了跳变，不能确定是否音视频都发生跳变还是单纯音频发生跳变.\n    // 这里记录关键帧标识, 从下一个关键帧开始，如果视频没有跳变，才能判断是只有音频发生了跳变\n    this._keyFrameInNextChunk = false\n\n    this._lastAudioExceptionGapDot = -Infinity\n    this._lastAudioExceptionOverlapDot = -Infinity\n    this._lastAudioExceptionLargeGapDot = -Infinity\n\n    this._lastVideoExceptionLargeGapDot = -Infinity\n    this._lastVideoExceptionChunkFirstDtsDot = -Infinity\n  }\n\n  /**\n   * @param {number} startTime 点播seek到的时间点\n   * @param {boolean} discontinuity 是否换流\n   * @param {boolean} contiguous 前后chunk时间戳是否连续\n   */\n  fix (startTime = 0, discontinuity = false, contiguous = true) {\n    startTime = Math.round(startTime * 1000)\n    const videoTrack = this.videoTrack\n    const audioTrack = this.audioTrack\n\n    if (discontinuity || !contiguous) {\n      this._videoLastSample = null\n      this._audioNextPts = undefined\n      this._videoNextDts = undefined\n      this._audioTimestampBreak = 0\n      this._videoTimestampBreak = 0\n      this._lastAudioExceptionGapDot = -Infinity\n      this._lastAudioExceptionOverlapDot = -Infinity\n      this._lastAudioExceptionLargeGapDot = -Infinity\n      this._lastVideoExceptionLargeGapDot = -Infinity\n      this._lastVideoExceptionChunkFirstDtsDot = -Infinity\n    }\n\n    if (discontinuity && !contiguous) {\n      this._baseDtsInited = false\n    }\n\n    if (!this._baseDtsInited) {\n      this._calculateBaseDts(audioTrack, videoTrack)\n    }\n\n    if (!contiguous && startTime) {\n      this._audioNextPts = this._videoNextDts = startTime\n    }\n\n    const resetBaseDts = this._baseDtsInited &&\n      (this._videoTimestampBreak || !this.videoTrack.exist()) &&\n      (this._audioTimestampBreak || !this.audioTrack.exist())\n\n    if (resetBaseDts) {\n      this._resetBaseDtsWhenStreamBreaked()\n    }\n\n    this._fixAudio(audioTrack)\n\n    this._keyFrameInNextChunk = false\n\n    this._fixVideo(videoTrack)\n\n    if (this.metadataTrack.exist()) {\n      const timescale = this.metadataTrack.timescale\n      this.metadataTrack.seiSamples.forEach(s => {\n        s.pts = s.originPts - this._baseDts\n        s.time = Math.max(0, s.pts) / timescale\n      })\n      this.metadataTrack.flvScriptSamples.forEach(s => {\n        s.pts = s.originPts - this._baseDts\n        s.time = Math.max(0, s.pts) / timescale\n      })\n    }\n\n    if (videoTrack.samples.length) {\n      videoTrack.baseMediaDecodeTime = videoTrack.samples[0].dts\n    }\n    if (audioTrack.samples.length) {\n      audioTrack.baseMediaDecodeTime = audioTrack.samples[0].pts * audioTrack.timescale / 1000\n    }\n  }\n\n  _fixVideo (videoTrack) {\n    const samples = videoTrack.samples\n\n    if (!samples.length) return\n\n    samples.forEach(x => {\n      x.dts -= this._baseDts\n      x.pts -= this._baseDts\n      if (x.keyframe) this._keyFrameInNextChunk = true\n    })\n\n    let refSampleDurationInt\n    if (videoTrack.fpsNum && videoTrack.fpsDen) {\n      refSampleDurationInt = videoTrack.timescale * (videoTrack.fpsDen / videoTrack.fpsNum)\n    } else if (videoTrack.length > 1) {\n      const first = videoTrack.samples[0]\n      const last = videoTrack.samples[samples.length - 1]\n      refSampleDurationInt = Math.floor((last.dts - first.dts) / (samples.length - 1))\n    } else {\n      refSampleDurationInt = this._lastVideoDuration || 40\n    }\n\n    const lastSample = samples.pop()\n\n    if (this._videoLastSample) {\n      samples.unshift(this._videoLastSample)\n    }\n\n    this._videoLastSample = lastSample\n\n    if (!samples.length) return\n\n    if (this._videoNextDts === undefined) {\n      const samp0 = samples[0]\n      this._videoNextDts = samp0.dts\n    }\n\n    const len = samples.length\n    let sampleDuration = 0\n    const firstSample = samples[0]\n    const vDelta = this._videoNextDts - firstSample.dts\n\n    if (Math.abs(vDelta) > MAX_DTS_DELTA_WITH_NEXT_CHUNK) {\n      // emit large delta of first sample with expect\n      if (Math.abs(firstSample.dts - this._lastVideoExceptionChunkFirstDtsDot) > VIDEO_EXCETION_LOG_EMIT_DURATION) {\n        this._lastVideoExceptionChunkFirstDtsDot = firstSample.dts\n\n        videoTrack.warnings.push({\n          type: WarningType.LARGE_VIDEO_GAP_BETWEEN_CHUNK,\n          nextDts: this._videoNextDts,\n          firstSampleDts: firstSample.dts,\n          nextSampleDts: samples[1]?.dts,\n          sampleDuration: vDelta\n        })\n      }\n\n      // only video breaked\n      if (this._videoTimestampBreak >= TRACK_BREACKED_CHECK_TIME) {\n        this._videoNextDts = firstSample.dts\n        this._videoTimestampBreak = 0\n      } else {\n        // resolve first frame only\n        firstSample.dts += vDelta\n        firstSample.pts += vDelta\n        if (!this.audioTrack.exist()) {\n          this._videoTimestampBreak = 1\n        }\n      }\n    }\n\n    for (let i = 0; i < len; i++) {\n      const dts = samples[i].dts\n      const nextSample = samples[i + 1]\n\n      if (i < len - 1) {\n        sampleDuration = nextSample.dts - dts\n      } else if (lastSample) {\n        sampleDuration = lastSample.dts - dts\n      } else {\n        sampleDuration = refSampleDurationInt\n      }\n\n      if (sampleDuration > MAX_VIDEO_FRAME_DURATION || sampleDuration < 0) {\n        this._videoTimestampBreak++\n        // emit stream breaked\n        if (Math.abs(dts - this._lastVideoExceptionLargeGapDot) > VIDEO_EXCETION_LOG_EMIT_DURATION) {\n          this._lastVideoExceptionLargeGapDot = dts\n          videoTrack.warnings.push({\n            type: WarningType.LARGE_VIDEO_GAP,\n            time: dts / videoTrack.timescale,\n            dts,\n            originDts: samples[i].originDts,\n            nextDts: this._videoNextDts,\n            sampleDuration,\n            refSampleDuration: refSampleDurationInt\n          })\n        }\n\n        sampleDuration = refSampleDurationInt\n      }\n\n      samples[i].duration = sampleDuration\n      this._videoNextDts += sampleDuration\n      this._lastVideoDuration = sampleDuration\n    }\n  }\n\n  _fixAudio (audioTrack) {\n    const samples = audioTrack.samples\n    if (!samples.length) return\n\n    // offset origin timestamp\n    samples.forEach(x => {\n      x.dts = x.pts -= this._baseDts\n    })\n\n    this._doFixAudioInternal(audioTrack, samples, 1000)\n  }\n\n  _calculateBaseDts (audioTrack, videoTrack) {\n    const audioSamps = audioTrack.samples\n    const videoSamps = videoTrack.samples\n\n    if (!audioSamps.length && !videoSamps.length) {\n      return false\n    }\n\n    let audioBasePts = Infinity\n    let videoBaseDts = Infinity\n\n    if (audioSamps.length) {\n      audioTrack.baseDts = audioBasePts = audioSamps[0].pts\n    }\n\n    if (videoSamps.length) {\n      videoTrack.baseDts = videoBaseDts = videoSamps[0].dts\n    }\n\n    this._baseDts = Math.min(audioBasePts, videoBaseDts)\n\n    const delta = videoBaseDts - audioBasePts\n\n    if (Number.isFinite(delta) && Math.abs(delta) > LARGE_AV_FIRST_FRAME_GAP) {\n      videoTrack.warnings.push({\n        type: WarningType.LARGE_AV_SHIFT,\n        videoBaseDts,\n        audioBasePts,\n        baseDts: this._baseDts,\n        delta\n      })\n    }\n\n    this._baseDtsInited = true\n    return true\n  }\n\n  _resetBaseDtsWhenStreamBreaked () {\n    /**\n       * timestamp breaked\n       *                     _audioNextDts\n       *  ---------------------|\n       * (_baseDts)          _videoNextDts\n       * ----------------------|\n       *                        <----------------\n       *                                       nextVideo.dts\n       * ----------------------------------------|\n       *                                       nextAudio.dts\n       * ---------------------------------------|\n       */\n\n    // calc baseDts base on new samples\n    const calc = this._calculateBaseDts(this.audioTrack, this.videoTrack)\n\n    if (!calc) return\n\n    // consider the expect dts for next frame\n    if (!this.audioTrack.exist()){\n      this._baseDts -= this._videoNextDts\n    } else if (!this.videoTrack.exist()){\n      this._baseDts -= this._audioNextPts\n    } else {\n      this._baseDts -= Math.min(this._audioNextPts, this._videoNextDts)\n    }\n    this._videoTimestampBreak = 0\n    this._audioTimestampBreak = 0\n  }\n\n  _doFixAudioInternal (audioTrack, samples, timescale) {\n    if (!audioTrack.sampleDuration) {\n      audioTrack.sampleDuration = audioTrack.codecType === AudioCodecType.AAC\n        ? AAC.getFrameDuration(audioTrack.timescale, timescale)\n        : this._getG711Duration(audioTrack)\n    }\n    const refSampleDuration = audioTrack.sampleDuration\n\n    const sampleDurationInSampleRate = audioTrack.codecType === AudioCodecType.AAC ? 1024 : refSampleDuration * audioTrack.timescale / 1000\n\n    if (this._audioNextPts === undefined) {\n      const samp0 = samples[0]\n      this._audioNextPts = samp0.pts\n    }\n\n    for (let i = 0; i < samples.length; i++) {\n      let nextPts = this._audioNextPts\n      const sample = samples[i]\n      let delta = sample.pts - nextPts\n\n      // only audio breaked\n      if (i === 0 && this._audioTimestampBreak >= TRACK_BREACKED_CHECK_TIME && this._keyFrameInNextChunk) {\n        nextPts = this._audioNextPts = sample.dts\n        delta = 0\n        this._audioTimestampBreak = 0\n      }\n\n      // fill frames\n      // delta >= 3 * refSampleDurationInt\n      // delta <= 500s\n      if (!this._audioTimestampBreak && delta >= AUDIO_GAP_OVERLAP_THRESHOLD_COUNT * refSampleDuration && delta <= MAX_SILENT_FRAME_DURATION && !isSafari) {\n        const silentFrame = this._getSilentFrame(audioTrack) || samples[0].data.subarray()\n        const count = Math.floor(delta / refSampleDuration)\n\n        if (Math.abs(sample.pts - this._lastAudioExceptionGapDot) > AUDIO_EXCETION_LOG_EMIT_DURATION) {\n          this._lastAudioExceptionGapDot = sample.pts\n          audioTrack.warnings.push({\n            type: WarningType.AUDIO_FILLED,\n            pts: sample.pts,\n            originPts: sample.originPts,\n            count,\n            nextPts,\n            refSampleDuration\n          })\n        }\n\n        for (let j = 0; j < count; j++) {\n          const silentSample = new AudioSample(Math.floor(this._audioNextPts + refSampleDuration) - Math.floor(this._audioNextPts), silentFrame, sampleDurationInSampleRate)\n          silentSample.originPts = Math.floor(this._baseDts + nextPts)\n          samples.splice(i, 0, silentSample)\n          this._audioNextPts += refSampleDuration\n          i++\n        }\n\n        i--\n        // delta  <= -3 * refSampleDurationInt\n        // delta  >= -500ms\n      } else if (delta <= -AUDIO_GAP_OVERLAP_THRESHOLD_COUNT * refSampleDuration && delta >= -1 * MAX_SILENT_FRAME_DURATION) {\n        // need discard frames\n        if (Math.abs(sample.pts - this._lastAudioExceptionOverlapDot) > AUDIO_EXCETION_LOG_EMIT_DURATION) {\n          this._lastAudioExceptionOverlapDot = sample.pts\n\n          audioTrack.warnings.push({\n            type: WarningType.AUDIO_DROPPED,\n            pts: sample.pts,\n            originPts: sample.originPts,\n            nextPts,\n            refSampleDuration\n          })\n        }\n        samples.splice(i, 1)\n        i--\n      } else {\n        if (Math.abs(delta) > MAX_SILENT_FRAME_DURATION) {\n          this._audioTimestampBreak++\n\n          if (Math.abs(sample.pts - this._lastAudioExceptionLargeGapDot) > AUDIO_EXCETION_LOG_EMIT_DURATION) {\n            this._lastAudioExceptionLargeGapDot = sample.pts\n            audioTrack.warnings.push({\n              type: WarningType.LARGE_AUDIO_GAP,\n              time: sample.pts / 1000,\n              pts: sample.pts,\n              originPts: sample.originPts,\n              nextPts,\n              sampleDuration: delta,\n              refSampleDuration\n            })\n          }\n        }\n\n        sample.dts = sample.pts = nextPts\n        sample.duration = sampleDurationInSampleRate\n        this._audioNextPts += refSampleDuration\n      }\n    }\n  }\n\n  _getG711Duration (track) {\n    const { sampleSize, channelCount, sampleRate } = track\n    const samp0 = track.samples[0]\n    if (!samp0) return\n    return samp0.data.byteLength * 2 / channelCount / (sampleSize / 8) / sampleRate * 1000\n  }\n\n  _getSilentFrame (track) {\n    if (track.codecType === AudioCodecType.AAC) return AAC.getSilentFrame(track.codec, track.channelCount)\n    return new Uint8Array(8 * track.sampleDuration * track.channelCount)\n  }\n}\n","import { UTF8 } from '../utils'\n\nexport class AMF {\n  static parse (data) {\n    if (data.length < 3) return\n\n    const ret = {}\n    const name = AMF._parseValue(new DataView(data.buffer, data.byteOffset, data.byteLength))\n    const value = AMF._parseValue(new DataView(data.buffer, data.byteOffset + name.size, data.byteLength - name.size))\n    ret[name.data] = value.data\n\n    return ret\n  }\n\n  static _parseValue (view) {\n    const dataLen = view.byteLength\n    const type = view.getUint8(0)\n    let offset = 1\n    let isEnd = false\n    let value\n\n    switch (type) {\n      case 0: // Number(Double) type\n        value = view.getFloat64(1)\n        offset += 8\n        break\n      case 1: { // Boolean type\n        value = !!view.getUint8(1)\n        offset += 1\n        break\n      }\n      case 2: { // String type\n        const { data, size } = AMF._parseString(new DataView(view.buffer, view.byteOffset + offset, view.byteLength - offset))\n        value = data\n        offset += size\n      }\n        break\n      case 3: { // Object(s) type\n        value = {}\n        let terminal = 0\n        if ((view.getUint32(dataLen - 4) & 0x00FFFFFF) === 9) {\n          terminal = 3\n        }\n        while (offset < dataLen - 4) { // 4 === type(UI8) + ScriptDataObjectEnd(UI24)\n          const { size, data, isEnd } = AMF._parseObject(new DataView(view.buffer, view.byteOffset + offset, view.byteLength - offset - terminal))\n          if (isEnd) break\n          value[data.name] = data.value\n          offset += size\n        }\n        if (offset <= dataLen - 3) {\n          const marker = view.getUint32(offset - 1) & 0x00FFFFFF\n          if (marker === 9) offset += 3\n        }\n      }\n        break\n      case 8: { // ECMA array type (Mixed array)\n        value = {}\n        offset += 4 // ECMAArrayLength(UI32)\n        let terminal = 0 // workaround for malformed MixedArrays which has missing ScriptDataObjectEnd\n        if ((view.getUint32(dataLen - 4) & 0x00FFFFFF) === 9) {\n          terminal = 3\n        }\n        while (offset < dataLen - 8) { // 8 === type(UI8) + ECMAArrayLength(UI32) + ScriptDataVariableEnd(UI24)\n          const { size, data, isEnd } = AMF._parseObject(new DataView(view.buffer, view.byteOffset + offset, view.byteLength - offset - terminal))\n          if (isEnd) break\n          value[data.name] = data.value\n          offset += size\n        }\n        if (offset <= dataLen - 3) {\n          const marker = view.getUint32(offset - 1) & 0x00FFFFFF\n          if (marker === 9) {\n            offset += 3\n          }\n        }\n      }\n        break\n      case 9: // ScriptDataObjectEnd\n        value = undefined\n        offset = 1\n        isEnd = true\n        break\n      case 10: { // Strict array type\n        value = []\n        const strictArrayLength = view.getUint32(1)\n        offset += 4\n        for (let i = 0; i < strictArrayLength; i++) {\n          const { data, size } = AMF._parseValue(new DataView(view.buffer, view.byteOffset + offset, view.byteLength - offset))\n          value.push(data)\n          offset += size\n        }\n      }\n        break\n      case 11: { // Date type\n        const timestamp = view.getFloat64(offset) + view.getInt16(offset + 8) * 60000\n        value = new Date(timestamp)\n        offset += 10\n      }\n        break\n      case 12: { // Long string type\n        const length = view.getUint32(1)\n        offset += 4\n        value = ''\n        if (length > 0) {\n          value = UTF8.decode(new Uint8Array(view.buffer, view.byteOffset + offset, length))\n        }\n        offset += length\n      }\n        break\n      default:\n        offset = dataLen\n        break\n    }\n\n    return {\n      data: value,\n      size: offset,\n      isEnd\n    }\n  }\n\n  static _parseString (view) {\n    const length = view.getUint16(0)\n    let data = ''\n    if (length > 0) {\n      data = UTF8.decode(new Uint8Array(view.buffer, view.byteOffset + 2, length))\n    }\n\n    return {\n      data,\n      size: 2 + length\n    }\n  }\n\n  static _parseObject (view) {\n    if (view.byteLength < 3) return\n\n    const name = AMF._parseString(view)\n    const value = AMF._parseValue(new DataView(view.buffer, view.byteOffset + name.size, view.byteLength - name.size))\n\n    return {\n      data: {\n        name: name.data,\n        value: value.data\n      },\n      size: name.size + value.size,\n      isEnd: value.isEnd\n    }\n  }\n}\n","import { VideoTrack, AudioTrack, MetadataTrack, AudioSample, VideoSample, VideoCodecType, AudioCodecType, FlvScriptSample, SeiSample } from '../model'\nimport { FlvFixer } from './fixer'\nimport { concatUint8Array, Logger, readBig32 } from '../utils'\nimport { AAC, AVC, HEVC, NALu } from '../codec'\nimport { AMF } from './amf'\n\nconst logger = new Logger('FlvDemuxer')\n\n/**\n * @typedef {Object} DemuxResult\n * @property {VideoTrack} videoTrack\n * @property {AudioTrack} audioTrack\n * @property {MetadataTrack} metadataTrack\n */\n\nexport class FlvDemuxer {\n  _headerParsed = false\n  _remainingData = null\n  _gopId = 0\n  _needAddMetaBeforeKeyFrameNal = true // 标识H265流中关键帧Nal之前是否需要插入vps、sps、pps Nal\n\n  static AUDIO_RATE = [5500, 11000, 22000, 44000]\n\n  /**\n   * @param {VideoTrack} [videoTrack]\n   * @param {AudioTrack} [audioTrack]\n   * @param {MetadataTrack} [metadataTrack]\n   */\n  constructor (videoTrack, audioTrack, metadataTrack) {\n    this.videoTrack = videoTrack || new VideoTrack()\n    this.audioTrack = audioTrack || new AudioTrack()\n    this.metadataTrack = metadataTrack || new MetadataTrack()\n    this._fixer = new FlvFixer(this.videoTrack, this.audioTrack, this.metadataTrack)\n  }\n\n  /**\n   * @param {Uint8Array} data\n   * @param {boolean} [discontinuity=false] 切流\n   * @param {boolean} [contiguous=true]\n   * @returns {DemuxResult}\n   */\n  demux (data, discontinuity = false, contiguous = true) {\n    const { audioTrack, videoTrack, metadataTrack } = this\n\n    if (discontinuity || !contiguous) {\n      this._remainingData = null\n    }\n\n    if (discontinuity) {\n      this._headerParsed = false\n    }\n\n    if (discontinuity) {\n      videoTrack.reset()\n      audioTrack.reset()\n      metadataTrack.reset()\n    } else {\n      videoTrack.samples = []\n      audioTrack.samples = []\n      metadataTrack.seiSamples = []\n      metadataTrack.flvScriptSamples = []\n      videoTrack.warnings = []\n      audioTrack.warnings = []\n\n      if (this._remainingData) {\n        data = concatUint8Array(this._remainingData, data)\n        this._remainingData = null\n      }\n    }\n\n    if (!data.length) {\n      return {\n        videoTrack,\n        audioTrack,\n        metadataTrack\n      }\n    }\n\n    let offset = 0\n    if (!this._headerParsed) {\n      if (!FlvDemuxer.probe(data)) {\n        throw new Error('Invalid flv file')\n      }\n      audioTrack.present = ((data[4] & 4) >>> 2) !== 0\n      videoTrack.present = (data[4] & 1) !== 0\n      this._headerParsed = true\n      offset = readBig32(data, 5) + 4 // skip prev tag size\n    }\n\n    const dataLen = data.length\n\n    let tagType\n    let dataSize\n    let timestamp\n    let bodyData\n    let prevTagSize\n    while ((offset + 15) < dataLen) { // header and prev tag size\n      tagType = data[offset]\n      dataSize = (data[offset + 1] << 16) | (data[offset + 2] << 8) | data[offset + 3]\n      if (offset + 15 + dataSize > dataLen) break\n      timestamp = (\n        (data[offset + 7] << 24 >>> 0) +\n        (data[offset + 4] << 16) +\n        (data[offset + 5] << 8) +\n        data[offset + 6]\n      )\n\n      offset += 11\n      bodyData = data.subarray(offset, offset + dataSize)\n      if (tagType === 8) {\n        this._parseAudio(bodyData, timestamp)\n      } else if (tagType === 9) {\n        this._parseVideo(bodyData, timestamp)\n      } else if (tagType === 18) {\n        this._parseScript(bodyData, timestamp)\n      } else {\n        logger.warn(`Invalid tag type: ${tagType}`)\n      }\n\n      offset += dataSize\n      prevTagSize = readBig32(data, offset)\n      if (prevTagSize !== 11 + dataSize) {\n        logger.warn(`Invalid PrevTagSize ${prevTagSize} (${11 + dataSize})`)\n      }\n\n      offset += 4\n    }\n\n    if (offset < dataLen) {\n      this._remainingData = data.subarray(offset)\n    }\n\n    audioTrack.formatTimescale = videoTrack.formatTimescale = videoTrack.timescale = metadataTrack.timescale = 1000\n    audioTrack.timescale = audioTrack.sampleRate || 0\n\n    if (!audioTrack.exist() && audioTrack.hasSample()) {\n      audioTrack.reset()\n    }\n    if (!videoTrack.exist() && videoTrack.hasSample()) {\n      videoTrack.reset()\n    }\n\n    return {\n      videoTrack,\n      audioTrack,\n      metadataTrack\n    }\n  }\n\n  /**\n   * @param {number} [startTime=0]\n   * @param {boolean} [discontinuity=false]\n   * @param {boolean} [contiguous=true]\n   * @returns {DemuxResult}\n   */\n  fix (startTime, discontinuity, contiguous) {\n    this._fixer.fix(startTime, discontinuity, contiguous)\n    return {\n      videoTrack: this.videoTrack,\n      audioTrack: this.audioTrack,\n      metadataTrack: this.metadataTrack\n    }\n  }\n\n  /**\n   * @param {Uint8Array} data\n   * @param {boolean} [discontinuity=false]\n   * @param {boolean} [contiguous=true]\n   * @param {number} [startTime=0]\n   * @returns {DemuxResult}\n   */\n  demuxAndFix (data, discontinuity, contiguous, startTime) {\n    this.demux(data, discontinuity, contiguous)\n    return this.fix(startTime, discontinuity, contiguous)\n  }\n\n  /**\n   * @param { Uint8Array } data\n   * @returns {boolean}\n   */\n  static probe (data) {\n    if (data[0] !== 0x46 || data[1] !== 0x4C || data[2] !== 0x56 || data[3] !== 0x01) {\n      return false\n    }\n    return readBig32(data, 5) >= 9\n  }\n\n  _parseAudio (data, pts) {\n    if (!data.length) return\n\n    const format = (data[0] & 0xf0) >>> 4\n    const track = this.audioTrack\n\n    if (\n      format !== 10 && // AAC\n      format !== 7 && // G.711 A-law logarithmic PCM\n      format !== 8 // G.711 mu-law logarithmic PCM\n    ) {\n      logger.warn(`Unsupported sound format: ${format}`)\n      track.reset()\n      return\n    }\n\n    if (format !== 10) {\n      const soundRate = (data[0] & 0x0c) >> 2\n      const soundSize = (data[0] & 0x02) >> 1\n      const soundType = (data[0] & 0x01)\n      track.sampleRate = FlvDemuxer.AUDIO_RATE[soundRate]\n      track.sampleSize = soundSize ? 16 : 8\n      track.channelCount = soundType + 1\n    }\n\n    if (format === 10) {\n      this._parseAac(data, pts)\n    } else {\n      this._parseG711(data, pts, format)\n    }\n  }\n\n  _parseG711 (data, pts, format) {\n    const track = this.audioTrack\n    track.codecType = format === 7 ? AudioCodecType.G711PCMA : AudioCodecType.G711PCMU\n    track.sampleRate = 8000\n    track.codec = track.codecType\n    track.samples.push(new AudioSample(pts, data.subarray(1)))\n  }\n\n  _parseAac (data, pts) {\n    const track = this.audioTrack\n    track.codecType = AudioCodecType.AAC\n\n    if (data[1] === 0) { // AACPacketType\n      const ret = AAC.parseAudioSpecificConfig(data.subarray(2))\n      if (ret) {\n        track.codec = ret.codec\n        track.channelCount = ret.channelCount\n        track.sampleRate = ret.sampleRate\n        track.config = ret.config\n        track.objectType = ret.objectType\n        track.sampleRateIndex = ret.samplingFrequencyIndex\n      } else {\n        track.reset()\n        logger.warn('Cannot parse AudioSpecificConfig', data)\n      }\n    } else if (data[1] === 1) { // Raw AAC frame data\n      if (pts === undefined || pts === null) return\n      track.samples.push(new AudioSample(pts, data.subarray(2)))\n    } else {\n      logger.warn(`Unknown AACPacketType: ${data[1]}`)\n    }\n  }\n\n  _parseVideo (data, dts) {\n    if (data.length < 6) return\n\n    const frameType = (data[0] & 0xf0) >>> 4\n    const codecId = data[0] & 0x0f\n\n    const track = this.videoTrack\n\n    if (\n      codecId !== 7 && // AVC\n      codecId !== 12 // HEVC\n    ) {\n      track.reset()\n      logger.warn(`Unsupported codecId: ${codecId}`)\n      return\n    }\n\n    const isHevc = codecId === 12\n    track.codecType = isHevc ? VideoCodecType.HEVC : VideoCodecType.AVC\n\n    const packetType = data[1]\n    const cts = (((data[2] << 16) | (data[3] << 8) | (data[4])) << 8) >> 8\n\n    if (packetType === 0) { // DecoderConfigurationRecord\n      const configData = data.subarray(5)\n      const ret = isHevc\n        ? HEVC.parseHEVCDecoderConfigurationRecord(configData)\n        : AVC.parseAVCDecoderConfigurationRecord(configData)\n      if (ret) {\n        const { hvcC, sps, ppsArr, spsArr, vpsArr, nalUnitSize } = ret\n        if (hvcC) {\n          track.hvcC = track.hvcC || hvcC\n        }\n        if (sps) {\n          track.codec = sps.codec\n          track.width = sps.width\n          track.height = sps.height\n          track.sarRatio = sps.sarRatio\n          track.fpsNum = sps.fpsNum\n          track.fpsDen = sps.fpsDen\n        }\n        if (spsArr.length) track.sps = spsArr\n        if (ppsArr.length) track.pps = ppsArr\n        if (vpsArr && vpsArr.length) track.vps = vpsArr\n        if (nalUnitSize) track.nalUnitSize = nalUnitSize\n      } else {\n        logger.warn(`Cannot parse ${isHevc ? 'HEVC' : 'AVC'}DecoderConfigurationRecord`, data)\n      }\n    } else if (packetType === 1) { // One or more NALUs\n      let units = NALu.parseAvcC(data.subarray(5), track.nalUnitSize)\n\n      units = this._checkAddMetaNalToUnits(isHevc, units, track)\n\n      if (units && units.length) {\n        const sample = new VideoSample(dts + cts, dts, units)\n        if (frameType === 1) {\n          sample.setToKeyframe()\n        }\n        track.samples.push(sample)\n\n        units.forEach(unit => {\n          const type = isHevc ? (unit[0] >>> 1) & 0x3f : unit[0] & 0x1f\n          switch (type) {\n            case 5: // IDR\n            case 16: // HEVC BLA_W_LP\n            case 17: // HEVC BLA_W_RADL\n            case 18: // HEVC BLA_N_LP\n            case 19: // HEVC IDR_W_RADL\n            case 20: // HEVC IDR_N_LP\n            case 21: // HEVC CRA_NUT\n            case 22: // HEVC RSV_IRAP_VCL22\n            case 23: // HEVC RSV_IRAP_VCL23\n              if ((!isHevc && type !== 5) || (isHevc && type === 5)) break\n              sample.setToKeyframe()\n              break\n            case 6: // SEI\n            case 39: // HEVC PREFIX_SEI\n            case 40: // HEVC SUFFIX_SEI\n              if ((!isHevc && type !== 6) || (isHevc && type === 6)) break\n              this.metadataTrack.seiSamples.push(new SeiSample(\n                NALu.parseSEI(NALu.removeEPB(unit), isHevc),\n                dts + cts\n              ))\n              break\n            default:\n          }\n        })\n\n        if (sample.keyframe) {\n          this._gopId++\n        }\n        sample.gopId = this._gopId\n      } else {\n        logger.warn('Cannot parse NALUs', data)\n      }\n    } else if (packetType === 2) {\n      // AVC end of sequence, Empty\n    } else {\n      logger.warn(`Unknown AVCPacketType: ${packetType}`)\n    }\n  }\n\n  _checkAddMetaNalToUnits (hevc, units, track) {\n    if (!hevc || !this._needAddMetaBeforeKeyFrameNal) {\n      this._needAddMetaBeforeKeyFrameNal = false\n      return units\n    }\n\n    const nalTypes = units.map(x => (x[0] >>> 1) & 0x3f)\n\n    if (nalTypes.includes(32)) {\n      this._needAddMetaBeforeKeyFrameNal = false\n      return units\n    }\n\n    units.unshift(track.pps[0])\n    units.unshift(track.sps[0])\n    units.unshift(track.vps[0])\n\n    return units.filter(Boolean)\n  }\n\n  _parseScript (data, pts) {\n    this.metadataTrack.flvScriptSamples.push(new FlvScriptSample(AMF.parse(data), pts))\n  }\n}\n","import { AudioSample, WarningType } from '../model'\nimport { AAC } from '../codec'\nimport { isSafari } from '../utils'\n\nconst LARGE_AV_FIRST_FRAME_GAP = 90000 / 2 // 500ms\nconst AUDIO_GAP_OVERLAP_THRESHOLD_COUNT = 3\nconst MAX_SILENT_FRAME_DURATION = 90000 // 1s\nconst AUDIO_EXCETION_LOG_EMIT_DURATION = 5 * 90000 // 5s\nconst MAX_VIDEO_FRAME_DURATION = 90000 // 1s\nconst MAX_DTS_DELTA_WITH_NEXT_CHUNK = 90000 / 2 // 500ms\n\nexport class TsFixer {\n  constructor (videoTrack, audioTrack, metadataTrack) {\n    this.videoTrack = videoTrack\n    this.audioTrack = audioTrack\n    this.metadataTrack = metadataTrack\n\n    this._baseDts = -1\n    this._baseDtsInited = false\n\n    this._audioNextPts = undefined\n    this._videoNextDts = undefined\n\n    this._audioTimestampBreak = false\n    this._videoTimestampBreak = false\n\n    this._lastAudioExceptionGapDot = 0\n    this._lastAudioExceptionOverlapDot = 0\n    this._lastAudioExceptionLargeGapDot = 0\n  }\n\n  fix (startTime = 0, discontinuity = false, contiguous = true) {\n    startTime = Math.round(startTime * 90000)\n    const videoTrack = this.videoTrack\n    const audioTrack = this.audioTrack\n\n    const vSamples = videoTrack.samples\n    const aSamples = audioTrack.samples\n\n    if (!vSamples.length && !aSamples.length) return\n\n    const firstVideoSample = vSamples[0]\n    const firstAudioSample = aSamples[0]\n\n    // consider av delta\n    let vaDelta = 0\n\n    if (vSamples.length && aSamples.length) {\n      vaDelta = firstVideoSample.dts - firstAudioSample.pts\n    }\n\n    if (!this._baseDtsInited) {\n      this._calculateBaseDts(this.audioTrack, this.videoTrack)\n    }\n\n    // recalc baseDts\n    if (discontinuity) {\n      this._calculateBaseDts(this.audioTrack, this.videoTrack)\n      this._baseDts -= startTime\n    }\n\n    // id discontinue, recalc nextDts, consider av delta of firstframe\n    if (!contiguous) {\n      /**\n       *  segment.start = min(a, v)\n       *  segment.start\n       *      |\n       *      a\n       *       -- vaDelta --\n       *                   v\n       */\n      this._videoNextDts = vaDelta > 0 ? startTime + vaDelta : startTime\n      this._audioNextPts = vaDelta > 0 ? startTime : startTime - vaDelta\n\n      const vDeltaToNextDts = firstVideoSample ? firstVideoSample.dts - this._baseDts - this._videoNextDts : 0\n      const aDeltaToNextDts = firstAudioSample ? firstAudioSample.pts - this._baseDts - this._audioNextPts : 0\n\n      if (Math.abs(vDeltaToNextDts || aDeltaToNextDts) > MAX_VIDEO_FRAME_DURATION) {\n        this._calculateBaseDts(this.audioTrack, this.videoTrack)\n        this._baseDts -= startTime\n      }\n    }\n\n    this._resetBaseDtsWhenStreamBreaked()\n\n    // fix audio first\n    this._fixAudio(audioTrack)\n\n    this._fixVideo(videoTrack)\n\n    if (this.metadataTrack.exist()) {\n      const timescale = this.metadataTrack.timescale\n      this.metadataTrack.seiSamples.forEach(s => {\n        s.pts = s.originPts - this._baseDts\n        s.time = Math.max(0, s.pts) / timescale\n      })\n    }\n\n    if (videoTrack.samples.length) {\n      videoTrack.baseMediaDecodeTime = videoTrack.samples[0].dts\n    }\n    if (audioTrack.samples.length) {\n      audioTrack.baseMediaDecodeTime = audioTrack.samples[0].pts * audioTrack.timescale / 90000\n    }\n  }\n\n  _fixVideo (videoTrack) {\n    const samples = videoTrack.samples\n\n    if (!samples.length) return\n    samples.forEach(x => {\n      x.dts -= this._baseDts\n      x.pts -= this._baseDts\n    })\n\n    if (this._videoNextDts === undefined) {\n      const samp0 = samples[0]\n      this._videoNextDts = samp0.dts\n    }\n\n    const len = samples.length\n    let sampleDuration = 0\n    const firstSample = samples[0]\n    const nextSample = samples[1]\n    const vDelta = this._videoNextDts - firstSample.dts\n\n    if (Math.abs(vDelta) > MAX_DTS_DELTA_WITH_NEXT_CHUNK) {\n      videoTrack.warnings.push({\n        type: WarningType.LARGE_VIDEO_GAP_BETWEEN_CHUNK,\n        nextDts: this._videoNextDts / 90,\n        firstSampleDts: firstSample.dts / 90,\n        nextSampleDts: (samples[1]?.dts || 0) / 90,\n        sampleDuration: vDelta / 90\n      })\n\n      // resolve first frame first\n      firstSample.dts += vDelta\n      firstSample.pts += vDelta\n\n\n      // check to ajust the whole segment\n      if (nextSample && Math.abs(nextSample.dts - firstSample.dts) > MAX_VIDEO_FRAME_DURATION) {\n        this._videoTimestampBreak = true\n        samples.forEach((x, i) => {\n          if (i === 0) return\n          x.dts += vDelta\n          x.pts += vDelta\n        })\n      } else {\n        for (let i = 1; i < len - 1; i++) {\n          const dts = samples[i]?.dts\n          const prevDts = samples[i - 1 ].dts\n          if (dts && dts - prevDts < 0) {\n            samples[i].dts += vDelta\n            samples[i].pts += vDelta\n          }\n        }\n      }\n    }\n\n    let refSampleDurationInt\n    if (videoTrack.fpsNum && videoTrack.fpsDen) {\n      refSampleDurationInt = videoTrack.timescale * (videoTrack.fpsDen / videoTrack.fpsNum)\n    }\n\n    // fps inaccuracy\n    if (refSampleDurationInt < 90 * 10) { // < 10ms per frame\n      refSampleDurationInt = 0\n    }\n\n    if (!refSampleDurationInt) {\n      const first = videoTrack.samples[0]\n      const second = videoTrack.samples[1]\n      // 100ms default\n      refSampleDurationInt = len === 1 ? 9000 : Math.floor((second.dts - first.dts))\n    }\n\n    for (let i = 0; i < len; i++) {\n      const dts = samples[i].dts\n      const nextSample = samples[i + 1]\n      if (i < len - 1) {\n        sampleDuration = nextSample.dts - dts\n      } else if (samples[i - 1]) {\n        sampleDuration = Math.min(dts - samples[i - 1].dts, refSampleDurationInt)\n      } else {\n        sampleDuration = refSampleDurationInt\n      }\n\n      if (sampleDuration > MAX_VIDEO_FRAME_DURATION || sampleDuration < 0) {\n        // dts exception of adjacent frame\n        this._videoTimestampBreak = true\n\n        // check if only video breaked!\n        sampleDuration = this._audioTimestampBreak ? refSampleDurationInt : Math.max(sampleDuration, 30 * 90) // 30ms\n\n        // check if sample breaked within current fragment\n        const expectFragEnd = (this._audioNextPts || 0)\n        if (nextSample && nextSample.dts > expectFragEnd) {\n          sampleDuration = refSampleDurationInt\n        }\n\n        videoTrack.warnings.push({\n          type: WarningType.LARGE_VIDEO_GAP,\n          time: dts / videoTrack.timescale,\n          dts,\n          originDts: samples[i].originDts,\n          nextDts: this._videoNextDts,\n          sampleDuration,\n          refSampleDuration: refSampleDurationInt\n        })\n      }\n\n      samples[i].duration = sampleDuration\n      this._videoNextDts += sampleDuration\n    }\n  }\n\n  _fixAudio (audioTrack) {\n    const samples = audioTrack.samples\n\n    if (!samples.length) return\n    samples.forEach(x => {\n      x.pts -= this._baseDts\n      x.dts = x.pts\n    })\n\n    this._doFixAudioInternal(audioTrack, samples, 90000)\n  }\n\n  _calculateBaseDts (audioTrack, videoTrack) {\n    const audioSamps = audioTrack.samples\n    const videoSamps = videoTrack.samples\n\n    if (!audioSamps.length && !videoSamps.length) {\n      return false\n    }\n\n    let audioBasePts = Infinity\n    let videoBaseDts = Infinity\n\n    if (audioSamps.length) {\n      audioTrack.baseDts = audioBasePts = audioSamps[0].pts\n    }\n\n    if (videoSamps.length) {\n      videoTrack.baseDts = videoBaseDts = videoSamps[0].dts\n    }\n\n    this._baseDts = Math.min(audioBasePts, videoBaseDts)\n\n    const delta = videoBaseDts - audioBasePts\n\n    if (Number.isFinite(delta) && Math.abs(delta) > LARGE_AV_FIRST_FRAME_GAP) {\n      videoTrack.warnings.push({\n        type: WarningType.LARGE_AV_SHIFT,\n        videoBaseDts,\n        audioBasePts,\n        baseDts: this._baseDts,\n        delta\n      })\n    }\n\n    this._baseDtsInited = true\n    return true\n  }\n\n  _resetBaseDtsWhenStreamBreaked () {\n    if (this._baseDtsInited && this._videoTimestampBreak && this._audioTimestampBreak) {\n      /**\n       * timestamp breaked\n       *                     _audioNextDts\n       *  ---------------------|\n       * (_baseDts)          _videoNextDts\n       * ----------------------|\n       *                        <----------------\n       *                                       nextVideo.dts\n       * ----------------------------------------|\n       *                                       nextAudio.dts\n       * ---------------------------------------|\n       */\n\n      // calc baseDts base on new samples\n      const calc = this._calculateBaseDts(this.audioTrack, this.videoTrack)\n\n      if (!calc) return\n\n      // consider the expect dts for next frame\n      this._baseDts -= Math.min(this._audioNextPts, this._videoNextDts)\n      this._audioLastSample = null\n      this._videoLastSample = null\n      this._videoTimestampBreak = false\n      this._audioTimestampBreak = false\n    }\n  }\n\n  _doFixAudioInternal (audioTrack, samples, timescale) {\n    if (!audioTrack.sampleDuration) audioTrack.sampleDuration = AAC.getFrameDuration(audioTrack.timescale, timescale)\n    const refSampleDuration = audioTrack.sampleDuration\n\n    if (this._audioNextPts === undefined) {\n      const samp0 = samples[0]\n      this._audioNextPts = samp0.pts\n    }\n\n    for (let i = 0; i < samples.length; i++) {\n      const nextPts = this._audioNextPts\n      const sample = samples[i]\n      const delta = sample.pts - nextPts\n\n      // fill frames\n      // delta >= 3 * refSampleDurationInt\n      // delta <= 500s\n      if (!this._audioTimestampBreak && delta >= AUDIO_GAP_OVERLAP_THRESHOLD_COUNT * refSampleDuration && delta <= MAX_SILENT_FRAME_DURATION && !isSafari) {\n        const silentFrame = AAC.getSilentFrame(audioTrack.codec, audioTrack.channelCount) || samples[0].data.subarray()\n        const count = Math.floor(delta / refSampleDuration)\n\n        if (Math.abs(sample.pts - this._lastAudioExceptionGapDot) > AUDIO_EXCETION_LOG_EMIT_DURATION) {\n          this._lastAudioExceptionGapDot = sample.pts\n        }\n\n        audioTrack.warnings.push({\n          type: WarningType.AUDIO_FILLED,\n          pts: sample.pts / 90,\n          originPts: sample.originPts,\n          count,\n          nextPts: nextPts / 90,\n          refSampleDuration\n        })\n\n        for (let j = 0; j < count; j++) {\n          const silentSample = new AudioSample(Math.floor(nextPts), silentFrame)\n          silentSample.originPts = Math.floor(this._baseDts + nextPts)\n          samples.splice(i, 0, silentSample)\n          this._audioNextPts += refSampleDuration\n          i++\n        }\n\n        i--\n        // delta  <= -3 * refSampleDurationInt\n        // delta  >= -500ms\n      } else if (delta <= -AUDIO_GAP_OVERLAP_THRESHOLD_COUNT * refSampleDuration && delta >= -1 * MAX_SILENT_FRAME_DURATION) {\n        // need discard frames\n        if (Math.abs(sample.pts - this._lastAudioExceptionOverlapDot) > AUDIO_EXCETION_LOG_EMIT_DURATION) {\n          this._lastAudioExceptionOverlapDot = sample.pts\n          audioTrack.warnings.push({\n            type: WarningType.AUDIO_DROPPED,\n            pts: sample.pts / 90,\n            originPts: sample.originPts,\n            nextPts: nextPts / 90,\n            refSampleDuration\n          })\n        }\n        samples.splice(i, 1)\n        i--\n      } else {\n        if (Math.abs(delta) >= MAX_SILENT_FRAME_DURATION) {\n          this._audioTimestampBreak = true\n\n          if (Math.abs(sample.pts - this._lastAudioExceptionLargeGapDot) > AUDIO_EXCETION_LOG_EMIT_DURATION) {\n            this._lastAudioExceptionLargeGapDot = sample.pts\n            audioTrack.warnings.push({\n              type: WarningType.LARGE_AUDIO_GAP,\n              time: sample.pts / 1000,\n              pts: sample.pts / 90,\n              originPts: sample.originPts,\n              nextPts: nextPts / 90,\n              sampleDuration: delta,\n              refSampleDuration\n            })\n          }\n        }\n\n        sample.dts = sample.pts = nextPts\n        this._audioNextPts += refSampleDuration\n      }\n    }\n  }\n}\n","import { TsFixer } from './fixer'\nimport { AVC, AAC, HEVC, NALu } from '../codec'\nimport { VideoSample, AudioSample, VideoCodecType, VideoTrack, AudioTrack, MetadataTrack, SeiSample } from '../model'\nimport { Logger, concatUint8Array } from '../utils'\n\nconst logger = new Logger('TsDemuxer')\n\nexport class TsDemuxer {\n  _pmtId = -1\n  _remainingPacketData = null\n  _videoPesData = []\n  _audioPesData = []\n  _gopId = 0\n\n  /**\n   * @param {VideoTrack} [videoTrack]\n   * @param {AudioTrack} [audioTrack]\n   * @param {MetadataTrack} [metadataTrack]\n   */\n  constructor (videoTrack, audioTrack, metadataTrack) {\n    this.videoTrack = videoTrack || new VideoTrack()\n    this.audioTrack = audioTrack || new AudioTrack()\n    this.metadataTrack = metadataTrack || new MetadataTrack()\n    this._fixer = new TsFixer(this.videoTrack, this.audioTrack, this.metadataTrack)\n  }\n\n  /**\n   * @param {Uint8Array} data\n   * @param {boolean} [discontinuity=false]\n   * @param {boolean} [contiguous=true]\n   * @returns {import('../flv').DemuxResult}\n   */\n  demux (data, discontinuity = false, contiguous = true) {\n    const { audioTrack, videoTrack, metadataTrack } = this\n\n    if (discontinuity) {\n      this._pmtId = -1\n      videoTrack.reset()\n      audioTrack.reset()\n      metadataTrack.reset()\n    }\n\n    if (!contiguous || discontinuity) {\n      this._remainingPacketData = null\n      this._videoPesData = []\n      this._audioPesData = []\n    } else {\n      videoTrack.samples = []\n      audioTrack.samples = []\n      metadataTrack.seiSamples = []\n      videoTrack.warnings = []\n      audioTrack.warnings = []\n\n      if (this._remainingPacketData) {\n        data = concatUint8Array(this._remainingPacketData, data)\n        this._remainingPacketData = null\n      }\n    }\n\n    let dataLen = data.length\n    const remainingLength = dataLen % 188\n    if (remainingLength) {\n      this._remainingPacketData = data.subarray(dataLen - remainingLength)\n      dataLen -= remainingLength\n    }\n\n    let videoPid = videoTrack.pid\n    let audioPid = audioTrack.pid\n\n    for (let start = 0; start < dataLen; start += 188) {\n      if (data[start] !== 0x47) throw new Error('TS packet did not start with 0x47')\n      const payloadUnitStartIndicator = !!(data[start + 1] & 0x40)\n      const pid = ((data[start + 1] & 0x1f) << 8) + data[start + 2]\n      const adaptationFiledControl = (data[start + 3] & 0x30) >> 4\n\n      let offset\n      if (adaptationFiledControl > 1) {\n        offset = start + 5 + data[start + 4]\n        if (offset === start + 188) continue\n      } else {\n        offset = start + 4\n      }\n\n      switch (pid) {\n        case 0: // PAT\n          if (payloadUnitStartIndicator) offset += data[offset] + 1\n          this._pmtId = ((data[offset + 10] & 0x1f) << 8) | data[offset + 11]\n          break\n        case this._pmtId: {\n          if (payloadUnitStartIndicator) offset += data[offset] + 1\n          const tableEnd = offset + 3 + (((data[offset + 1] & 0x0f) << 8) | data[offset + 2]) - 4\n          const programInfoLength = ((data[offset + 10] & 0x0f) << 8) | data[offset + 11]\n          offset += 12 + programInfoLength\n\n          while (offset < tableEnd) {\n            const esPid = ((data[offset + 1] & 0x1f) << 8) | data[offset + 2]\n            switch (data[offset]) {\n              case 0x0f: // AAC ADTS\n                audioTrack.pid = audioPid = esPid\n                break\n              case 0x1b: // AVC\n                if (videoPid !== -1) break\n                videoTrack.codecType = VideoCodecType.AVC\n                videoTrack.pid = videoPid = esPid\n                break\n              case 0x24: // HEVC\n                if (videoPid !== -1) break\n                videoTrack.codecType = VideoCodecType.HEVC\n                videoTrack.pid = videoPid = esPid\n                break\n              default:\n                logger.warn(`Unsupported stream. type: ${data[offset]}, pid: ${esPid}`)\n            }\n\n            offset += (((data[offset + 3] & 0x0f) << 8) | data[offset + 4]) + 5\n          }\n        }\n          break\n        case videoPid:\n          if (payloadUnitStartIndicator && this._videoPesData.length) {\n            this._parseVideoData()\n          }\n          this._videoPesData.push(data.subarray(offset, start + 188))\n          break\n        case audioPid:\n          if (payloadUnitStartIndicator && this._audioPesData.length) {\n            this._parseAudioData()\n          }\n          this._audioPesData.push(data.subarray(offset, start + 188))\n          break\n        case 17:\n        case 0x1fff:\n          break\n        default:\n          logger.warn(`Unknown pid: ${pid}`)\n      }\n    }\n\n    this._parseVideoData()\n    this._parseAudioData()\n\n    audioTrack.formatTimescale = videoTrack.formatTimescale = videoTrack.timescale = metadataTrack.timescale = 90000\n\n    audioTrack.timescale = audioTrack.sampleRate || 0\n\n    return {\n      videoTrack,\n      audioTrack,\n      metadataTrack\n    }\n  }\n\n  /**\n   * @param {number} [startTime=0]\n   * @param {boolean} [discontinuity=false]\n   * @param {boolean} [contiguous=true]\n   */\n  fix (startTime, discontinuity, contiguous) {\n    this._fixer.fix(startTime, discontinuity, contiguous)\n    return {\n      videoTrack: this.videoTrack,\n      audioTrack: this.audioTrack,\n      metadataTrack: this.metadataTrack\n    }\n  }\n\n  /**\n   * @param {Uint8Array} data\n   * @param {boolean} [discontinuity=false]\n   * @param {boolean} [contiguous=true]\n   * @param {number} [startTime=0]\n   */\n  demuxAndFix (data, discontinuity, contiguous, startTime) {\n    this.demux(data, discontinuity, contiguous)\n    return this.fix(startTime, discontinuity, contiguous)\n  }\n\n  /**\n   * @param { Uint8Array } data\n   * @returns {boolean}\n   */\n  static probe (data) {\n    if (!data.length) return false\n    return data[0] === 0x47 && data[188] === 0x47 && data[376] === 0x47\n  }\n\n  _parseVideoData () {\n    if (!this._videoPesData.length) return\n    const pes = TsDemuxer._parsePES(concatUint8Array(...this._videoPesData))\n    if (!pes) {\n      logger.warn('Cannot parse video pes', this._videoPesData)\n      return\n    }\n\n    const units = NALu.parseAnnexB(pes.data)\n    if (units) {\n      this._createVideoSample(units, pes.pts, pes.dts)\n    } else {\n      logger.warn('Cannot parse avc units', pes)\n    }\n\n    this._videoPesData = []\n  }\n\n  _createVideoSample (units, pts, dts) {\n    if (!units.length) return\n    const track = this.videoTrack\n    const isHevc = track.codecType === VideoCodecType.HEVC\n\n    const sample = new VideoSample(pts, dts)\n    units.forEach((unit) => {\n      const type = isHevc ? (unit[0] >>> 1) & 0x3f : unit[0] & 0x1f\n      switch (type) {\n        case 5: // IDR\n        case 16: // HEVC BLA_W_LP\n        case 17: // HEVC BLA_W_RADL\n        case 18: // HEVC BLA_N_LP\n        case 19: // HEVC IDR_W_RADL\n        case 20: // HEVC IDR_N_LP\n        case 21: // HEVC CRA_NUT\n        case 22: // HEVC RSV_IRAP_VCL22\n        case 23: // HEVC RSV_IRAP_VCL23\n          if ((!isHevc && type !== 5) || (isHevc && type === 5)) break\n          sample.setToKeyframe()\n          this._gopId++\n          break\n        case 6: // SEI\n        case 39: // HEVC PREFIX_SEI\n        case 40: // HEVC SUFFIX_SEI\n          if ((!isHevc && type !== 6) || (isHevc && type === 6)) break\n          this.metadataTrack.seiSamples.push(new SeiSample(\n            NALu.parseSEI(NALu.removeEPB(unit), isHevc),\n            pts\n          ))\n          // fix 分割nal之前只要sei信息被当做单独一个sample\n          return\n        case 32: // HEVC VPS\n          if (!isHevc) break\n          if (!track.vps.length) {\n            const hvcC = HEVC.parseVPS(NALu.removeEPB(unit), track.hvcC)\n            track.hvcC = track.hvcC || hvcC\n            track.vps = [unit]\n          }\n          break\n        case 7: // SPS\n        case 33: // HEVC SPS\n          if ((!isHevc && type !== 7) || (isHevc && type === 7)) break\n          if (!track.sps.length) {\n            const data = NALu.removeEPB(unit)\n            const spsInfo = isHevc ? HEVC.parseSPS(data, track.hvcC) : AVC.parseSPS(data)\n            track.sps = [unit]\n            track.hvcC = track.hvcC || spsInfo.hvcC\n            track.codec = spsInfo.codec\n            track.width = spsInfo.width\n            track.height = spsInfo.height\n            track.sarRatio = spsInfo.sarRatio\n            track.fpsNum = spsInfo.fpsNum\n            track.fpsDen = spsInfo.fpsDen\n          }\n          break\n        case 8: // PPS\n        case 34: // HEVC PPS\n          if ((!isHevc && type !== 8) || (isHevc && type === 8)) break\n          if (!track.pps.length) track.pps = [unit]\n          break\n        case 9: // AUD\n        case 35: // HEVC AUD\n          // if ((!isHevc && type !== 9) || (isHevc && type === 9)) break\n          // sample.gopId = this._gopId\n          // if (sample.units.length && !keyFrame) {\n          //   this._pushVideoSample(track, sample)\n          //   sample = this.prevAvcSample = new VideoSample(pts, dts)\n          // }\n          break\n        case 38: // HEVC FD_NUT\n          if (isHevc) {\n            let ffByteFound = false\n            for (let i = 2; i < unit.byteLength; i++) {\n              if (unit[i] === 0xff) {\n                ffByteFound = true\n                break\n              }\n            }\n            if (!ffByteFound) {\n              return\n            }\n          }\n          break\n        default:\n      }\n      sample.units.push(unit)\n    })\n    sample.gopId = this._gopId\n    this._pushVideoSample(track, sample)\n  }\n\n  _pushVideoSample (track, sample) {\n    if (sample.units.length) {\n      if (sample.pts === null || sample.pts === undefined) {\n        logger.warn('Video sample no pts', sample)\n        const lastSample = track.samples[track.samples.length - 1]\n        if (lastSample) {\n          sample.pts = lastSample.pts\n          sample.dts = lastSample.dts\n        } else {\n          logger.warn('Drop video sample', sample)\n        }\n      } else {\n        track.samples.push(sample)\n      }\n    }\n  }\n\n  _parseAudioData () {\n    if (!this._audioPesData.length) return\n    const pes = TsDemuxer._parsePES(concatUint8Array(...this._audioPesData))\n    if (!pes) {\n      logger.warn('Cannot parse audio pes', this._audioPesData)\n      return\n    }\n\n    this._parseAacData(pes)\n\n    this._audioPesData = []\n  }\n\n  _parseAacData (pes) {\n    const track = this.audioTrack\n    let pts = pes.pts\n    if (pts === null || pts === undefined) {\n      logger.warn('AAC pes not pts', track)\n      if (!track.samples.length || !track.sampleRate) {\n        return\n      }\n      pts = track.samples[track.samples.length - 1].pts + AAC.getFrameDuration(track.sampleRate)\n    }\n\n    const ret = AAC.parseADTS(pes.data, pts)\n    if (ret) {\n      track.codec = ret.codec\n      track.channelCount = ret.channelCount\n      track.sampleRate = ret.sampleRate\n      track.objectType = ret.objectType\n      track.sampleRateIndex = ret.samplingFrequencyIndex\n      track.config = ret.config\n      track.samples.push(...ret.frames.map((s) => new AudioSample(s.pts, s.data)))\n\n      if (ret.skip) {\n        logger.warn(`Skip aac adts ${ret.skip} bits`)\n      }\n      if (ret.remaining) {\n        logger.warn(`Remaining aac adts ${ret.remaining} bits`)\n      }\n    } else {\n      logger.warn('Cannot parse aac adts', pes)\n    }\n  }\n\n  static _parsePES (data) {\n    const headerDataLen = data[8]\n    if (headerDataLen === null || headerDataLen === undefined || data.length < (headerDataLen + 9)) return\n    const startPrefix = data[0] << 16 | data[1] << 8 | data[2]\n    if (startPrefix !== 1) return\n    const pesLen = (data[4] << 8) + data[5]\n    if (pesLen && pesLen > data.length - 6) return\n\n    let pts\n    let dts\n    const ptsDtsFlags = data[7]\n    if (ptsDtsFlags & 0xc0) {\n      pts = (data[9] & 0x0e) * 536870912 +\n        (data[10] & 0xff) * 4194304 +\n        (data[11] & 0xfe) * 16384 +\n        (data[12] & 0xff) * 128 +\n        (data[13] & 0xfe) / 2\n\n      if (ptsDtsFlags & 0x40) {\n        dts = (data[14] & 0x0e) * 536870912 +\n          (data[15] & 0xff) * 4194304 +\n          (data[16] & 0xfe) * 16384 +\n          (data[17] & 0xff) * 128 +\n          (data[18] & 0xfe) / 2\n        if (pts - dts > 60 * 90000) pts = dts\n      } else {\n        dts = pts\n      }\n    }\n\n    return { data: data.subarray(9 + headerDataLen), pts, dts }\n  }\n}\n","import { AudioCodecType, VideoCodecType } from '../model'\nimport { getAvcCodec, readBig16, readBig24, readBig32, readBig64 } from '../utils'\nimport { AAC } from '../codec'\nexport class MP4Parser {\n  static findBox (data, names, start = 0) {\n    const ret = []\n    if (!data) return ret\n\n    let size = 0\n    let type = ''\n    let headerSize = 0\n    while (data.length > 7) {\n      size = readBig32(data)\n      type = String.fromCharCode.apply(null, data.subarray(4, 8))\n      headerSize = 8\n      if (size === 1) {\n        size = readBig64(data, 8)\n        headerSize += 8\n      } else if (!size) {\n        size = data.length\n      }\n      if (!names[0] || type === names[0]) {\n        const subData = data.subarray(0, size)\n        if (names.length < 2) {\n          ret.push({\n            start,\n            size,\n            headerSize,\n            type,\n            data: subData\n          })\n        } else {\n          return MP4Parser.findBox(subData.subarray(headerSize), names.slice(1), start + headerSize)\n        }\n      }\n\n      start += size\n      data = data.subarray(size)\n    }\n\n    return ret\n  }\n\n  static tfhd (box) {\n    return parseBox(box, true, (ret, data) => {\n      ret.trackId = readBig32(data)\n      let start = 4\n      const baseDataOffsetPresent = (ret.flags & 0xff) & 0x01\n      const sampleDescriptionIndexPresent = (ret.flags & 0xff) & 0x02\n      const defaultSampleDurationPresent = (ret.flags & 0xff) & 0x08\n      const defaultSampleSizePresent = (ret.flags & 0xff) & 0x10\n      const defaultSampleFlagsPresent = (ret.flags & 0xff) & 0x20\n\n      if (baseDataOffsetPresent) {\n        start += 4 // truncate top 4 bytes\n        ret.baseDataOffset = readBig32(data, start)\n        start += 4\n      }\n      if (sampleDescriptionIndexPresent) {\n        ret.sampleDescriptionIndex = readBig32(data, start)\n        start += 4\n      }\n      if (defaultSampleDurationPresent) {\n        ret.defaultSampleDuration = readBig32(data, start)\n        start += 4\n      }\n      if (defaultSampleSizePresent) {\n        ret.defaultSampleSize = readBig32(data, start)\n        start += 4\n      }\n      if (defaultSampleFlagsPresent) {\n        ret.defaultSampleFlags = readBig32(data, start)\n      }\n    })\n  }\n\n  static sidx (box) {\n    return parseBox(box, true, (ret, data) => {\n      let start = 0\n      ret.reference_ID = readBig32(data, start)// stream.readUint32();\n      start += 4\n      ret.timescale = readBig32(data, start)\n      start += 4\n      if (ret.version === 0) {\n        ret.earliest_presentation_time = readBig32(data, start)\n        start += 4\n        ret.first_offset = readBig32(data, start)\n        start += 4\n      } else {\n        ret.earliest_presentation_time = readBig64(data, start)\n        start += 8\n        ret.first_offset = readBig64(data, start)\n        start += 8\n      }\n      start += 2\n      ret.references = []\n      const count = readBig16(data, start)\n      start += 2\n      for (let i = 0; i < count; i++) {\n        const ref = {}\n        ret.references.push(ref)\n        let tmp32 = readBig32(data, start)\n        start += 4\n        ref.reference_type = (tmp32 >> 31) & 0x1\n        ref.referenced_size = tmp32 & 0x7FFFFFFF\n        ref.subsegment_duration = readBig32(data, start)\n        start += 4\n        tmp32 = readBig32(data, start)\n        start += 4\n        ref.starts_with_SAP = (tmp32 >> 31) & 0x1\n        ref.SAP_type = (tmp32 >> 28) & 0x7\n        ref.SAP_delta_time = tmp32 & 0xFFFFFFF\n      }\n    })\n  }\n\n  static moov (box) {\n    return parseBox(box, false, (ret, data, start) => {\n      ret.mvhd = MP4Parser.mvhd(MP4Parser.findBox(data, ['mvhd'], start)[0])\n      ret.trak = MP4Parser.findBox(data, ['trak'], start).map(trak => MP4Parser.trak(trak))\n      ret.pssh = MP4Parser.pssh(MP4Parser.findBox(data, ['pssh'], start)[0])\n    })\n  }\n\n  static mvhd (box) {\n    return parseBox(box, true, (ret, data) => {\n      let start = 0\n      if (ret.version === 1) {\n        ret.timescale = readBig32(data, 16)\n        ret.duration = readBig64(data, 20)\n        start += 28\n      } else {\n        ret.timescale = readBig32(data, 8)\n        ret.duration = readBig32(data, 12)\n        start += 16\n      }\n      ret.nextTrackId = readBig32(data, start + 76)\n    })\n  }\n\n  static trak (box) {\n    return parseBox(box, false, (ret, data, start) => {\n      ret.tkhd = MP4Parser.tkhd(MP4Parser.findBox(data, ['tkhd'], start)[0])\n      ret.mdia = MP4Parser.mdia(MP4Parser.findBox(data, ['mdia'], start)[0])\n    })\n  }\n\n  static tkhd (box) {\n    return parseBox(box, true, (ret, data) => {\n      let start = 0\n      if (ret.version === 1) {\n        ret.trackId = readBig32(data, 16)\n        ret.duration = readBig64(data, 24)\n        start += 32\n      } else {\n        ret.trackId = readBig32(data, 8)\n        ret.duration = readBig32(data, 16)\n        start += 20\n      }\n      ret.width = readBig32(data, start + 52)\n      ret.height = readBig32(data, start + 56)\n    })\n  }\n\n  static mdia (box) {\n    return parseBox(box, false, (ret, data, start) => {\n      ret.mdhd = MP4Parser.mdhd(MP4Parser.findBox(data, ['mdhd'], start)[0])\n      ret.hdlr = MP4Parser.hdlr(MP4Parser.findBox(data, ['hdlr'], start)[0])\n      ret.minf = MP4Parser.minf(MP4Parser.findBox(data, ['minf'], start)[0])\n    })\n  }\n\n  static mdhd (box) {\n    return parseBox(box, true, (ret, data) => {\n      let start = 0\n      if (ret.version === 1) {\n        ret.timescale = readBig32(data, 16)\n        ret.duration = readBig64(data, 20)\n        start += 28\n      } else {\n        ret.timescale = readBig32(data, 8)\n        ret.duration = readBig32(data, 12)\n        start += 16\n      }\n      const lang = readBig16(data, start)\n      ret.language = String.fromCharCode(((lang >> 10) & 0x1F) + 0x60, ((lang >> 5) & 0x1F) + 0x60, (lang & 0x1F) + 0x60)\n    })\n  }\n\n  static hdlr (box) {\n    return parseBox(box, true, (ret, data) => {\n      if (ret.version === 0) {\n        ret.handlerType = String.fromCharCode.apply(null, data.subarray(4, 8))\n      }\n    })\n  }\n\n  static minf (box) {\n    return parseBox(box, false, (ret, data, start) => {\n      ret.vmhd = MP4Parser.vmhd(MP4Parser.findBox(data, ['vmhd'], start)[0])\n      ret.smhd = MP4Parser.smhd(MP4Parser.findBox(data, ['smhd'], start)[0])\n      ret.stbl = MP4Parser.stbl(MP4Parser.findBox(data, ['stbl'], start)[0])\n    })\n  }\n\n  static vmhd (box) {\n    return parseBox(box, true, (ret, data) => {\n      ret.graphicsmode = readBig16(data)\n      ret.opcolor = [readBig16(data, 2), readBig16(data, 4), readBig16(data, 6)]\n    })\n  }\n\n  static smhd (box) {\n    return parseBox(box, true, (ret, data) => {\n      ret.balance = readBig16(data)\n    })\n  }\n\n  static stbl (box) {\n    return parseBox(box, false, (ret, data, start) => {\n      ret.stsd = MP4Parser.stsd(MP4Parser.findBox(data, ['stsd'], start)[0])\n      ret.stts = MP4Parser.stts(MP4Parser.findBox(data, ['stts'], start)[0])\n      ret.ctts = MP4Parser.ctts(MP4Parser.findBox(data, ['ctts'], start)[0])\n      ret.stsc = MP4Parser.stsc(MP4Parser.findBox(data, ['stsc'], start)[0])\n      ret.stsz = MP4Parser.stsz(MP4Parser.findBox(data, ['stsz'], start)[0])\n      ret.stco = MP4Parser.stco(MP4Parser.findBox(data, ['stco'], start)[0])\n      if (!ret.stco) {\n        ret.co64 = MP4Parser.co64(MP4Parser.findBox(data, ['co64'], start)[0])\n        ret.stco = ret.co64\n      }\n      const default_IV_size = ret.stsd.entries[0]?.sinf?.schi?.tenc.default_IV_size\n      ret.stss = MP4Parser.stss(MP4Parser.findBox(data, ['stss'], start)[0])\n      ret.senc = MP4Parser.senc(MP4Parser.findBox(data, ['senc'], start)[0], default_IV_size)\n    })\n  }\n\n  static senc (box, iv = 8) {\n    return parseBox(box, true, (ret, data) => {\n      let start = 0\n      const sampleCount = readBig32(data, start)\n      start += 4\n      ret.samples = []\n      for (let i = 0; i < sampleCount; i++) {\n        const sample = {}\n        sample.InitializationVector = []\n        for (let j = 0; j < iv; j++){\n          sample.InitializationVector[j] = data[start + j]\n        }\n        start += iv\n        if (ret.flags & 0x2) {\n          sample.subsamples = []\n          const subsampleCount = readBig16(data, start)\n          start += 2\n          for (let j = 0; j < subsampleCount; j++) {\n            const subsample = {}\n            subsample.BytesOfClearData = readBig16(data, start)\n            start += 2\n            subsample.BytesOfProtectedData = readBig32(data, start)\n            start += 4\n            sample.subsamples.push(subsample)\n          }\n        }\n        ret.samples.push(sample)\n      }\n    })\n  }\n\n  static pssh (box) {\n    return parseBox(box, true, (ret, data) => {\n      const keyIds = []\n      const systemId = []\n      let start = 0\n      for (let i = 0; i < 16; i++) {\n        systemId.push(toHex(data[start + i]))\n      }\n      start += 16\n      if (ret.version > 0) {\n        const numKeyIds = readBig32(data, start)\n        start += 4\n        for (let i = 0; i < ('' + numKeyIds).length; i++) {\n          for (let j = 0; j < 16; j++) {\n            const keyId = data[start]\n            start += 1\n            keyIds.push(toHex(keyId))\n          }\n        }\n      }\n      const dataSize = readBig32(data, start)\n      ret.data_size = dataSize\n      start += 4\n      ret.kid = keyIds\n      ret.system_id = systemId\n      ret.buffer = data\n    })\n  }\n\n  static stsd (box) {\n    return parseBox(box, true, (ret, data, start) => {\n      ret.entryCount = readBig32(data)\n      ret.entries = MP4Parser.findBox(data.subarray(4), [], start + 4).map(b => {\n        switch (b.type) {\n          case 'avc1':\n          case 'avc2':\n          case 'avc3':\n          case 'avc4':\n            return MP4Parser.avc1(b)\n          case 'hvc1':\n          case 'hev1':\n            return MP4Parser.hvc1(b)\n          case 'mp4a':\n            return MP4Parser.mp4a(b)\n          case 'alaw':\n          case 'ulaw':\n            return MP4Parser.alaw(b)\n          case 'enca':\n            // sinf->schi->tenc\n            return parseBox(b, false, (ret, data, start) => {\n              ret.channelCount = readBig16(data, 16)\n              ret.samplesize = readBig16(data, 18)\n              ret.sampleRate = (readBig32(data, 24) / (1 << 16))\n              data = data.subarray(28)\n              ret.sinf = MP4Parser.sinf(MP4Parser.findBox(data, ['sinf'], start)[0])\n              ret.esds = MP4Parser.esds(MP4Parser.findBox(data, ['esds'], start)[0])\n            })\n          case 'encv':\n            // sinf->schi->tenc\n            return parseBox(b, false, (ret, data, start) => {\n              ret.width = readBig16(data, 24)\n              ret.height = readBig16(data, 26)\n              ret.horizresolution = readBig32(data, 28)\n              ret.vertresolution = readBig32(data, 32)\n              data = data.subarray(78)\n              ret.sinf = MP4Parser.sinf(MP4Parser.findBox(data, ['sinf'], start)[0])\n              ret.avcC = MP4Parser.avcC(MP4Parser.findBox(data, ['avcC'], start)[0])\n              ret.hvcC = MP4Parser.hvcC(MP4Parser.findBox(data, ['hvcC'], start)[0])\n              ret.pasp = MP4Parser.pasp(MP4Parser.findBox(data, ['pasp'], start)[0])\n            })\n          default:\n        }\n      }).filter(Boolean)\n    })\n  }\n\n  static tenc (box) {\n    return parseBox(box, false, (ret, data) => {\n      let start = 6\n      ret.default_IsEncrypted = data[start]\n      start += 1\n      ret.default_IV_size = data[start]\n      start += 1\n      ret.default_KID = []\n      for (let i = 0; i < 16; i++) {\n        ret.default_KID.push(toHex(data[start]))\n        start += 1\n      }\n    })\n  }\n\n  static schi (box) {\n    return parseBox(box, false, (ret, data, start) => {\n      ret.tenc = MP4Parser.tenc(MP4Parser.findBox(data, ['tenc'], start)[0])\n    })\n  }\n\n  static sinf (box) {\n    return parseBox(box, false, (ret, data, start) => {\n      ret.schi = MP4Parser.schi(MP4Parser.findBox(data, ['schi'], start)[0])\n      ret.frma = MP4Parser.frma(MP4Parser.findBox(data, ['frma'], start)[0])\n    })\n  }\n\n  static frma (box) {\n    return parseBox(box, false, (ret, data) => {\n      ret.data_format = ''\n      for (let i = 0; i < 4; i++) {\n        ret.data_format += String.fromCharCode(data[i])\n      }\n    })\n  }\n\n  static avc1 (box) {\n    return parseBox(box, false, (ret, data, start) => {\n      const bodyStart = parseVisualSampleEntry(ret, data)\n      const bodyData = data.subarray(bodyStart)\n      start += bodyStart\n      ret.avcC = MP4Parser.avcC(MP4Parser.findBox(bodyData, ['avcC'], start)[0])\n      ret.pasp = MP4Parser.pasp(MP4Parser.findBox(bodyData, ['pasp'], start)[0])\n    })\n  }\n\n  static avcC (box) {\n    return parseBox(box, false, (ret, data) => {\n      ret.data = box.data;\n      ret.configurationVersion = data[0]\n      ret.AVCProfileIndication = data[1]\n      ret.profileCompatibility = data[2]\n      ret.AVCLevelIndication = data[3]\n      ret.codec = getAvcCodec([data[1], data[2], data[3]])\n      ret.lengthSizeMinusOne = data[4] & 0x3\n      ret.spsLength = data[5] & 0x1F\n      ret.sps = []\n      let start = 6\n      for (let i = 0; i < ret.spsLength; i++) {\n        const size = readBig16(data, start)\n        start += 2\n        ret.sps.push(data.subarray(start, start + size))\n        // ret.spsInfo = SpsParser.parseSPS(ret.sps[i])\n        // ret.pixelRatio = ret.spsInfo.par_ratio\n        start += size\n      }\n      ret.ppsLength = data[start]\n      start += 1\n      ret.pps = []\n      for (let i = 0; i < ret.ppsLength; i++) {\n        const size = readBig16(data, start)\n        start += 2\n        ret.pps.push(data.subarray(start, start += size))\n        start += size\n      }\n    })\n  }\n\n  static hvc1 (box) {\n    return parseBox(box, false, (ret, data, start) => {\n      const bodyStart = parseVisualSampleEntry(ret, data)\n      const bodyData = data.subarray(bodyStart)\n      start += bodyStart\n      ret.hvcC = MP4Parser.hvcC(MP4Parser.findBox(bodyData, ['hvcC'], start)[0])\n      ret.pasp = MP4Parser.pasp(MP4Parser.findBox(bodyData, ['pasp'], start)[0])\n    })\n  }\n\n  static hvcC (box) {\n    return parseBox(box, false, (ret, data) => {\n      ret.data = box.data\n      ret.codec = 'hev1.1.6.L93.B0'\n      ret.configurationVersion = data[0]\n      const tmp = data[1]\n      ret.generalProfileSpace = tmp >> 6\n      ret.generalTierFlag = (tmp & 0x20) >> 5\n      ret.generalProfileIdc = tmp & 0x1F\n      ret.generalProfileCompatibility = readBig32(data, 2)\n      ret.generalConstraintIndicatorFlags = data.subarray(6, 12)\n      ret.generalLevelIdc = data[12]\n      ret.avgFrameRate = readBig16(data, 19)\n      ret.numOfArrays = data[22]\n      ret.vps = []\n      ret.sps = []\n      ret.pps = []\n      let start = 23\n      let type = 0\n      let numNalus = 0\n      let size = 0\n      for (let i = 0; i < ret.numOfArrays; i++) {\n        type = data[start] & 0x3F\n        numNalus = readBig16(data, start + 1)\n        start += 3\n        const nalus = []\n        for (let j = 0; j < numNalus; j++) {\n          size = readBig16(data, start)\n          start += 2\n          nalus.push(data.subarray(start, start + size))\n          start += size\n        }\n\n        if (type === 32) {\n          ret.vps.push(...nalus)\n        } else if (type === 33) {\n          ret.sps.push(...nalus)\n        } else if (type === 34) {\n          ret.pps.push(...nalus)\n        }\n      }\n    })\n  }\n\n  static pasp (box) {\n    return parseBox(box, false, (ret, data) => {\n      ret.hSpacing = readBig32(data)\n      ret.vSpacing = readBig32(data, 4)\n    })\n  }\n\n  static mp4a (box) {\n    return parseBox(box, false, (ret, data, start) => {\n      const bodyStart = parseAudioSampleEntry(ret, data)\n      ret.esds = MP4Parser.esds(MP4Parser.findBox(data.subarray(bodyStart), ['esds'], start + bodyStart)[0])\n    })\n  }\n\n  static esds (box) {\n    return parseBox(box, true, (ret, data) => {\n      ret.codec = 'mp4a.'\n      let start = 0\n      let byteRead = 0\n      let size = 0\n      let tag = 0\n      while (data.length) {\n        start = 0\n        tag = data[start]\n        byteRead = data[start + 1]\n        start += 2\n        while (byteRead & 0x80) {\n          size = (byteRead & 0x7F) << 7\n          byteRead = data[start]\n          start += 1\n        }\n        size += byteRead & 0x7F\n        if (tag === 3) {\n          data = data.subarray(start + 3)\n        } else if (tag === 4) {\n          ret.codec += (data[start].toString(16) + '.').padStart(3, '0')\n          data = data.subarray(start + 13)\n        } else if (tag === 5) {\n          const config = ret.config = data.subarray(start, start + size)\n          let objectType = (config[0] & 0xF8) >> 3\n          if (objectType === 31 && config.length >= 2) {\n            objectType = 32 + ((config[0] & 0x7) << 3) + ((config[1] & 0xE0) >> 5)\n          }\n          ret.objectType = objectType\n          ret.codec += objectType.toString(16)\n          if (ret.codec[ret.codec.length - 1] === '.') {\n            ret.codec = ret.codec.substring(0, ret.codec.length - 1)\n          }\n          return\n        } else {\n          if (ret.codec[ret.codec.length - 1] === '.') {\n            ret.codec = ret.codec.substring(0, ret.codec.length - 1)\n          }\n          return\n        }\n      }\n    })\n  }\n\n  static alaw (box) {\n    return parseBox(box, false, (ret, data) => {\n      parseAudioSampleEntry(ret, data)\n    })\n  }\n\n  static stts (box) {\n    return parseBox(box, true, (ret, data) => {\n      const entryCount = readBig32(data)\n      const entries = []\n      let start = 4\n      for (let i = 0; i < entryCount; i++) {\n        entries.push({\n          count: readBig32(data, start),\n          delta: readBig32(data, start + 4)\n        })\n        start += 8\n      }\n      ret.entryCount = entryCount\n      ret.entries = entries\n    })\n  }\n\n  static ctts (box) {\n    return parseBox(box, true, (ret, data) => {\n      const entryCount = readBig32(data)\n      const entries = []\n      let start = 4\n      if (ret.version === 1) {\n        for (let i = 0; i < entryCount; i++) {\n          entries.push({\n            count: readBig32(data, start),\n            offset: readBig32(data, start + 4)\n          })\n          start += 8\n        }\n      } else {\n        for (let i = 0; i < entryCount; i++) {\n          entries.push({\n            count: readBig32(data, start),\n            offset: -(~readBig32(data, start + 4) + 1)\n          })\n          start += 8\n        }\n      }\n      ret.entryCount = entryCount\n      ret.entries = entries\n    })\n  }\n\n  static stsc (box) {\n    return parseBox(box, true, (ret, data) => {\n      const entryCount = readBig32(data)\n      const entries = []\n      let start = 4\n      for (let i = 0; i < entryCount; i++) {\n        entries.push({\n          firstChunk: readBig32(data, start),\n          samplesPerChunk: readBig32(data, start + 4),\n          sampleDescriptionIndex: readBig32(data, start + 8)\n        })\n        start += 12\n      }\n      ret.entryCount = entryCount\n      ret.entries = entries\n    })\n  }\n\n  static stsz (box) {\n    return parseBox(box, true, (ret, data) => {\n      const sampleSize = readBig32(data)\n      const sampleCount = readBig32(data, 4)\n      const entrySizes = []\n      if (!sampleSize) {\n        let start = 8\n        for (let i = 0; i < sampleCount; i++) {\n          entrySizes.push(readBig32(data, start))\n          start += 4\n        }\n      }\n      ret.sampleSize = sampleSize\n      ret.sampleCount = sampleCount\n      ret.entrySizes = entrySizes\n    })\n  }\n\n  static stco (box) {\n    return parseBox(box, true, (ret, data) => {\n      const entryCount = readBig32(data)\n      const entries = []\n      let start = 4\n      for (let i = 0; i < entryCount; i++) {\n        entries.push(readBig32(data, start))\n        start += 4\n      }\n      ret.entryCount = entryCount\n      ret.entries = entries\n    })\n  }\n\n  static co64 (box) {\n    return parseBox(box, true, (ret, data) => {\n      const entryCount = readBig32(data)\n      const entries = []\n      let start = 4\n      for (let i = 0; i < entryCount; i++) {\n        entries.push(readBig64(data, start))\n        start += 8\n      }\n      ret.entryCount = entryCount\n      ret.entries = entries\n    })\n  }\n\n  static stss (box) {\n    return parseBox(box, true, (ret, data) => {\n      const entryCount = readBig32(data)\n      const entries = []\n      let start = 4\n      for (let i = 0; i < entryCount; i++) {\n        entries.push(readBig32(data, start))\n        start += 4\n      }\n      ret.entryCount = entryCount\n      ret.entries = entries\n    })\n  }\n\n  static moof (box) {\n    return parseBox(box, false, (ret, data, start) => {\n      ret.mfhd = MP4Parser.mfhd(MP4Parser.findBox(data, ['mfhd'], start)[0])\n      ret.traf = MP4Parser.findBox(data, ['traf'], start).map(t => MP4Parser.traf(t))\n    })\n  }\n\n  static mfhd (box) {\n    return parseBox(box, true, (ret, data) => {\n      ret.sequenceNumber = readBig32(data)\n    })\n  }\n\n  static traf (box) {\n    return parseBox(box, false, (ret, data, start) => {\n      ret.tfhd = MP4Parser.tfhd(MP4Parser.findBox(data, ['tfhd'], start)[0])\n      ret.tfdt = MP4Parser.tfdt(MP4Parser.findBox(data, ['tfdt'], start)[0])\n      ret.trun = MP4Parser.trun(MP4Parser.findBox(data, ['trun'], start)[0])\n    })\n  }\n\n  static trun (box) {\n    return parseBox(box, true, (ret, data) => {\n      const { version, flags } = ret\n      const dataLen = data.length\n      const sampleCount = ret.sampleCount = readBig32(data)\n      let offset = 4\n      if (dataLen > offset && flags & 1) {\n        ret.dataOffset = -(~readBig32(data, offset) + 1)\n        offset += 4\n      }\n      if (dataLen > offset && flags & 4) {\n        ret.firstSampleFlags = readBig32(data, offset)\n        offset += 4\n      }\n      ret.samples = []\n      if (dataLen > offset) {\n        let sample\n        for (let i = 0; i < sampleCount; i++) {\n          sample = {}\n          if (flags & 0x100) {\n            sample.duration = readBig32(data, offset)\n            offset += 4\n          }\n          if (flags & 0x200) {\n            sample.size = readBig32(data, offset)\n            offset += 4\n          }\n          if (flags & 0x400) {\n            sample.flags = readBig32(data, offset)\n            offset += 4\n          }\n          if (flags & 0x800) {\n            if (version) {\n              sample.cts = -(~readBig32(data, offset + 4) + 1)\n            } else {\n              sample.cts = readBig32(data, offset)\n            }\n            offset += 4\n          }\n          ret.samples.push(sample)\n        }\n      }\n    })\n  }\n\n  static tfdt (box) {\n    return parseBox(box, true, (ret, data) => {\n      if (ret.version === 1) {\n        ret.baseMediaDecodeTime = readBig64(data)\n      } else {\n        ret.baseMediaDecodeTime = readBig32(data)\n      }\n    })\n  }\n\n  static probe (data) {\n    return !!MP4Parser.findBox(data, ['ftyp'])\n  }\n\n  static parseSampleFlags (flags) {\n    return {\n      isLeading: (flags[0] & 0x0c) >>> 2,\n      dependsOn: flags[0] & 0x03,\n      isDependedOn: (flags[1] & 0xc0) >>> 6,\n      hasRedundancy: (flags[1] & 0x30) >>> 4,\n      paddingValue: (flags[1] & 0x0e) >>> 1,\n      isNonSyncSample: flags[1] & 0x01,\n      degradationPriority: (flags[2] << 8) | flags[3]\n    }\n  }\n\n  static moovToTrack (moov, videoTrack, audioTrack) {\n    const tracks = moov.trak\n    if (!tracks || !tracks.length) return\n    const vTrack = tracks.find(t => t.mdia?.hdlr?.handlerType === 'vide')\n    const aTrack = tracks.find(t => t.mdia?.hdlr?.handlerType === 'soun')\n    if (vTrack && videoTrack) {\n      const v = videoTrack\n      const _vTrackId = vTrack.tkhd?.trackId\n      if (_vTrackId !== null && _vTrackId !== undefined) v.id = vTrack.tkhd.trackId\n      v.tkhdDuration = vTrack.tkhd.duration\n      v.mvhdDurtion = moov.mvhd.duration\n      v.mvhdTimecale = moov.mvhd.timescale\n      v.timescale = v.formatTimescale = vTrack.mdia.mdhd.timescale\n      v.duration = vTrack.mdia.mdhd.duration || (v.mvhdDurtion / v.mvhdTimecale * v.timescale)\n      const e1 = vTrack.mdia.minf.stbl.stsd.entries[0]\n      v.width = e1.width\n      v.height = e1.height\n      if (e1.pasp) {\n        v.sarRatio = [e1.pasp.hSpacing, e1.pasp.vSpacing]\n      }\n      if (e1.hvcC) {\n        v.codecType = VideoCodecType.HEVC\n        v.codec = e1.hvcC.codec\n        v.vps = e1.hvcC.vps\n        v.sps = e1.hvcC.sps\n        v.pps = e1.hvcC.pps\n        v.hvcC = e1.hvcC.data\n      } else if (e1.avcC) {\n        v.codec = e1.avcC.codec\n        v.sps = e1.avcC.sps\n        v.pps = e1.avcC.pps\n      } else {\n        throw new Error('unknown video stsd entry')\n      }\n      v.present = true\n      v.ext = {}\n      v.ext.stss = vTrack.mdia?.minf?.stbl?.stss\n      v.ext.ctts = vTrack.mdia?.minf?.stbl?.ctts\n\n      if (e1 && e1.type === 'encv') {\n        v.isVideoEncryption = true\n        e1.default_KID = e1.sinf?.schi?.tenc.default_KID\n        e1.default_IsEncrypted = e1.sinf?.schi?.tenc.default_IsEncrypted\n        e1.default_IV_size = e1.sinf?.schi?.tenc.default_IV_size\n        v.videoSenc = vTrack.mdia.minf.stbl.senc && vTrack.mdia.minf.stbl.senc.samples\n        e1.data_format = e1.sinf?.frma?.data_format\n        v.useEME = moov.useEME\n        v.kidValue = moov.kidValue\n        v.pssh = moov.pssh\n        v.encv = e1\n      }\n    }\n\n    if (aTrack && audioTrack) {\n      const a = audioTrack\n      const _aTrackId = aTrack.tkhd?.trackId\n      if (_aTrackId !== null && _aTrackId !== undefined) a.id = aTrack.tkhd.trackId\n      a.tkhdDuration = aTrack.tkhd.duration\n      a.mvhdDurtion = moov.mvhd.duration\n      a.mvhdTimecale = moov.mvhd.timescale\n      a.timescale = a.formatTimescale = aTrack.mdia.mdhd.timescale\n      a.duration = aTrack.mdia.mdhd.duration || (a.mvhdDurtion / a.mvhdTimecale * a.timescale)\n      const e1 = aTrack.mdia.minf.stbl.stsd.entries[0]\n      a.sampleSize = e1.sampleSize\n      a.sampleRate = e1.sampleRate\n      a.channelCount = e1.channelCount\n      a.present = true\n\n      switch (e1.type) {\n        case 'alaw':\n          a.codecType = a.codec = AudioCodecType.G711PCMA\n          a.sampleRate = 8000\n          break\n        case 'ulaw':\n          a.codecType = a.codec = AudioCodecType.G711PCMU\n          a.sampleRate = 8000\n          break\n        default:\n          a.sampleDuration = AAC.getFrameDuration(a.sampleRate, a.timescale)\n          a.sampleRateIndex = AAC.getRateIndexByRate(a.sampleRate)\n          a.objectType = e1.esds?.objectType || 2\n          if (e1.esds) a.config = Array.from(e1.esds.config)\n          a.codec = e1.esds?.codec || 'mp4a.40.2'\n          break\n      }\n      a.sampleDuration = AAC.getFrameDuration(a.sampleRate, a.timescale)\n      a.objectType = e1.esds?.objectType || 2\n      if (e1.esds) {\n        if (e1.esds.config) {\n          a.config = Array.from(e1.esds.config)\n        } else {\n          console.warn('esds config is null')\n        }\n      }\n      a.codec = e1.esds?.codec || 'mp4a.40.2'\n      a.sampleRateIndex = AAC.getRateIndexByRate(a.sampleRate)\n      a.ext = {}\n      a.ext.stss = aTrack.mdia?.minf?.stbl?.stss\n      a.ext.ctts = aTrack.mdia?.minf?.stbl?.ctts\n      a.present = true\n      if (e1 && e1.type === 'enca') {\n        a.isAudioEncryption = true\n        e1.data_format = e1.sinf?.frma?.data_format\n        e1.default_KID = e1.sinf?.schi?.tenc.default_KID\n        e1.default_IsEncrypted = e1.sinf?.schi?.tenc.default_IsEncrypted\n        e1.default_IV_size = e1.sinf?.schi?.tenc.default_IV_size\n        a.audioSenc = aTrack.mdia.minf.stbl.senc && aTrack.mdia.minf.stbl.senc.samples\n        a.useEME = moov.useEME\n        a.kidValue = moov.kidValue\n        a.enca = e1\n      }\n    }\n\n    audioTrack && (audioTrack.isVideoEncryption = videoTrack ? videoTrack.isVideoEncryption : false)\n    videoTrack && (videoTrack.isAudioEncryption = audioTrack ? audioTrack.isAudioEncryption : false)\n\n    if (videoTrack?.encv || audioTrack?.enca) {\n      const vkid = videoTrack?.encv?.default_KID\n      const akid = audioTrack?.enca?.default_KID\n      const kid = (vkid || akid) ? (vkid || akid).join('') : null\n      videoTrack && (videoTrack.kid = kid)\n      audioTrack && (audioTrack.kid = kid)\n    }\n\n    videoTrack && (videoTrack.flags = 0xf01)\n    audioTrack && (audioTrack.flags = 0x701)\n\n    return {\n      videoTrack,\n      audioTrack\n    }\n  }\n\n  static evaluateDefaultDuration (videoTrack, audioTrack, videoSampleCount) {\n    const audioSampleCount = audioTrack?.samples?.length\n\n    // audio\n    if (!audioSampleCount) return 1024\n\n    const segmentDuration = 1024 * audioSampleCount / audioTrack.timescale\n\n    return segmentDuration * videoTrack.timescale / videoSampleCount\n  }\n\n  static moofToSamples (moof, videoTrack, audioTrack) {\n    const ret = {}\n\n    if (moof.mfhd) {\n      if (videoTrack) videoTrack.sequenceNumber = moof.mfhd.sequenceNumber\n      if (audioTrack) audioTrack.sequenceNumber = moof.mfhd.sequenceNumber\n    }\n\n    moof.traf.forEach(({ tfhd, tfdt, trun }) => {\n      if (!tfhd || !trun) return\n      if (tfdt) {\n        if (videoTrack && videoTrack.id === tfhd.trackId) videoTrack.baseMediaDecodeTime = tfdt.baseMediaDecodeTime\n        if (audioTrack && audioTrack.id === tfhd.trackId) audioTrack.baseMediaDecodeTime = tfdt.baseMediaDecodeTime\n      }\n      const defaultSize = tfhd.defaultSampleSize || 0\n      const defaultDuration = tfhd.defaultSampleDuration || MP4Parser.evaluateDefaultDuration(videoTrack, audioTrack, trun.samples.length || trun.sampleCount)\n      let offset = trun.dataOffset || 0\n      let dts = 0\n      let gopId = -1\n      if (!trun.samples.length && trun.sampleCount) {\n        ret[tfhd.trackId] = []\n        for (let i = 0; i < trun.sampleCount; i++) {\n          ret[tfhd.trackId].push({\n            offset,\n            dts,\n            duration: defaultDuration,\n            size: defaultSize\n          })\n          dts += defaultDuration\n          offset += defaultSize\n        }\n      } else {\n        ret[tfhd.trackId] = trun.samples.map((s, index) => {\n          s = {\n            offset,\n            dts,\n            pts: dts + (s.cts || 0),\n            duration: s.duration || defaultDuration,\n            size: s.size || defaultSize,\n            gopId,\n            keyframe: index === 0 || ((s.flags !== null && s.flags !== undefined) && ((s.flags & 65536) >>> 0) !== 65536)\n          }\n          if (s.keyframe) {\n            gopId++\n            s.gopId = gopId\n          }\n          dts += s.duration\n          offset += s.size\n          return s\n        })\n      }\n    })\n\n    return ret\n  }\n\n  static moovToSamples (moov) {\n    const tracks = moov.trak\n    if (!tracks || !tracks.length) return\n    const vTrack = tracks.find(t => t.mdia?.hdlr?.handlerType === 'vide')\n    const aTrack = tracks.find(t => t.mdia?.hdlr?.handlerType === 'soun')\n    if (!vTrack && !aTrack) return\n    let videoSamples\n    let audioSamples\n    if (vTrack) {\n      const videoStbl = vTrack.mdia?.minf?.stbl\n      if (!videoStbl) return\n      const { stts, stsc, stsz, stco, stss, ctts } = videoStbl\n      if (!stts || !stsc || !stsz || !stco || !stss) return\n      videoSamples = getSamples(stts, stsc, stsz, stco, ctts, stss)\n    }\n    if (aTrack) {\n      const audioStbl = aTrack.mdia?.minf?.stbl\n      if (!audioStbl) return\n      const timescale = aTrack.mdia.mdhd?.timescale\n      const { stts, stsc, stsz, stco } = audioStbl\n      if (!timescale || !stts || !stsc || !stsz || !stco) return\n      audioSamples = getSamples(stts, stsc, stsz, stco)\n    }\n\n    return {\n      videoSamples,\n      audioSamples\n    }\n  }\n}\n\nfunction getSamples (stts, stsc, stsz, stco, ctts, stss) {\n  const samples = []\n  const cttsEntries = ctts?.entries\n  const stscEntries = stsc.entries\n  const stcoEntries = stco.entries\n  const stszEntrySizes = stsz.entrySizes\n  const stssEntries = stss?.entries\n  let keyframeMap\n  if (stssEntries) {\n    keyframeMap = {}\n    stssEntries.forEach(x => { keyframeMap[x - 1] = true })\n  }\n  let cttsArr\n  if (cttsEntries) {\n    cttsArr = []\n    cttsEntries.forEach(({ count, offset }) => {\n      for (let i = 0; i < count; i++) {\n        cttsArr.push(offset)\n      }\n    })\n  }\n\n  let sample\n  let gopId = -1\n  let dts = 0\n  let pos = 0\n  let chunkIndex = 0\n  let chunkRunIndex = 0\n  let offsetInChunk = 0\n  let lastSampleInChunk = stscEntries[0].samplesPerChunk\n  let lastChunkInRun = stscEntries[1] ? stscEntries[1].firstChunk - 1 : Infinity\n  stts.entries.forEach(({ count, delta }) => {\n    for (let i = 0; i < count; i++) {\n      sample = {\n        dts,\n        duration: delta,\n        size: stszEntrySizes[pos] || stsz.sampleSize,\n        offset: stcoEntries[chunkIndex] + offsetInChunk,\n        index: pos\n      }\n      if (stssEntries) {\n        sample.keyframe = keyframeMap[pos]\n        if (sample.keyframe) {\n          gopId++\n        }\n        sample.gopId = gopId\n      }\n      // sample.timeOffset = 0\n      if (cttsArr && pos < cttsArr.length) {\n        sample.pts = sample.dts + cttsArr[pos]\n        // sample.timeOffset = cttsArr[pos]\n        // if (pos === 0) {\n        //   sample.pts = sample.dts\n        //   sample.timeOffset = 0\n        // }\n      }\n      samples.push(sample)\n      dts += delta\n      pos++\n\n      if (pos < lastSampleInChunk) {\n        offsetInChunk += sample.size\n      } else {\n        chunkIndex++\n        offsetInChunk = 0\n        if (chunkIndex >= lastChunkInRun) {\n          chunkRunIndex++\n          lastChunkInRun = stscEntries[chunkRunIndex + 1] ? stscEntries[chunkRunIndex + 1].firstChunk - 1 : Infinity\n        }\n        lastSampleInChunk += stscEntries[chunkRunIndex].samplesPerChunk\n      }\n    }\n  })\n\n  return samples\n}\n\nfunction parseVisualSampleEntry (ret, data) {\n  ret.dataReferenceIndex = readBig16(data, 6)\n  ret.width = readBig16(data, 24)\n  ret.height = readBig16(data, 26)\n  ret.horizresolution = readBig32(data, 28)\n  ret.vertresolution = readBig32(data, 32)\n  ret.frameCount = readBig16(data, 40)\n  ret.depth = readBig16(data, 74)\n  return 78\n}\n\nfunction parseAudioSampleEntry (ret, data) {\n  ret.dataReferenceIndex = readBig16(data, 6)\n  ret.channelCount = readBig16(data, 16)\n  ret.sampleSize = readBig16(data, 18)\n  ret.sampleRate = readBig32(data, 24) / (1 << 16)\n  return 28\n}\n\nfunction parseBox (box, isFullBox, parse) {\n  if (!box) return\n  if (box.size !== box.data.length) throw new Error(`box ${box.type} size !== data.length`)\n  const ret = {\n    start: box.start,\n    size: box.size,\n    headerSize: box.headerSize,\n    type: box.type\n  }\n  if (isFullBox) {\n    ret.version = box.data[box.headerSize]\n    ret.flags = readBig24(box.data, box.headerSize + 1)\n    ret.headerSize += 4\n  }\n  parse(ret, box.data.subarray(ret.headerSize), ret.start + ret.headerSize)\n  return ret\n}\n\nconst padStart = function (str, length, pad) {\n  const charstr = String(pad)\n  const len = length >> 0\n  let maxlen = Math.ceil(len / charstr.length)\n  const chars = []\n  const r = String(str)\n  while (maxlen--) {\n    chars.push(charstr)\n  }\n  return chars.join('').substring(0, len - r.length) + r\n}\n\nconst toHex = function (...value) {\n  const hex = []\n  value.forEach(item => {\n    hex.push(padStart(Number(item).toString(16), 2, 0))\n  })\n  return hex[0]\n}\n","import { VideoTrack, AudioTrack, MetadataTrack, VideoSample, AudioSample } from '../model'\nimport { readBig32 } from '../utils'\nimport { MP4Parser } from './mp4-parser'\n\nexport class FMP4Demuxer {\n  constructor (videoTrack, audioTrack, metadataTrack) {\n    this.videoTrack = videoTrack || new VideoTrack()\n    this.audioTrack = audioTrack || new AudioTrack()\n    this.metadataTrack = metadataTrack || new MetadataTrack()\n  }\n\n  demux (videoData, audioData) {\n    const { videoTrack, audioTrack } = this\n    const videoExist = videoTrack.exist()\n    const audioExist = audioTrack.exist()\n    videoTrack.samples = []\n    audioTrack.samples = []\n\n    if (audioData) {\n      if (!audioExist) {\n        const moovBox = MP4Parser.findBox(audioData, ['moov'])[0]\n        if (!moovBox) throw new Error('cannot found moov box')\n        MP4Parser.moovToTrack(MP4Parser.moov(moovBox), null, audioTrack)\n      }\n      const moofBox = MP4Parser.findBox(audioData, ['moof'])[0]\n      if (moofBox) {\n        const samples = MP4Parser.moofToSamples(MP4Parser.moof(moofBox), null, audioTrack)[audioTrack.id]\n        const baseMediaDecodeTime = audioTrack.baseMediaDecodeTime\n        if (samples) {\n          const baseOffset = moofBox.start\n          samples.map(x => {\n            x.offset += baseOffset\n            const sampleData = audioData.subarray(x.offset, x.offset + x.size)\n            audioTrack.samples.push(new AudioSample(x.dts + baseMediaDecodeTime, sampleData, x.duration))\n          })\n        }\n      }\n    }\n\n    if (videoData) {\n      if (!videoExist && !audioExist) {\n        const moovBox = MP4Parser.findBox(videoData, ['moov'])[0]\n        if (!moovBox) throw new Error('cannot found moov box')\n        MP4Parser.moovToTrack(MP4Parser.moov(moovBox), videoTrack, audioTrack)\n      }\n      const moofBox = MP4Parser.findBox(videoData, ['moof'])[0]\n      if (moofBox) {\n        const tracks = MP4Parser.moofToSamples(MP4Parser.moof(moofBox), videoTrack, audioTrack)\n        const videoBaseMediaDecodeTime = videoTrack.baseMediaDecodeTime\n        const audioBaseMediaDecodeTime = audioTrack.baseMediaDecodeTime\n        const baseOffset = moofBox.start\n        let nalSize\n        Object.keys(tracks).forEach(k => {\n          // eslint-disable-next-line eqeqeq\n          if (videoTrack.id == k) {\n            tracks[k].map(x => {\n              x.offset += baseOffset\n              const sample = new VideoSample((x.pts || x.dts) + videoBaseMediaDecodeTime, x.dts + videoBaseMediaDecodeTime)\n              sample.duration = x.duration\n              sample.gopId = x.gopId\n              if (x.keyframe) sample.setToKeyframe()\n              const sampleData = videoData.subarray(x.offset, x.offset + x.size)\n              sample.data = sampleData\n              let start = 0\n              const len = sampleData.length - 1\n              while (start < len) {\n                nalSize = readBig32(sampleData, start)\n                start += 4\n                sample.units.push(sampleData.subarray(start, start + nalSize))\n                start += nalSize\n              }\n              videoTrack.samples.push(sample)\n            })\n            // eslint-disable-next-line eqeqeq\n          } else if (audioTrack.id == k) {\n            tracks[k].map(x => {\n              x.offset += baseOffset\n              const sampleData = videoData.subarray(x.offset, x.offset + x.size)\n              audioTrack.samples.push(new AudioSample(x.dts + audioBaseMediaDecodeTime, sampleData, x.duration))\n            })\n          }\n        })\n      }\n    }\n\n    return {\n      videoTrack,\n      audioTrack,\n      metadataTrack: this.metadataTrack\n    }\n  }\n\n  reset () {\n    this.videoTrack.reset()\n    this.audioTrack.reset()\n    this.metadataTrack.reset()\n  }\n\n  static probe (data) {\n    return MP4Parser.probe(data)\n  }\n}\n","\n// 改造为兼容IE11\nfunction Concat (ResultConstructor, ...arrays){\n  let totalLength = 0\n  arrays.forEach(function (arr){\n    totalLength += arr.length\n  })\n  const result = new ResultConstructor(totalLength)\n  let offset = 0\n  arrays.forEach(function (arr){\n    result.set(arr, offset)\n    offset += arr.length\n  })\n  return result\n}\n\nclass Buffer {\n  constructor () {\n    this.buffer = new Uint8Array(0)\n  }\n\n  write (...buffer) {\n    const self = this\n    buffer.forEach(item => {\n      if (item) {\n        self.buffer = Concat(Uint8Array, self.buffer, item)\n      } else {\n        window.console.warn(item)\n      }\n    })\n  }\n\n  static writeUint16 (value) {\n    return new Uint8Array([\n      (value >> 8) & 0xff,\n      value & 0xff\n    ])\n  }\n\n  static writeUint32 (value) {\n    return new Uint8Array([\n      value >> 24,\n      (value >> 16) & 0xff,\n      (value >> 8) & 0xff,\n      value & 0xff\n    ])\n  }\n}\n\nexport default Buffer\n","import { TrackType, VideoCodecType } from '../model'\nimport { concatUint8Array, parse /* hashVal */ } from '../utils'\nimport Buffer from './buffer'\n// import Crypto from './crypto/crypto'\nconst UINT32_MAX = 2 ** 32 - 1\n\nexport class MP4 {\n  static types = [\n    'avc1',\n    'avcC',\n    'hvc1',\n    'hvcC',\n    'dinf',\n    'dref',\n    'esds',\n    'ftyp',\n    'hdlr',\n    'mdat',\n    'mdhd',\n    'mdia',\n    'mfhd',\n    'minf',\n    'moof',\n    'moov',\n    'mp4a',\n    'mvex',\n    'mvhd',\n    'pasp',\n    'stbl',\n    'stco',\n    'stsc',\n    'stsd',\n    'stsz',\n    'stts',\n    'tfdt',\n    'tfhd',\n    'traf',\n    'trak',\n    'trex',\n    'tkhd',\n    'vmhd',\n    'smhd',\n    'ctts',\n    'stss',\n    'styp',\n    'pssh',\n    'sidx',\n    'sbgp',\n    'saiz',\n    'saio',\n    'senc',\n    'trun',\n    'encv',\n    'enca',\n    'sinf',\n    'btrt',\n    'frma',\n    'tenc',\n    'schm',\n    'schi',\n    'mehd',\n    'fiel',\n    'sdtp'\n  ].reduce((p, c) => {\n    p[c] = [c.charCodeAt(0), c.charCodeAt(1), c.charCodeAt(2), c.charCodeAt(3)]\n    return p\n  }, Object.create(null));\n\n  static HDLR_TYPES = {\n    video: new Uint8Array([\n      0x00, // version 0\n      0x00, 0x00, 0x00, // flags\n      0x00, 0x00, 0x00, 0x00, // pre_defined\n      0x76, 0x69, 0x64, 0x65, // handler_type: 'vide'\n      0x00, 0x00, 0x00, 0x00,\n      0x00, 0x00, 0x00, 0x00,\n      0x00, 0x00, 0x00, 0x00, // reserved\n      0x56, 0x69, 0x64, 0x65, 0x6f, 0x48, 0x61,\n      0x6e, 0x64, 0x6c, 0x65, 0x72, 0x00 // name: 'VideoHandler'\n    ]),\n    audio: new Uint8Array([\n      0x00, // version 0\n      0x00, 0x00, 0x00, // flags\n      0x00, 0x00, 0x00, 0x00, // pre_defined\n      0x73, 0x6f, 0x75, 0x6e, // handler_type: 'soun'\n      0x00, 0x00, 0x00, 0x00,\n      0x00, 0x00, 0x00, 0x00,\n      0x00, 0x00, 0x00, 0x00, // reserved\n      0x53, 0x6f, 0x75, 0x6e, 0x64, 0x48, 0x61,\n      0x6e, 0x64, 0x6c, 0x65, 0x72, 0x00 // name: 'SoundHandler'\n    ])\n  }\n\n  static FTYPAVC1 = MP4.box(MP4.types.ftyp, new Uint8Array([\n    105, 115, 111, 109, // isom\n    0, 0, 0, 1,\n    105, 115, 111, 109,\n    97, 118, 99, 49 // avc1\n  ]))\n\n  static FTYPHEV1 = MP4.box(MP4.types.ftyp, new Uint8Array([\n    105, 115, 111, 109, // isom\n    0, 0, 0, 1,\n    105, 115, 111, 109,\n    104, 101, 118, 49 // hev1\n  ]))\n\n  static DINF = MP4.box(MP4.types.dinf, MP4.box(MP4.types.dref, new Uint8Array([\n    0x00, // version\n    0x00, 0x00, 0x00, // flags\n    0x00, 0x00, 0x00, 0x01, // entry_count\n    0x00, 0x00, 0x00, 0x0c, // entry_size\n    0x75, 0x72, 0x6c, 0x20, // 'url' type\n    0x00, // version\n    0x00, 0x00, 0x01 // entry_flags\n  ])))\n\n  static VMHD = MP4.box(MP4.types.vmhd, new Uint8Array([\n    0x00, // version\n    0x00, 0x00, 0x01, // flags\n    0x00, 0x00, // graphics mode\n    0x00, 0x00, 0x00, 0x00, 0x00, 0x00 // op color\n  ]))\n\n  static SMHD = MP4.box(MP4.types.smhd, new Uint8Array([\n    0x00, // version\n    0x00, 0x00, 0x00, // flags\n    0x00, 0x00, // balance\n    0x00, 0x00 // reserved\n  ]))\n\n  static StblTable = new Uint8Array([\n    0x00, // version\n    0x00, 0x00, 0x00, // flags\n    0x00, 0x00, 0x00, 0x00 // entry_count\n  ])\n\n  static STTS = MP4.box(MP4.types.stts, MP4.StblTable)\n\n  static STSC = MP4.box(MP4.types.stsc, MP4.StblTable)\n\n  static STSZ = MP4.box(MP4.types.stsz, new Uint8Array([\n    0x00, // version\n    0x00, 0x00, 0x00, // flags\n    0x00, 0x00, 0x00, 0x00, // sample_size\n    0x00, 0x00, 0x00, 0x00 // sample_count\n  ]))\n\n  static STCO = MP4.box(MP4.types.stco, MP4.StblTable)\n\n  static box (type, ...payload) {\n    payload = payload.filter(Boolean)\n    const size = 8 + payload.reduce((p, c) => (p + c.byteLength), 0)\n    const ret = new Uint8Array(size)\n    ret[0] = (size >> 24) & 0xff\n    ret[1] = (size >> 16) & 0xff\n    ret[2] = (size >> 8) & 0xff\n    ret[3] = size & 0xff\n    ret.set(type, 4)\n    let offset = 8\n    payload.forEach((data) => {\n      ret.set(data, offset)\n      offset += data.byteLength\n    })\n    return ret\n  }\n\n  static ftyp (tracks) {\n    const isHevc = tracks.find(t => t.type === TrackType.VIDEO && t.codecType === VideoCodecType.HEVC)\n    return isHevc ? MP4.FTYPHEV1 : MP4.FTYPAVC1\n  }\n\n  static initSegment (tracks) {\n    const ftyp = MP4.ftyp(tracks)\n    // console.log('[remux],ftyp ,len ', ftyp.byteLength, hashVal(ftyp.toString()))\n    const init = concatUint8Array(ftyp, MP4.moov(tracks))\n    // console.log('[remux],init ,len ', init.byteLength, hashVal(init.toString()))\n    return init\n  }\n\n  static pssh (data) {\n    // const buffer = new Buffer()\n    const content = new Uint8Array(\n      [\n        0x01, 0x00, 0x00, 0x00 // version\n      ].concat(\n        [\n          0x10, 0x77, 0xef, 0xec,\n          0xc0, 0xb2, 0x4d, 0x02,\n          0xac, 0xe3, 0x3c, 0x1e,\n          0x52, 0xe2, 0xfb, 0x4b\n        ],\n        [0x00, 0x00, 0x00, 0x01],\n        parse(data.kid),\n        [0x00, 0x00, 0x00, 0x00]\n      )\n    )\n    return MP4.box(MP4.types.pssh, content)\n  }\n\n  static moov (tracks) {\n    if (tracks[0].useEME && (tracks[0].encv || tracks[0].enca)) {\n      if (!tracks[0].pssh) {\n        tracks[0].pssh = {\n          kid: tracks[0].kid\n        }\n      }\n      const pssh = this.pssh(tracks[0].pssh)\n      // console.log('[remux],pssh,', hashVal(pssh.toString()))\n      return MP4.box(MP4.types.moov,\n        MP4.mvhd(tracks[0].mvhdDurtion || tracks[0].duration, tracks[0].mvhdTimecale || tracks[0].timescale),\n        MP4.mvex(tracks),\n        ...tracks.map((t) => MP4.trak(t)),\n        pssh)\n    } else {\n      return MP4.box(MP4.types.moov,\n        MP4.mvhd(tracks[0].mvhdDurtion || tracks[0].duration, tracks[0].mvhdTimecale || tracks[0].timescale),\n        ...tracks.map((t) => MP4.trak(t)),\n        MP4.mvex(tracks)\n      )\n    }\n  }\n\n  static mvhd (duration, timescale = 90000) {\n    const mvhd = MP4.box(MP4.types.mvhd, new Uint8Array([\n      0x00, // version\n      0x00, 0x00, 0x00, // flags\n      0x00, 0x00, 0x00, 0x00, // creation_time\n      0x00, 0x00, 0x00, 0x00, // modification_time\n      (timescale >> 24) & 0xff, (timescale >> 16) & 0xff, (timescale >> 8) & 0xff, timescale & 0xff,\n      (duration >> 24) & 0xff, (duration >> 16) & 0xff, (duration >> 8) & 0xff, duration & 0xff,\n      0x00, 0x01, 0x00, 0x00, // rate\n      0x01, 0x00, // volume\n      0x00, 0x00,\n      0x00, 0x00, 0x00, 0x00,\n      0x00, 0x00, 0x00, 0x00, // reserved\n      0x00, 0x01, 0x00, 0x00,\n      0x00, 0x00, 0x00, 0x00,\n      0x00, 0x00, 0x00, 0x00,\n      0x00, 0x00, 0x00, 0x00,\n      0x00, 0x01, 0x00, 0x00,\n      0x00, 0x00, 0x00, 0x00,\n      0x00, 0x00, 0x00, 0x00,\n      0x00, 0x00, 0x00, 0x00,\n      0x40, 0x00, 0x00, 0x00, // matrix\n      0x00, 0x00, 0x00, 0x00,\n      0x00, 0x00, 0x00, 0x00,\n      0x00, 0x00, 0x00, 0x00,\n      0x00, 0x00, 0x00, 0x00,\n      0x00, 0x00, 0x00, 0x00,\n      0x00, 0x00, 0x00, 0x00, // pre_defined\n      0xff, 0xff, 0xff, 0xff // todo 0xff, 0xff, 0xff, 0xff // next_track_ID\n    ]))\n    // console.log('[remux],mvhd, len,', mvhd.byteLength, hashVal(mvhd.toString()))\n    return mvhd\n  }\n\n  static trak (track) {\n    const trak = MP4.box(\n      MP4.types.trak,\n      MP4.tkhd(track.id, track.tkhdDuration || 0, track.width, track.height),\n      MP4.mdia(track)\n    )\n    // console.log('[remux],trak, len,', trak.byteLength, track.id, hashVal(trak.toString()))\n    return trak\n  }\n\n  static tkhd (id, duration, width = 0, height = 0) {\n    const tkhd = MP4.box(MP4.types.tkhd, new Uint8Array([\n      0x00, // version\n      0x00, 0x00, 0x07, // flags、todo 0x07\n      0x00, 0x00, 0x00, 0x00, // creation_time\n      0x00, 0x00, 0x00, 0x00, // modification_time todo\n      (id >> 24) & 0xff, (id >> 16) & 0xff, (id >> 8) & 0xff, id & 0xff,\n      0x00, 0x00, 0x00, 0x00,\n      (duration >> 24) & 0xff, (duration >> 16) & 0xff, (duration >> 8) & 0xff, duration & 0xff, // todo (duration >> 24) & 0xff, (duration >> 16) & 0xff, (duration >> 8) & 0xff, duration & 0xff,\n      0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // reserved\n      0x00, 0x00, // layer\n      0x00, 0x00, // /*0x00*/ alternate_group  //todo type === 'video' ? 0x01 : 0x00（第二个位置）\n      0x01, 0x00, // /* 0x01 */, 0x00, // non-audio track volume  //todo type === 'audio' ? 0x01 : 0x00（第一个位置）\n      0x00, 0x00, // reserved\n      0x00, 0x01, 0x00, 0x00,\n      0x00, 0x00, 0x00, 0x00,\n      0x00, 0x00, 0x00, 0x00,\n      0x00, 0x00, 0x00, 0x00,\n      0x00, 0x01, 0x00, 0x00,\n      0x00, 0x00, 0x00, 0x00,\n      0x00, 0x00, 0x00, 0x00,\n      0x00, 0x00, 0x00, 0x00,\n      0x40, 0x00, 0x00, 0x00, // matrix\n      (width >> 8) & 0xff, width & 0xff, 0x00, 0x00,\n      (height >> 8) & 0xff, height & 0xff, 0x00, 0x00\n    ]))\n    // console.log('[remux],tkhd, len,', tkhd.byteLength, hashVal(tkhd.toString()))\n    return tkhd\n  }\n\n  static mdia (track) {\n    const mdia = MP4.box(MP4.types.mdia, MP4.mdhd(track.duration, track.timescale), MP4.hdlr(track.type), MP4.minf(track))\n    // console.log('[remux],mdia, len,', mdia.byteLength, hashVal(mdia.toString()))\n    return mdia\n  }\n\n  static mdhd (duration, timescale = 90000) {\n    const mdhd = MP4.box(MP4.types.mdhd, new Uint8Array([\n      0x00, // version\n      0x00, 0x00, 0x00, // flags\n      0x00, 0x00, 0x00, 0x00, // creation_time\n      0x00, 0x00, 0x00, 0x00, // todo 0x00, 0x00, 0x00, 0x00, // modification_time\n      (timescale >> 24) & 0xff, (timescale >> 16) & 0xff, (timescale >> 8) & 0xff, timescale & 0xff,\n      (duration >> 24) & 0xff, (duration >> 16) & 0xff, (duration >> 8) & 0xff, duration & 0xff, // (duration >> 24) & 0xff, (duration >> 16) & 0xff, (duration >> 8) & 0xff, duration & 0xff,//todo\n      0x55, 0xc4, // 'und' language (undetermined) //todo 0x15, 0xC7\n      0x00, 0x00 // pre_defined\n    ]))\n    // console.log('[remux],mdhd, len,', mdhd.byteLength, hashVal(mdhd.toString()))\n    return mdhd\n  }\n\n  static hdlr (type) {\n    const hdlr = MP4.box(MP4.types.hdlr, MP4.HDLR_TYPES[type])\n    // console.log('[remux],hdlr, len,', hdlr.byteLength, hashVal(hdlr.toString()))\n    return hdlr\n  }\n\n  static minf (track) {\n    const minf = MP4.box(MP4.types.minf, track.type === TrackType.VIDEO ? MP4.VMHD : MP4.SMHD, MP4.DINF, MP4.stbl(track))\n    // console.log('[remux],minf, len,', minf.byteLength, hashVal(minf.toString()))\n    return minf\n  }\n\n  static stbl (track) {\n    const extBox = []\n    if (track && track.ext) {\n      track.ext.stss && extBox.push(MP4.stss(track.ext.stss.entries))\n      // track.ext.stss && extBox.push(MP4.ctts(track.ext.stss.entries))\n    }\n    const stbl = MP4.box(MP4.types.stbl, MP4.stsd(track), MP4.STTS, extBox[0], MP4.STSC, MP4.STSZ, MP4.STCO)\n    // console.log('[remux],stbl, len,', stbl.byteLength, hashVal(stbl.toString()))\n    return stbl\n  }\n\n  static stsd (track) {\n    let content\n    if (track.type === 'audio') {\n      if (track.useEME && track.enca) {\n        content = MP4.enca(track)\n        // console.log('[remux],enca, len,', content.byteLength, track.type, hashVal(content.toString()))\n      } else {\n        content = MP4.mp4a(track)\n        // console.log('[remux],mp4a, len,', content.byteLength, track.type, hashVal(content.toString()))\n      }\n    } else if (track.useEME && track.encv) {\n      content = MP4.encv(track)\n      // console.log('[remux],encv, len,', content.byteLength, track.type, hashVal(content.toString()))\n    } else {\n      content = MP4.avc1hev1(track)\n      // console.log('[remux],avc1hev1, len,', content.byteLength, track.type, hashVal(content.toString()))\n    }\n    const stsd = MP4.box(MP4.types.stsd, new Uint8Array([\n      0x00, // version 0\n      0x00, 0x00, 0x00, // flags\n      0x00, 0x00, 0x00, 0x01 // entry_count\n    ]), content)\n    // console.log('[remux],stsd, len,', stsd.byteLength, hashVal(stsd.toString()))\n    return stsd\n  }\n\n  static enca (data) {\n    const channelCount = data.enca.channelCount\n    const sampleRate = data.enca.sampleRate\n    const content = new Uint8Array([\n      0x00, 0x00, 0x00, // reserved\n      0x00, 0x00, 0x00, // reserved\n      0x00, 0x01, // data_reference_index\n      0x00, 0x00, 0x00, 0x00,\n      0x00, 0x00, 0x00, 0x00, // reserved\n      0x00, channelCount, // channelcount\n      0x00, 0x10, // sampleSize:16bits\n      0x00, 0x00, 0x00, 0x00, // reserved2\n      (sampleRate >> 8) & 0xff,\n      sampleRate & 0xff, //\n      0x00, 0x00\n    ])\n    const esds = MP4.esds(data.config)\n    // console.log('[remux],esds, len,', esds.byteLength, hashVal(esds.toString()))\n    const sinf = MP4.sinf(data.enca)\n    // console.log('[remux],sinf, len,', sinf.byteLength, hashVal(sinf.toString()))\n    return MP4.box(MP4.types.enca, content, esds, sinf)\n  }\n\n  static encv (track) {\n    const sps = track.sps.length > 0 ? track.sps[0] : []\n    const pps = track.pps.length > 0 ? track.pps[0] : []\n    const width = track.width\n    const height = track.height\n    const hSpacing = track.sarRatio[0]\n    const vSpacing = track.sarRatio[1]\n\n    const content = new Uint8Array([\n      0x00, 0x00, 0x00, // reserved\n      0x00, 0x00, 0x00, // reserved\n      0x00, 0x01, // data_reference_index\n\n      0x00, 0x00, // pre_defined\n      0x00, 0x00, // reserved\n      0x00, 0x00, 0x00, 0x00,\n      0x00, 0x00, 0x00, 0x00,\n      0x00, 0x00, 0x00, 0x00, // pre_defined\n      (width >> 8) & 0xff,\n      width & 0xff, // width\n      (height >> 8) & 0xff,\n      height & 0xff, // height\n      0x00, 0x48, 0x00, 0x00, // horizresolution\n      0x00, 0x48, 0x00, 0x00, // vertresolution\n      0x00, 0x00, 0x00, 0x00, // reserved\n      0x00, 0x01, // frame_count\n\n      0x12,\n      0x64, 0x61, 0x69, 0x6C, // dailymotion/hls.js\n      0x79, 0x6D, 0x6F, 0x74,\n      0x69, 0x6F, 0x6E, 0x2F,\n      0x68, 0x6C, 0x73, 0x2E,\n      0x6A, 0x73, 0x00, 0x00,\n      0x00, 0x00, 0x00, 0x00,\n      0x00, 0x00, 0x00, 0x00,\n      0x00, 0x00, 0x00, // compressorname\n      0x00, 0x18, // depth = 24\n      0x11, 0x11]) // pre_defined = -1;\n    const avcc = new Uint8Array([\n      0x01, // version\n      sps[1], // profile\n      sps[2], // profile compatible\n      sps[3], // level\n      0xfc | 3,\n      0xE0 | 1, // 目前只处理一个sps\n      sps.length >>> 8 & 0xff,\n      sps.length & 0xff\n    ].concat(...sps).concat([\n      0x01,\n      pps.length >>> 8 & 0xff,\n      pps.length & 0xff\n    ]).concat(...pps))\n    const btrt = new Uint8Array([\n      0x00, 0x00, 0x58, 0x39,\n      0x00, 0x0F, 0xC8, 0xC0,\n      0x00, 0x04, 0x56, 0x48\n    ])\n    const sinf = MP4.sinf(track.encv)\n    const pasp = new Uint8Array([\n      (hSpacing >> 24), // hSpacing\n      (hSpacing >> 16) & 0xff,\n      (hSpacing >> 8) & 0xff,\n      hSpacing & 0xff,\n      (vSpacing >> 24), // vSpacing\n      (vSpacing >> 16) & 0xff,\n      (vSpacing >> 8) & 0xff,\n      vSpacing & 0xff\n    ])\n    return MP4.box(MP4.types.encv, content, MP4.box(MP4.types.avcC, avcc), MP4.box(MP4.types.btrt, btrt), sinf, MP4.box(MP4.types.pasp, pasp))\n  }\n\n  static schi (data) {\n    const content = new Uint8Array([])\n    const tenc = MP4.tenc(data)\n    return MP4.box(MP4.types.schi, content, tenc)\n  }\n\n  static tenc (data) {\n    //  用于每个track的加密参数（包括KID、初始化向量、加密标志位），包含在TrackEncryptionBox(‘tenc’)中。\n    const content = new Uint8Array(\n      [\n        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // skip\n        data.default_IsEncrypted & 0xff, // default_isProtected\n        data.default_IV_size & 0xff // default_Per_Sample_IV_Size\n      ].concat(parse(data.default_KID)))\n    return MP4.box(MP4.types.tenc, content)\n  }\n\n  static sinf (data) {\n    const content = new Uint8Array([])\n    const frma = new Uint8Array([\n      data.data_format.charCodeAt(0),\n      data.data_format.charCodeAt(1),\n      data.data_format.charCodeAt(2),\n      data.data_format.charCodeAt(3)\n    ])\n    const schm = new Uint8Array([\n      0x00, 0x00, 0x00, 0x00,\n      0x63, 0x65, 0x6E, 0x63, // cenc\n      0x00, 0x01, 0x00, 0x00 // version\n    ])\n    const schi = MP4.schi(data)\n    return MP4.box(MP4.types.sinf, content, MP4.box(MP4.types.frma, frma), MP4.box(MP4.types.schm, schm), schi)\n  }\n\n  static avc1hev1 (track) {\n    const isHevc = track.codecType === VideoCodecType.HEVC\n    const typ = isHevc ? MP4.types.hvc1 : MP4.types.avc1\n    const config = isHevc ? MP4.hvcC(track) : MP4.avcC(track)\n    const boxes = [\n      new Uint8Array([\n        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // reserved\n        0x00, 0x01, // data_reference_index\n        0x00, 0x00, // pre_defined\n        0x00, 0x00, // reserved\n        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // pre_defined\n        (track.width >> 8) & 0xff, track.width & 0xff, // width\n        (track.height >> 8) & 0xff, track.height & 0xff, // height\n        0x00, 0x48, 0x00, 0x00, // horizresolution\n        0x00, 0x48, 0x00, 0x00, // vertresolution\n        0x00, 0x00, 0x00, 0x00, // reserved\n        0x00, 0x01, // frame_count\n        0x00, 0x00, 0x00, 0x00,\n        0x00, 0x00, 0x00, 0x00,\n        0x00, 0x00, 0x00, 0x00,\n        0x00, 0x00, 0x00, 0x00,\n        0x00, 0x00, 0x00, 0x00,\n        0x00, 0x00, 0x00, 0x00,\n        0x00, 0x00, 0x00, 0x00,\n        0x00, 0x00, 0x00, 0x00, // compressor name\n        0x00, 0x18, // depth\n        0x11, 0x11 // pre_defined = -1 //todo\n      ]), config\n    ]\n    // console.log('[remux],avc1hev1_0, len,', boxes[0].byteLength, hashVal(boxes[0].toString()))\n    // console.log('[remux],avc1hev1_1, len,', boxes[1].byteLength, hashVal(boxes[1].toString()))\n    if (isHevc) {\n      boxes.push(MP4.box(MP4.types.fiel, new Uint8Array([0x01, 0x00])))\n      // console.log('[remux],fiel, len,', boxes[2].byteLength, hashVal(boxes[2].toString()))\n    } else if (track.sarRatio && track.sarRatio.length > 1) {\n      boxes.push(MP4.pasp(track.sarRatio))\n      // console.log('[remux],pasp, len,', boxes[2].byteLength, hashVal(boxes[2].toString()))\n    }\n    return MP4.box(typ, ...boxes)\n  }\n\n  static avcC (track) {\n    const sps = []\n    const pps = []\n\n    let len\n    track.sps.forEach((s) => {\n      len = s.byteLength\n      sps.push((len >>> 8) & 0xff)\n      sps.push(len & 0xff)\n      sps.push(...s)\n    })\n\n    track.pps.forEach((p) => {\n      len = p.byteLength\n      pps.push((len >>> 8) & 0xff)\n      pps.push(len & 0xff)\n      pps.push(...p)\n    })\n\n    return MP4.box(MP4.types.avcC, new Uint8Array([\n      0x01, // configurationVersion\n      sps[3], // AVCProfileIndication\n      sps[4], // profile_compatibility\n      sps[5], // AVCLevelIndication\n      0xfc | 3, // lengthSizeMinusOne\n      0xe0 | track.sps.length // 3bit reserved (111) + numOfSequenceParameterSets\n    ].concat(...sps)\n      .concat([track.pps.length]) // numOfPictureParameterSets\n      .concat(...pps)))\n  }\n\n  static hvcC (track) {\n    const hvcC = track.hvcC\n    if (hvcC instanceof ArrayBuffer || hvcC instanceof Uint8Array) return hvcC\n    const { vps, sps, pps } = track\n    let data\n    if (hvcC) {\n      const pcf = hvcC.generalProfileCompatibilityFlags\n      const cif = hvcC.generalConstraintIndicatorFlags\n      const numOfArrays = (vps.length && 1) + (sps.length && 1) + (pps.length && 1)\n      data = [\n        0x01, // configurationVersion\n        hvcC.generalProfileSpace << 6 | hvcC.generalTierFlag << 5 | hvcC.generalProfileIdc,\n        pcf >>> 24, pcf >>> 16, pcf >>> 8, pcf,\n        cif[0], cif[1], cif[2], cif[3], cif[4], cif[5],\n        hvcC.generalLevelIdc,\n        0xF0, 0x00, // min_spatial_segmentation_idc\n        0xFC, // parallelismType\n        hvcC.chromaFormatIdc | 0xFC,\n        hvcC.bitDepthLumaMinus8 | 0xF8,\n        hvcC.bitDepthChromaMinus8 | 0xF8,\n        0x00, 0x00, // avgFrameRate\n        hvcC.numTemporalLayers << 3 | hvcC.temporalIdNested << 2 | 3,\n        numOfArrays\n      ]\n      const write = (x) => {\n        data.push(x.length >> 8, x.length)\n        data.push(...x)\n      }\n      if (vps.length) {\n        data.push(0xA0, 0x00, vps.length)\n        vps.forEach(write)\n      }\n      if (sps.length) {\n        data.push(0xA1, 0x00, sps.length)\n        sps.forEach(write)\n      }\n      if (pps.length) {\n        data.push(0xA2, 0x00, pps.length)\n        pps.forEach(write)\n      }\n    } else {\n      data = [\n        0x01, // configurationVersion\n        0x01, // profile_space + tier_flag + profile_idc\n        0x60, 0x00, 0x00, 0x00, // general_profile_compatibility\n        0x90, 0x00, 0x00, 0x00, 0x00, 0x00, // constraint_indicator_flags\n        0x5D, // level_idc=90\n        0xF0, 0x00, 0xFC, 0xFD, // profile_compatibility_indications\n        0xF8, // ‘11111’b + bitDepthLumaMinus8\n        0xF8, // ‘11111’b + bitDepthChromaMinus8\n        0x00, 0x00, // avgFrameRate\n        0x0F, // constantFrameRate + numTemporalLayers + ‘1’b + lengthSizeMinusOne\n        0x03, // numOfArrays\n\n        // vps\n        0xA0, 0x00, 0x01, // array_completeness + ‘0’b + NAL_unit_type + numNalus\n        0x00, 0x18, // nalUnitLength\n        0x40, 0x01, 0x0C, 0x01, 0xFF, 0xFF, 0x01, 0x60, 0x00, 0x00, 0x03, 0x00, 0x90, 0x00, 0x00, 0x03, 0x00, 0x00, 0x03, 0x00, 0x5D, 0x99, 0x98, 0x09,\n\n        // sps\n        0xA1, 0x00, 0x01, // array_completeness + ‘0’b + NAL_unit_type + numNalus\n        0x00, 0x2D, // nalUnitLength\n        0x42, 0x01, 0x01, 0x01, 0x60, 0x00, 0x00, 0x03, 0x00, 0x90, 0x00, 0x00, 0x03, 0x00, 0x00, 0x03, 0x00, 0x5D, 0xA0, 0x02,\n        0x80, 0x80, 0x2D, 0x16, 0x59, 0x99, 0xA4, 0x93, 0x2B, 0x9A, 0x80, 0x80, 0x80, 0x82, 0x00, 0x00, 0x03, 0x00, 0x02, 0x00,\n        0x00, 0x03, 0x00, 0x32, 0x10,\n\n        // pps\n        0xA2, 0x00, 0x01, // array_completeness + ‘0’b + NAL_unit_type + numNalus\n        0x00, 0x07, // nalUnitLength\n        0x44, 0x01, 0xC1, 0x72, 0xB4, 0x62, 0x40\n      ]\n    }\n    return MP4.box(MP4.types.hvcC, new Uint8Array(data))\n  }\n\n  static pasp ([hSpacing, vSpacing]) {\n    return MP4.box(MP4.types.pasp, new Uint8Array([\n      hSpacing >> 24, (hSpacing >> 16) & 0xff, (hSpacing >> 8) & 0xff, hSpacing & 0xff,\n      vSpacing >> 24, (vSpacing >> 16) & 0xff, (vSpacing >> 8) & 0xff, vSpacing & 0xff\n    ]))\n  }\n\n  static mp4a (track) {\n    return MP4.box(MP4.types.mp4a, new Uint8Array([\n      0x00, 0x00, 0x00,\n      0x00, 0x00, 0x00, // reserved\n      0x00, 0x01, // data_reference_index\n      0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // reserved\n      0x00, track.channelCount,\n      0x00, 0x10, // sampleSize:16bits\n      0x00, 0x00, // pre_defined\n      0x00, 0x00, // reserved\n      (track.sampleRate >> 8) & 0xff, track.sampleRate & 0xff,\n      0x00, 0x00\n    ]), track.config.length ? MP4.esds(track.config) : undefined)\n  }\n\n  static esds (config) {\n    const len = config.length\n    const esds = MP4.box(MP4.types.esds, new Uint8Array([\n      0x00, // version\n      0x00, 0x00, 0x00, // flags\n      0x03, // tag\n      0x17 + len, // length\n      0x00, 0x00, // ES_ID\n      0x00, // streamDependenceFlag, URL_flag, reserved, streamPriority\n      0x04, // tag\n      0x0f + len, // length\n      0x40, // object type\n      0x15, // streamType\n      0x00, 0x06, 0x00, // bufferSizeDB\n      0x00, 0x00, 0xda, 0xc0, // maxBitrate\n      0x00, 0x00, 0xda, 0xc0, // avgBitrate\n      0x05 // tag, DecoderSpecificInfoTag\n    ].concat([len])\n      .concat(config)\n      .concat(\n        [0x06, 0x01, 0x02]// GASpecificConfig\n      )\n    ))\n    // console.log('[remux],esds ,len ', esds.byteLength, hashVal(esds.toString()))\n    return esds\n  }\n\n  static mvex (tracks) {\n    // const mehd = MP4.box(MP4.types.mehd, this.extension(0, 0), Buffer.writeUint32(tracks[0].tkhdDuration))\n    // const mvex = MP4.box(MP4.types.mvex, mehd, MP4.trex1(1), MP4.trex2(2))\n    // // console.log('[remux],mvex, len,', mvex.byteLength, hashVal(mvex.toString()))\n    // const mvex = MP4.box(MP4.types.mvex, MP4.trex1(1), MP4.trex2(2))\n    const mvex = MP4.box(MP4.types.mvex, ...tracks.map((t) => MP4.trex(t.id)))\n    // console.log('[remux],mvex, len,', mvex.byteLength, hashVal(mvex.toString()))\n    return mvex\n  }\n\n  static trex (id) {\n    const trex = MP4.box(MP4.types.trex, new Uint8Array([\n      0x00, // version\n      0x00, 0x00, 0x00, // flags\n      id >> 24, (id >> 16) & 0xff, (id >> 8) & 0xff, id & 0xff, // track_ID\n      0x00, 0x00, 0x00, 0x01, // default_sample_description_index\n      0x00, 0x00, 0x00, 0x00, // default_sample_duration\n      0x00, 0x00, 0x00, 0x00, // default_sample_size\n      0x00, 0x01, 0x00, 0x01 // default_sample_flags\n    ]))\n    // console.log('[remux],trex, len,', trex.byteLength, hashVal(trex.toString()))\n    return trex\n  }\n\n  static trex1 (id) {\n    const trex = MP4.box(MP4.types.trex, new Uint8Array([\n      0x00, // version 0\n      0x00, 0x00, 0x00, // flags\n      (id >> 24),\n      (id >> 16) & 0xff,\n      (id >> 8) & 0xff,\n      (id & 0xff), // track_ID\n      0x00, 0x00, 0x00, 0x01, // default_sample_description_index\n      0x00, 0x00, 0x02, 0x00, // default_sample_duration\n      0x00, 0x00, 0x00, 0x00, // default_sample_size\n      0x00, 0x01, 0x00, 0x00 // default_sample_flags\n    ]))\n    // console.log('[remux],trex, len,', trex.byteLength, hashVal(trex.toString()))\n    return trex\n  }\n\n  static trex2 (id) {\n    const trex = MP4.box(MP4.types.trex, new Uint8Array([\n      0x00, // version 0\n      0x00, 0x00, 0x00, // flags\n      (id >> 24),\n      (id >> 16) & 0xff,\n      (id >> 8) & 0xff,\n      (id & 0xff), // track_ID\n      0x00, 0x00, 0x00, 0x01, // default_sample_description_index\n      0x00, 0x00, 0x04, 0x00, // default_sample_duration\n      0x00, 0x00, 0x00, 0x00, // default_sample_size\n      0x02, 0x00, 0x00, 0x00 // default_sample_flags\n    ]))\n    // console.log('[remux],trex, len,', trex.byteLength, hashVal(trex.toString()))\n    return trex\n  }\n\n  static moof (tracks) {\n    const moof = MP4.box(MP4.types.moof, MP4.mfhd(tracks[0].samples ? tracks[0].samples[0].gopId : 0), ...tracks.map((t) => MP4.traf(t)))\n    // console.log('[remux],moof, len', moof.byteLength)\n    return moof\n    // return MP4.box(MP4.types.moof, MP4.mfhd(tracks[0].gopId), ...tracks.map((t) => MP4.traf(t)))\n  }\n\n  static mfhd (sequenceNumber) {\n    // sequenceNumber += 1\n    const mfhd = MP4.box(MP4.types.mfhd, new Uint8Array([\n      0x00, // version\n      0x00, 0x00, 0x00, // flags\n      sequenceNumber >> 24, (sequenceNumber >> 16) & 0xff, (sequenceNumber >> 8) & 0xff, sequenceNumber & 0xff\n    ]))\n    // console.log('[remux],mfhd, len,', mfhd.byteLength, hashVal(mfhd.toString()))\n    return mfhd\n  }\n\n  static traf (track) {\n    const tfhd = MP4.tfhd(track.id)\n    // console.log('[remux],tfhd, len,', tfhd.byteLength, hashVal(tfhd.toString()), ', trackid = ', track.id)\n    // console.log('[remux],tfdt,baseMediaDecodeTime,', track.baseMediaDecodeTime)\n    const tfdt = MP4.tfdt(track, track.baseMediaDecodeTime)\n    let sencLength = 0\n    let samples\n    if (track.isVideo && track.videoSenc) {\n      samples = track.videoSenc\n      samples.forEach(function (item) {\n        sencLength = sencLength + 8\n        if (item.subsamples && item.subsamples.length) {\n          sencLength = sencLength + 2\n          sencLength = sencLength + item.subsamples.length * 6\n        }\n      })\n    }\n    track.videoSencLength = sencLength\n    // console.log('[remux],tfdt, len,', tfdt.toString().length)\n    // console.log('[remux],tfdt, len,', tfdt.byteLength, hashVal(tfdt.toString()))\n    if (!track.useEME || (!track.isVideoEncryption && !track.isAudioEncryption)) {\n      const sdtp = MP4.sdtp(track)\n      // console.log('[remux],sdtp, len,', sdtp.byteLength, hashVal(sdtp.toString()))\n      const offset = 16 + // tfhd\n        20 + // tfdt\n        8 + // traf header\n        16 + // mfhd\n        8 + // moof header\n        8 // mdat header\n      return MP4.box(MP4.types.traf, tfhd, tfdt, sdtp, MP4.trun(track.samples, sdtp.byteLength + offset))\n    } else if (track.isVideoEncryption) {\n      if (track.isVideo) {\n        // 加密视频\n        const saiz = MP4.saiz(track)\n        const saio = MP4.saio(track)\n        const trun = MP4.trun1(track)\n        const senc = MP4.senc(track)\n        const traf = MP4.box(MP4.types.traf, tfhd, tfdt, saiz, saio, trun, senc)\n        // console.log('[remux],trex_video, len,', traf.byteLength, hashVal(traf.toString()))\n        return traf\n      } else {\n        // 视频加密，音频加密和未加密处理\n        if (!track.isAudioEncryption) {\n          // 音频未加密\n          const sbgp = MP4.sbgp()\n          const trun = MP4.trun1(track)\n          return MP4.box(MP4.types.traf, tfhd, tfdt, sbgp, trun)\n        } else {\n          // 音频加密\n          const sbgp = MP4.sbgp()\n          const saiz = MP4.saiz(track)\n          const saio = MP4.saio(track)\n          const senc = MP4.senc(track)\n          const trun = MP4.trun1(track)\n          const traf = MP4.box(MP4.types.traf, tfhd, tfdt, sbgp, saiz, saio, senc, trun)\n          // console.log('[remux],trex_audio, len,', traf.byteLength, hashVal(traf.toString()))\n          return traf\n        }\n      }\n    } else {\n      // 视频未加密，音频加密\n      if (track.isVideo) {\n        const trun = MP4.trun1(track)\n        return MP4.box(MP4.types.traf, tfhd, tfdt, trun)\n      } else {\n        const sbgp = MP4.sbgp()\n        const saiz = MP4.saiz(track)\n        const saio = MP4.saio(track)\n        const senc = MP4.senc(track)\n        const trun = MP4.trun1(track)\n        const traf = MP4.box(MP4.types.traf, tfhd, tfdt, sbgp, saiz, saio, senc, trun)\n        // console.log('[remux],trex, len,', traf.byteLength, hashVal(traf.toString()))\n        return traf\n      }\n    }\n  }\n\n  static sdtp (data) {\n    const buffer = new Buffer()\n    data.samples.forEach(item => {\n      buffer.write(new Uint8Array(data.isVideo ? [item.keyframe ? 32 : 16] : [16]))\n    })\n    return MP4.box(MP4.types.sdtp, this.extension(0, 0), buffer.buffer)\n  }\n\n  static trun1 (data) {\n    // const id = data.id\n    // const ceil = id === 1 ? 12 : 4\n    const buffer = new Buffer()\n    const sampleCount = Buffer.writeUint32(data.samples.length)\n    let offset = null\n    if (data.isVideo) {\n      const sencLength = data.videoSencLength\n      /*\n      16 + // mfhd\n      16 + // tfhd\n      20 + // tfdt\n      17 + //saiz\n      24 + //saio\n      data.samples.length*16\n      4(offset) + 4(sampleCount) + 12(header)  //trun\n      12(header) + sencLength //senc\n      8 + // traf header\n      8 + // moof header\n      8 // mdat header\n      = 149+data.samples.length * 16 + sencLength\n       */\n      offset = Buffer.writeUint32(data.samples.length * 16 + sencLength + 149)\n      if (!data.isVideoEncryption && data.isAudioEncryption) {\n        offset = Buffer.writeUint32(data.samples.length * 16 + 92)\n      }\n    } else {\n      /*\n      16 + // mfhd\n      16 + // tfhd\n      20 + // tfdt\n      28 + //sbgp\n      4(offset) + 4(sampleCount) + 12(header)  //trun\n      8 + // traf header\n      8 + // moof header\n      8 // mdat header\n       */\n      let len = data.samples.length * 12 + 124\n      if (data.isAudioEncryption) {\n        len = data.samples.length * 12 + 8 * data.audioSenc.length + 177\n      }\n      offset = Buffer.writeUint32(len)\n    }\n\n    data.samples.forEach(item => {\n      buffer.write(Buffer.writeUint32(item.duration))\n      buffer.write(Buffer.writeUint32(item.size))\n      buffer.write(Buffer.writeUint32(item.keyframe ? 0x02000000 : 0x00010000))\n      if (data.isVideo) {\n        buffer.write(Buffer.writeUint32(item.cts ? item.cts : 0))\n      }\n    })\n\n    return MP4.box(MP4.types.trun, this.extension(0, data.flags), sampleCount, offset, buffer.buffer)\n  }\n\n  static senc (data) {\n    const buffer = new Buffer()\n    const len = data.samples.length\n    const ceil = data.isVideo ? 16 : 8\n    const flag = data.isVideo ? 2 : 0\n    let samples = []\n    let samplesLength = 0\n    if (data.isVideo) {\n      samples = data.videoSenc\n      samplesLength = data.videoSencLength\n    } else {\n      samples = data.audioSenc\n    }\n    samplesLength = samplesLength || ceil * len\n    buffer.write(\n      Buffer.writeUint32(16 + samplesLength), MP4.types.senc, this.extension(0, flag)\n    )\n    buffer.write(Buffer.writeUint32(len))\n    samples.forEach(item => {\n      for (let i = 0; i < item.InitializationVector.length; i++) {\n        buffer.write(new Uint8Array([item.InitializationVector[i]]))\n      }\n      if (item.subsamples && item.subsamples.length) {\n        buffer.write(Buffer.writeUint16(item.subsamples.length))\n        item.subsamples.forEach(value => {\n          buffer.write(Buffer.writeUint16(value.BytesOfClearData))\n          buffer.write(Buffer.writeUint32(value.BytesOfProtectedData))\n        })\n      }\n    })\n    return buffer.buffer\n    // return MP4.box(MP4.types.senc, this.extension(0, flag), buffer.buffer)\n  }\n\n  static saio (data) {\n    let length = data.samples.length * 12 + 141\n    if (!data.isVideo && data.isAudioEncryption) {\n      length = 149\n    }\n    const content = new Uint8Array([\n      0x01, 0x00, 0x00, 0x00,\n      0x00, 0x00, 0x00, 0x01,\n      0x00, 0x00, 0x00, 0x00,\n      (length >> 24) & 0xff,\n      (length >> 16) & 0xff,\n      (length >> 8) & 0xff,\n      length & 0xff\n    ])\n    return MP4.box(MP4.types.saio, content)\n  }\n\n  static saiz (data) {\n    const samplesLength = data.samples.length\n    const content = new Uint8Array([\n      0x00, 0x00, 0x00, 0x00,\n      0x10, // default sample info size\n      (samplesLength >> 24) & 0xff,\n      (samplesLength >> 16) & 0xff,\n      (samplesLength >> 8) & 0xff,\n      samplesLength & 0xff\n    ])\n    return MP4.box(MP4.types.saiz, content)\n  }\n\n  static sbgp () {\n    const content = new Uint8Array([\n      0x72, 0x6F, 0x6C, 0x6C, // sgpd, grouping_type\n      0x00, 0x00, 0x00, 0x01,\n      0x00, 0x00, 0x01, 0x19,\n      0x00, 0x00, 0x00, 0x01\n    ])\n    return MP4.box(MP4.types.sbgp, this.extension(0, 0), content)\n  }\n\n  static extension (version, flag) {\n    return new Uint8Array([\n      version,\n      (flag >> 16) & 0xff,\n      (flag >> 8) & 0xff,\n      flag & 0xff\n    ])\n  }\n\n  static tfhd (id) {\n    return MP4.box(MP4.types.tfhd, new Uint8Array([\n      0x00, // version 0\n      0x00, 0x00, 0x00, // flags todo 0x00\n      id >> 24, (id >> 16) & 0xff, (id >> 8) & 0xff, id & 0xff // track_ID\n    ]))\n  }\n\n  static tfdt (data, baseMediaDecodeTime) {\n    const upperWordBaseMediaDecodeTime = Math.floor(baseMediaDecodeTime / (UINT32_MAX + 1))\n    const lowerWordBaseMediaDecodeTime = Math.floor(baseMediaDecodeTime % (UINT32_MAX + 1))\n    if (data.useEME && (data.isVideoEncryption || data.isAudioEncryption)) {\n      return MP4.box(MP4.types.tfdt, new Uint8Array([\n        0x00, // version 0\n        0x00, 0x00, 0x00, // flags\n        lowerWordBaseMediaDecodeTime >> 24,\n        (lowerWordBaseMediaDecodeTime >> 16) & 0xff,\n        (lowerWordBaseMediaDecodeTime >> 8) & 0xff,\n        lowerWordBaseMediaDecodeTime & 0xff\n      ]))\n    } else {\n      return MP4.box(MP4.types.tfdt, new Uint8Array([\n        0x01, // version 1\n        0x00, 0x00, 0x00, // flags\n        upperWordBaseMediaDecodeTime >> 24,\n        (upperWordBaseMediaDecodeTime >> 16) & 0xff,\n        (upperWordBaseMediaDecodeTime >> 8) & 0xff,\n        upperWordBaseMediaDecodeTime & 0xff,\n        lowerWordBaseMediaDecodeTime >> 24,\n        (lowerWordBaseMediaDecodeTime >> 16) & 0xff,\n        (lowerWordBaseMediaDecodeTime >> 8) & 0xff,\n        lowerWordBaseMediaDecodeTime & 0xff\n      ]))\n    }\n  }\n\n  static trun (samples, offset) {\n    const sampleLen = samples.length\n    const dataLen = 12 + (16 * sampleLen)\n    offset += 8 + dataLen\n    const data = new Uint8Array(dataLen)\n    data.set([\n      0x00, // version\n      0x00, 0x0f, 0x01, // flags\n      (sampleLen >>> 24) & 0xff, (sampleLen >>> 16) & 0xff, (sampleLen >>> 8) & 0xff, sampleLen & 0xff,\n      (offset >>> 24) & 0xff, (offset >>> 16) & 0xff, (offset >>> 8) & 0xff, offset & 0xff // data_offset\n    ], 0)\n    for (let i = 0; i < sampleLen; i++) {\n      const {\n        duration, size, flag = {}, cts = 0\n      } = samples[i]\n      data.set([\n        (duration >>> 24) & 0xff, (duration >>> 16) & 0xff, (duration >>> 8) & 0xff, duration & 0xff,\n        (size >>> 24) & 0xff, (size >>> 16) & 0xff, (size >>> 8) & 0xff, size & 0xff,\n        (flag.isLeading << 2) | (flag.dependsOn === null || flag.dependsOn === undefined ? 1 : flag.dependsOn),\n        (flag.isDependedOn << 6) | (flag.hasRedundancy << 4) | (flag.paddingValue << 1) | (flag.isNonSyncSample === null || flag.isNonSyncSample === undefined ? 1 : flag.isNonSyncSample),\n        flag.degradationPriority & (0xf0 << 8), flag.degradationPriority & 0x0f, // sample_flags\n        (cts >>> 24) & 0xff, (cts >>> 16) & 0xff, (cts >>> 8) & 0xff, cts & 0xff // sample_composition_time_offset\n      ], 12 + 16 * i)\n    }\n\n    return MP4.box(MP4.types.trun, data)\n  }\n\n  static moovMP4 (tracks) {\n    return MP4.box(MP4.types.moov,\n      MP4.mvhd(tracks[0].duration, tracks[0].timescale),\n      ...tracks.map((t) => MP4.trackMP4(t)))\n  }\n\n  static trackMP4 (track) {\n    return MP4.box(\n      MP4.types.trak,\n      MP4.tkhd(track.id, track.duration, track.width, track.height),\n      MP4.mdiaMP4(track)\n    )\n  }\n\n  static mdiaMP4 (track) {\n    return MP4.box(MP4.types.mdia, MP4.mdhd(track.duration, track.timescale), MP4.hdlr(track.type), MP4.minfMP4(track))\n  }\n\n  static minfMP4 (track) {\n    return MP4.box(MP4.types.minf, track.type === TrackType.VIDEO ? MP4.VMHD : MP4.SMHD, MP4.DINF, MP4.stblMP4(track))\n  }\n\n  static stblMP4 (track) {\n    const { ext } = track\n    const boxes = [\n      MP4.stsd(track),\n      MP4.stts(ext.stts),\n      MP4.stsc(ext.stsc),\n      MP4.stsz(ext.stsz),\n      MP4.stco(ext.stco)\n    ]\n\n    if (ext.stss.length) {\n      boxes.push(MP4.stss(ext.stss))\n    }\n\n    if (ext.ctts.length) {\n      boxes.push(MP4.ctts(ext.ctts))\n    }\n\n    return MP4.box(MP4.types.stbl, ...boxes)\n  }\n\n  static stts (samples) {\n    const len = samples.length\n    const data = new Uint8Array(8 * len)\n    let offset = 0\n    samples.forEach(({ value, count }) => {\n      data.set([\n        count >> 24, (count >> 16) & 0xff, (count >> 8) & 0xff, count & 0xff,\n        value >> 24, (value >> 16) & 0xff, (value >> 8) & 0xff, value & 0xff\n      ], offset)\n      offset += 8\n    })\n\n    return MP4.box(MP4.types.stts, concatUint8Array(new Uint8Array([\n      0, 0, 0, 0,\n      (len >> 24), (len >> 16) & 0xff, (len >> 8) & 0xff, len & 0xff\n    ]), data))\n  }\n\n  static stsc (entries) {\n    const len = entries.length\n    const data = new Uint8Array(12 * len)\n    let offset = 0\n    entries.forEach(({ firstChunk, samplesPerChunk, sampleDescIndex }) => {\n      data.set([\n        firstChunk >> 24, (firstChunk >> 16) & 0xff, (firstChunk >> 8) & 0xff, firstChunk & 0xff,\n        samplesPerChunk >> 24, (samplesPerChunk >> 16) & 0xff, (samplesPerChunk >> 8) & 0xff, samplesPerChunk & 0xff,\n        sampleDescIndex >> 24, (sampleDescIndex >> 16) & 0xff, (sampleDescIndex >> 8) & 0xff, sampleDescIndex & 0xff\n      ], offset)\n      offset += 12\n    })\n    return MP4.box(MP4.types.stsc, concatUint8Array(new Uint8Array([\n      0, 0, 0, 0,\n      (len >> 24), (len >> 16) & 0xff, (len >> 8) & 0xff, len & 0xff\n    ]), data))\n  }\n\n  static stsz (samplesSizes) {\n    const len = samplesSizes.length\n    const data = new Uint8Array(4 * len)\n    let offset = 0\n    samplesSizes.forEach((x) => {\n      data.set([\n        x >> 24, (x >> 16) & 0xff, (x >> 8) & 0xff, x & 0xff\n      ], offset)\n      offset += 4\n    })\n    return MP4.box(MP4.types.stsz, concatUint8Array(\n      new Uint8Array([\n        0, 0, 0, 0,\n        0, 0, 0, 0,\n        len >> 24, (len >> 16) & 0xff, (len >> 8) & 0xff, len & 0xff\n      ]),\n      data\n    ))\n  }\n\n  static stco (offsets) {\n    const len = offsets.length\n    const data = new Uint8Array(4 * len)\n    let offset = 0\n    offsets.forEach((x) => {\n      data.set([\n        x >> 24, (x >> 16) & 0xff, (x >> 8) & 0xff, x & 0xff\n      ], offset)\n      offset += 4\n    })\n    return MP4.box(MP4.types.stco, concatUint8Array(\n      new Uint8Array([\n        0, 0, 0, 0,\n        len >> 24, (len >> 16) & 0xff, (len >> 8) & 0xff, len & 0xff\n      ]),\n      data\n    ))\n  }\n\n  static stss (keyframeIndexes) {\n    const len = keyframeIndexes.length\n    const data = new Uint8Array(4 * len)\n    let offset = 0\n    keyframeIndexes.forEach((x) => {\n      data.set([\n        x >> 24, (x >> 16) & 0xff, (x >> 8) & 0xff, x & 0xff\n      ], offset)\n      offset += 4\n    })\n    return MP4.box(MP4.types.stss, concatUint8Array(\n      new Uint8Array([\n        0, 0, 0, 0,\n        len >> 24, (len >> 16) & 0xff, (len >> 8) & 0xff, len & 0xff\n      ]),\n      data\n    ))\n  }\n\n  static ctts (samples) {\n    const len = samples.length\n    const data = new Uint8Array(8 * len)\n    let offset = 0\n    samples.forEach(({ value, count }) => {\n      data.set([\n        count >> 24, (count >> 16) & 0xff, (count >> 8) & 0xff, count & 0xff,\n        value >> 24, (value >> 16) & 0xff, (value >> 8) & 0xff, value & 0xff\n      ], offset)\n      offset += 8\n    })\n    return MP4.box(MP4.types.ctts, concatUint8Array(new Uint8Array([\n      0, 0, 0, 0,\n      len >> 24, (len >> 16) & 0xff, (len >> 8) & 0xff, len & 0xff\n    ]), data))\n  }\n\n  static styp () {\n    return MP4.box(MP4.types.styp, new Uint8Array([\n      0x6D, 0x73, 0x64, 0x68,\n      0x00, 0x00, 0x00, 0x00,\n      0x6D, 0x73, 0x64, 0x68,\n      0x6D, 0x73, 0x69, 0x78\n    ]))\n  }\n\n  // data.sampleOffset 指的是samples的序列号。_samples[0].idx\n  static sidx (data) {\n    // const buffer = new Buffer()\n    const timescale = data.timescale\n    const duration = data.samples[0].duration\n    const durationCount = duration * data.samples.length\n    const earliestTime = data.samples[0].sampleOffset * duration\n    let mdatSize = 8\n    data.samples.forEach(item => {\n      mdatSize += item.size\n    })\n    let length = 0\n    if (data.isVideo) {\n      let sencLength = 0\n      let samples\n      if (data.videoSenc) {\n        samples = data.videoSenc\n      }\n      if (data.isVideo) {\n        samples.forEach(item => {\n          sencLength = sencLength + 8\n          if (item.subsamples && item.subsamples.length) {\n            sencLength = sencLength + 2\n            sencLength = sencLength + item.subsamples.length * 6\n          }\n        })\n      }\n      data.videoSencLength = sencLength\n      length = mdatSize + 141 + data.samples.length * 16 + sencLength\n      if (data.useEME && data.isAudioEncryption && !data.isVideoEncryption) {\n        length = mdatSize + (data.samples.length * 16) + 84\n      }\n    } else {\n      length = mdatSize + 116 + data.samples.length * 12\n      if (data.useEME && data.isAudioEncryption) {\n        length = mdatSize + 169 + data.samples.length * 12 + 8 * data.audioSenc.length\n      }\n    }\n\n    const content = new Uint8Array([\n      0x00, 0x00, 0x00, 0x00,\n      0x00, 0x00, 0x00, data.id & 0xff, // ref_id\n      (timescale >> 24) & 0xff,\n      (timescale >> 16) & 0xff,\n      (timescale >> 8) & 0xff,\n      timescale & 0xff, // timescale\n      (earliestTime >> 24) & 0xff,\n      (earliestTime >> 16) & 0xff,\n      (earliestTime >> 8) & 0xff,\n      earliestTime & 0xff, // earliest_presentation_time\n      0x00, 0x00, 0x00, 0x00, // first_offset\n      0x00, 0x00, // reserved\n      0x00, 0x01, // ref_count\n      // 0x00, 0x04, 0x11, 0xCF, // ref_size + ref_type\n      // 0x00, 0x01, 0x0A, 0xA6, // ref_size + ref_type\n      0x00, // ref_size + ref_type ref_size = moof.size + mdat.size\n      (length >> 16) & 0xff,\n      (length >> 8) & 0xff,\n      length & 0xff,\n      (durationCount >> 24) & 0xff,\n      (durationCount >> 16) & 0xff,\n      (durationCount >> 8) & 0xff,\n      durationCount & 0xff,\n      0x90, 0x00, 0x00, 0x00\n    ])\n    return MP4.box(MP4.types.sidx, content)\n  }\n\n  static mdat (data) {\n    const mdat = MP4.box(MP4.types.mdat, data)\n    // console.log('[remux],mdat ,len ', mdat.byteLength, hashVal(mdat.toString()))\n    return mdat\n  }\n}\n","\nexport class Logger {\n  constructor (name, enable) {\n    this.name = name || ''\n    this._prefix = `[${this.name}]`\n    Logger.disabled = enable\n  }\n\n  debug (...args) {\n    if (Logger.disabled) return\n    console.debug(this._prefix, ...args)\n  }\n\n  log (...args) {\n    if (Logger.disabled) return\n    console.log(this._prefix, ...args)\n  }\n\n  warn (...args) {\n    if (Logger.disabled) return\n    console.warn(this._prefix, ...args)\n  }\n\n  error (...args) {\n    if (Logger.disabled) return\n    console.error(this._prefix, ...args)\n  }\n\n  table (...args) {\n    if (Logger.disabled) return\n    console.group(this._prefix)\n    console.table(...args)\n    console.groupEnd()\n  }\n\n  static disabled = true\n\n  static enable () {\n    Logger.disabled = false\n  }\n\n  static disable () {\n    Logger.disabled = true\n  }\n}\n","import {\n  WordArray,\n  Hasher,\n} from './core.js';\n\n// Constants table\nconst T = [];\n\n// Compute constants\nfor (let i = 0; i < 64; i += 1) {\n  T[i] = (Math.abs(Math.sin(i + 1)) * 0x100000000) | 0;\n}\n\nconst FF = (a, b, c, d, x, s, t) => {\n  const n = a + ((b & c) | (~b & d)) + x + t;\n  return ((n << s) | (n >>> (32 - s))) + b;\n};\n\nconst GG = (a, b, c, d, x, s, t) => {\n  const n = a + ((b & d) | (c & ~d)) + x + t;\n  return ((n << s) | (n >>> (32 - s))) + b;\n};\n\nconst HH = (a, b, c, d, x, s, t) => {\n  const n = a + (b ^ c ^ d) + x + t;\n  return ((n << s) | (n >>> (32 - s))) + b;\n};\n\nconst II = (a, b, c, d, x, s, t) => {\n  const n = a + (c ^ (b | ~d)) + x + t;\n  return ((n << s) | (n >>> (32 - s))) + b;\n};\n\n/**\n * MD5 hash algorithm.\n */\nexport class MD5Algo extends Hasher {\n  _doReset() {\n    this._hash = new WordArray([\n      0x67452301,\n      0xefcdab89,\n      0x98badcfe,\n      0x10325476,\n    ]);\n  }\n\n  _doProcessBlock(M, offset) {\n    const _M = M;\n\n    // Swap endian\n    for (let i = 0; i < 16; i += 1) {\n      // Shortcuts\n      const offset_i = offset + i;\n      const M_offset_i = M[offset_i];\n\n      _M[offset_i] = (\n        (((M_offset_i << 8) | (M_offset_i >>> 24)) & 0x00ff00ff)\n          | (((M_offset_i << 24) | (M_offset_i >>> 8)) & 0xff00ff00)\n      );\n    }\n\n    // Shortcuts\n    const H = this._hash.words;\n\n    const M_offset_0 = _M[offset + 0];\n    const M_offset_1 = _M[offset + 1];\n    const M_offset_2 = _M[offset + 2];\n    const M_offset_3 = _M[offset + 3];\n    const M_offset_4 = _M[offset + 4];\n    const M_offset_5 = _M[offset + 5];\n    const M_offset_6 = _M[offset + 6];\n    const M_offset_7 = _M[offset + 7];\n    const M_offset_8 = _M[offset + 8];\n    const M_offset_9 = _M[offset + 9];\n    const M_offset_10 = _M[offset + 10];\n    const M_offset_11 = _M[offset + 11];\n    const M_offset_12 = _M[offset + 12];\n    const M_offset_13 = _M[offset + 13];\n    const M_offset_14 = _M[offset + 14];\n    const M_offset_15 = _M[offset + 15];\n\n    // Working varialbes\n    let a = H[0];\n    let b = H[1];\n    let c = H[2];\n    let d = H[3];\n\n    // Computation\n    a = FF(a, b, c, d, M_offset_0, 7, T[0]);\n    d = FF(d, a, b, c, M_offset_1, 12, T[1]);\n    c = FF(c, d, a, b, M_offset_2, 17, T[2]);\n    b = FF(b, c, d, a, M_offset_3, 22, T[3]);\n    a = FF(a, b, c, d, M_offset_4, 7, T[4]);\n    d = FF(d, a, b, c, M_offset_5, 12, T[5]);\n    c = FF(c, d, a, b, M_offset_6, 17, T[6]);\n    b = FF(b, c, d, a, M_offset_7, 22, T[7]);\n    a = FF(a, b, c, d, M_offset_8, 7, T[8]);\n    d = FF(d, a, b, c, M_offset_9, 12, T[9]);\n    c = FF(c, d, a, b, M_offset_10, 17, T[10]);\n    b = FF(b, c, d, a, M_offset_11, 22, T[11]);\n    a = FF(a, b, c, d, M_offset_12, 7, T[12]);\n    d = FF(d, a, b, c, M_offset_13, 12, T[13]);\n    c = FF(c, d, a, b, M_offset_14, 17, T[14]);\n    b = FF(b, c, d, a, M_offset_15, 22, T[15]);\n\n    a = GG(a, b, c, d, M_offset_1, 5, T[16]);\n    d = GG(d, a, b, c, M_offset_6, 9, T[17]);\n    c = GG(c, d, a, b, M_offset_11, 14, T[18]);\n    b = GG(b, c, d, a, M_offset_0, 20, T[19]);\n    a = GG(a, b, c, d, M_offset_5, 5, T[20]);\n    d = GG(d, a, b, c, M_offset_10, 9, T[21]);\n    c = GG(c, d, a, b, M_offset_15, 14, T[22]);\n    b = GG(b, c, d, a, M_offset_4, 20, T[23]);\n    a = GG(a, b, c, d, M_offset_9, 5, T[24]);\n    d = GG(d, a, b, c, M_offset_14, 9, T[25]);\n    c = GG(c, d, a, b, M_offset_3, 14, T[26]);\n    b = GG(b, c, d, a, M_offset_8, 20, T[27]);\n    a = GG(a, b, c, d, M_offset_13, 5, T[28]);\n    d = GG(d, a, b, c, M_offset_2, 9, T[29]);\n    c = GG(c, d, a, b, M_offset_7, 14, T[30]);\n    b = GG(b, c, d, a, M_offset_12, 20, T[31]);\n\n    a = HH(a, b, c, d, M_offset_5, 4, T[32]);\n    d = HH(d, a, b, c, M_offset_8, 11, T[33]);\n    c = HH(c, d, a, b, M_offset_11, 16, T[34]);\n    b = HH(b, c, d, a, M_offset_14, 23, T[35]);\n    a = HH(a, b, c, d, M_offset_1, 4, T[36]);\n    d = HH(d, a, b, c, M_offset_4, 11, T[37]);\n    c = HH(c, d, a, b, M_offset_7, 16, T[38]);\n    b = HH(b, c, d, a, M_offset_10, 23, T[39]);\n    a = HH(a, b, c, d, M_offset_13, 4, T[40]);\n    d = HH(d, a, b, c, M_offset_0, 11, T[41]);\n    c = HH(c, d, a, b, M_offset_3, 16, T[42]);\n    b = HH(b, c, d, a, M_offset_6, 23, T[43]);\n    a = HH(a, b, c, d, M_offset_9, 4, T[44]);\n    d = HH(d, a, b, c, M_offset_12, 11, T[45]);\n    c = HH(c, d, a, b, M_offset_15, 16, T[46]);\n    b = HH(b, c, d, a, M_offset_2, 23, T[47]);\n\n    a = II(a, b, c, d, M_offset_0, 6, T[48]);\n    d = II(d, a, b, c, M_offset_7, 10, T[49]);\n    c = II(c, d, a, b, M_offset_14, 15, T[50]);\n    b = II(b, c, d, a, M_offset_5, 21, T[51]);\n    a = II(a, b, c, d, M_offset_12, 6, T[52]);\n    d = II(d, a, b, c, M_offset_3, 10, T[53]);\n    c = II(c, d, a, b, M_offset_10, 15, T[54]);\n    b = II(b, c, d, a, M_offset_1, 21, T[55]);\n    a = II(a, b, c, d, M_offset_8, 6, T[56]);\n    d = II(d, a, b, c, M_offset_15, 10, T[57]);\n    c = II(c, d, a, b, M_offset_6, 15, T[58]);\n    b = II(b, c, d, a, M_offset_13, 21, T[59]);\n    a = II(a, b, c, d, M_offset_4, 6, T[60]);\n    d = II(d, a, b, c, M_offset_11, 10, T[61]);\n    c = II(c, d, a, b, M_offset_2, 15, T[62]);\n    b = II(b, c, d, a, M_offset_9, 21, T[63]);\n\n    // Intermediate hash value\n    H[0] = (H[0] + a) | 0;\n    H[1] = (H[1] + b) | 0;\n    H[2] = (H[2] + c) | 0;\n    H[3] = (H[3] + d) | 0;\n  }\n  /* eslint-ensable no-param-reassign */\n\n  _doFinalize() {\n    // Shortcuts\n    const data = this._data;\n    const dataWords = data.words;\n\n    const nBitsTotal = this._nDataBytes * 8;\n    const nBitsLeft = data.sigBytes * 8;\n\n    // Add padding\n    dataWords[nBitsLeft >>> 5] |= 0x80 << (24 - (nBitsLeft % 32));\n\n    const nBitsTotalH = Math.floor(nBitsTotal / 0x100000000);\n    const nBitsTotalL = nBitsTotal;\n    dataWords[(((nBitsLeft + 64) >>> 9) << 4) + 15] = (\n      (((nBitsTotalH << 8) | (nBitsTotalH >>> 24)) & 0x00ff00ff)\n        | (((nBitsTotalH << 24) | (nBitsTotalH >>> 8)) & 0xff00ff00)\n    );\n    dataWords[(((nBitsLeft + 64) >>> 9) << 4) + 14] = (\n      (((nBitsTotalL << 8) | (nBitsTotalL >>> 24)) & 0x00ff00ff)\n        | (((nBitsTotalL << 24) | (nBitsTotalL >>> 8)) & 0xff00ff00)\n    );\n\n    data.sigBytes = (dataWords.length + 1) * 4;\n\n    // Hash final blocks\n    this._process();\n\n    // Shortcuts\n    const hash = this._hash;\n    const H = hash.words;\n\n    // Swap endian\n    for (let i = 0; i < 4; i += 1) {\n      // Shortcut\n      const H_i = H[i];\n\n      H[i] = (((H_i << 8) | (H_i >>> 24)) & 0x00ff00ff)\n        | (((H_i << 24) | (H_i >>> 8)) & 0xff00ff00);\n    }\n\n    // Return final computed hash\n    return hash;\n  }\n\n  clone() {\n    const clone = super.clone.call(this);\n    clone._hash = this._hash.clone();\n\n    return clone;\n  }\n}\n\n/**\n * Shortcut function to the hasher's object interface.\n *\n * @param {WordArray|string} message The message to hash.\n *\n * @return {WordArray} The hash.\n *\n * @static\n *\n * @example\n *\n *     var hash = CryptoJS.MD5('message');\n *     var hash = CryptoJS.MD5(wordArray);\n */\nexport const MD5 = Hasher._createHelper(MD5Algo);\n\n/**\n * Shortcut function to the HMAC's object interface.\n *\n * @param {WordArray|string} message The message to hash.\n * @param {WordArray|string} key The secret key.\n *\n * @return {WordArray} The HMAC.\n *\n * @static\n *\n * @example\n *\n *     var hmac = CryptoJS.HmacMD5(message, key);\n */\nexport const HmacMD5 = Hasher._createHmacHelper(MD5Algo);\n","import { MP4 } from './mp4'\nimport { concatUint8Array } from '../utils'\nimport { Logger } from './logger'\n\n/**\n * @typedef {Object} RemuxResult\n * @property {Uint8Array} [videoInitSegment]\n * @property {Uint8Array} [audioInitSegment]\n * @property {Uint8Array} [videoSegment]\n * @property {Uint8Array} [audioSegment]\n */\n\nexport class FMP4Remuxer {\n  /**\n   * @param {import('../model').VideoTrack} videoTrack\n   * @param {import('../model').AudioTrack} audioTrack\n   */\n  constructor (videoTrack, audioTrack, options) {\n    this.videoTrack = videoTrack\n    this.audioTrack = audioTrack\n    const browserVersions = /Chrome\\/([^.]+)/.exec(navigator.userAgent)\n    this.forceFirstIDR = browserVersions && Number(browserVersions[1]) < 50\n    this.log = new Logger('FMP4Remuxer', options && options.openLog ? !options.openLog : true)\n  }\n\n  /**\n   * @param {boolean} [createInit=false]\n   * @returns {RemuxResult}\n   */\n  remux (createInit = false, options = {}) {\n    const videoTrack = this.videoTrack\n    const audioTrack = this.audioTrack\n    const hasVideo = videoTrack.exist()\n    const hasAudio = audioTrack.exist()\n\n    let videoInitSegment\n    let audioInitSegment\n\n    let initSegment\n    const tracks = []\n\n    if (createInit) {\n      if (options && options.initMerge) {\n        if (hasVideo) {\n          tracks.push(this.videoTrack)\n        }\n        if (hasAudio) {\n          tracks.push(this.audioTrack)\n        }\n        initSegment = MP4.initSegment(tracks)\n      } else {\n        if (hasVideo) videoInitSegment = MP4.initSegment([this.videoTrack])\n        if (hasAudio) audioInitSegment = MP4.initSegment([this.audioTrack])\n      }\n    }\n\n    let videoSegment\n    let audioSegment\n    if (hasVideo && videoTrack.hasSample()) {\n      videoSegment = this._remuxVideo()\n    }\n\n    if (hasAudio && audioTrack.hasSample()) {\n      audioSegment = this._remuxAudio()\n    }\n\n    videoTrack.samples = []\n    audioTrack.samples = []\n\n    return {\n      initSegment,\n      videoInitSegment,\n      audioInitSegment,\n      videoSegment,\n      audioSegment\n    }\n  }\n\n  _remuxVideo () {\n    const track = this.videoTrack\n    if (this.forceFirstIDR) {\n      track.samples[0].flag = { dependsOn: 2, isNonSyncSample: 0 }\n    }\n    const samples = track.samples\n\n    let mdatSize = 0\n\n    samples.forEach((s) => {\n      mdatSize += s.units.reduce((t, c) => (t + c.byteLength), 0)\n      mdatSize += (s.units.length * 4)\n    })\n\n    const mdata = new Uint8Array(mdatSize)\n    const mdatView = new DataView(mdata.buffer)\n\n    for (let i = 0, l = samples.length, offset = 0, sample; i < l; i++) {\n      sample = samples[i]\n\n      let sampleSize = 0\n      sample.units.forEach((u) => {\n        mdatView.setUint32(offset, u.byteLength)\n        offset += 4\n        mdata.set(u, offset)\n        offset += u.byteLength\n        sampleSize += (4 + u.byteLength)\n      })\n      sample.size = sampleSize\n    }\n    const mdat = MP4.mdat(mdata)\n\n    const moof = MP4.moof([track])\n    return concatUint8Array(moof, mdat)\n\n  }\n\n  _remuxAudio () {\n    const track = this.audioTrack\n    const mdata = new Uint8Array(track.samples.reduce((t, c) => (t + c.size), 0))\n    track.samples.reduce((offset, s) => {\n      mdata.set(s.data, offset)\n      return offset + s.size\n    }, 0)\n    const mdat = MP4.mdat(mdata)\n    const moof = MP4.moof([track])\n    return concatUint8Array(moof, mdat)\n  }\n\n  reset () {\n    this.videoTrack.reset()\n    this.audioTrack.reset()\n  }\n}\n","/* eslint-disable no-use-before-define */\n\n/**\n * Base class for inheritance.\n */\nexport class Base {\n  /**\n   * Extends this object and runs the init method.\n   * Arguments to create() will be passed to init().\n   *\n   * @return {Object} The new object.\n   *\n   * @static\n   *\n   * @example\n   *\n   *     var instance = MyType.create();\n   */\n  static create(...args) {\n    return new this(...args);\n  }\n\n  /**\n   * Copies properties into this object.\n   *\n   * @param {Object} properties The properties to mix in.\n   *\n   * @example\n   *\n   *     MyType.mixIn({\n   *         field: 'value'\n   *     });\n   */\n  mixIn(properties) {\n    return Object.assign(this, properties);\n  }\n\n  /**\n   * Creates a copy of this object.\n   *\n   * @return {Object} The clone.\n   *\n   * @example\n   *\n   *     var clone = instance.clone();\n   */\n  clone() {\n    const clone = new this.constructor();\n    Object.assign(clone, this);\n    return clone;\n  }\n}\n\n/**\n * An array of 32-bit words.\n *\n * @property {Array} words The array of 32-bit words.\n * @property {number} sigBytes The number of significant bytes in this word array.\n */\nexport class WordArray extends Base {\n  /**\n   * Initializes a newly created word array.\n   *\n   * @param {Array} words (Optional) An array of 32-bit words.\n   * @param {number} sigBytes (Optional) The number of significant bytes in the words.\n   *\n   * @example\n   *\n   *     var wordArray = CryptoJS.lib.WordArray.create();\n   *     var wordArray = CryptoJS.lib.WordArray.create([0x00010203, 0x04050607]);\n   *     var wordArray = CryptoJS.lib.WordArray.create([0x00010203, 0x04050607], 6);\n   */\n  constructor(words = [], sigBytes = words.length * 4) {\n    super();\n\n    let typedArray = words;\n    // Convert buffers to uint8\n    if (typedArray instanceof ArrayBuffer) {\n      typedArray = new Uint8Array(typedArray);\n    }\n\n    // Convert other array views to uint8\n    if (\n      typedArray instanceof Int8Array\n      || typedArray instanceof Uint8ClampedArray\n      || typedArray instanceof Int16Array\n      || typedArray instanceof Uint16Array\n      || typedArray instanceof Int32Array\n      || typedArray instanceof Uint32Array\n      || typedArray instanceof Float32Array\n      || typedArray instanceof Float64Array\n    ) {\n      typedArray = new Uint8Array(typedArray.buffer, typedArray.byteOffset, typedArray.byteLength);\n    }\n\n    // Handle Uint8Array\n    if (typedArray instanceof Uint8Array) {\n      // Shortcut\n      const typedArrayByteLength = typedArray.byteLength;\n\n      // Extract bytes\n      const _words = [];\n      for (let i = 0; i < typedArrayByteLength; i += 1) {\n        _words[i >>> 2] |= typedArray[i] << (24 - (i % 4) * 8);\n      }\n\n      // Initialize this word array\n      this.words = _words;\n      this.sigBytes = typedArrayByteLength;\n    } else {\n      // Else call normal init\n      this.words = words;\n      this.sigBytes = sigBytes;\n    }\n  }\n\n  /**\n   * Creates a word array filled with random bytes.\n   *\n   * @param {number} nBytes The number of random bytes to generate.\n   *\n   * @return {WordArray} The random word array.\n   *\n   * @static\n   *\n   * @example\n   *\n   *     var wordArray = CryptoJS.lib.WordArray.random(16);\n   */\n  static random(nBytes) {\n    const words = [];\n\n    const r = (m_w) => {\n      let _m_w = m_w;\n      let _m_z = 0x3ade68b1;\n      const mask = 0xffffffff;\n\n      return () => {\n        _m_z = (0x9069 * (_m_z & 0xFFFF) + (_m_z >> 0x10)) & mask;\n        _m_w = (0x4650 * (_m_w & 0xFFFF) + (_m_w >> 0x10)) & mask;\n        let result = ((_m_z << 0x10) + _m_w) & mask;\n        result /= 0x100000000;\n        result += 0.5;\n        return result * (Math.random() > 0.5 ? 1 : -1);\n      };\n    };\n\n    for (let i = 0, rcache; i < nBytes; i += 4) {\n      const _r = r((rcache || Math.random()) * 0x100000000);\n\n      rcache = _r() * 0x3ade67b7;\n      words.push((_r() * 0x100000000) | 0);\n    }\n\n    return new WordArray(words, nBytes);\n  }\n\n  /**\n   * Converts this word array to a string.\n   *\n   * @param {Encoder} encoder (Optional) The encoding strategy to use. Default: CryptoJS.enc.Hex\n   *\n   * @return {string} The stringified word array.\n   *\n   * @example\n   *\n   *     var string = wordArray + '';\n   *     var string = wordArray.toString();\n   *     var string = wordArray.toString(CryptoJS.enc.Utf8);\n   */\n  toString(encoder = Hex) {\n    return encoder.stringify(this);\n  }\n\n  /**\n   * Concatenates a word array to this word array.\n   *\n   * @param {WordArray} wordArray The word array to append.\n   *\n   * @return {WordArray} This word array.\n   *\n   * @example\n   *\n   *     wordArray1.concat(wordArray2);\n   */\n  concat(wordArray) {\n    // Shortcuts\n    const thisWords = this.words;\n    const thatWords = wordArray.words;\n    const thisSigBytes = this.sigBytes;\n    const thatSigBytes = wordArray.sigBytes;\n\n    // Clamp excess bits\n    this.clamp();\n\n    // Concat\n    if (thisSigBytes % 4) {\n      // Copy one byte at a time\n      for (let i = 0; i < thatSigBytes; i += 1) {\n        const thatByte = (thatWords[i >>> 2] >>> (24 - (i % 4) * 8)) & 0xff;\n        thisWords[(thisSigBytes + i) >>> 2] |= thatByte << (24 - ((thisSigBytes + i) % 4) * 8);\n      }\n    } else {\n      // Copy one word at a time\n      for (let i = 0; i < thatSigBytes; i += 4) {\n        thisWords[(thisSigBytes + i) >>> 2] = thatWords[i >>> 2];\n      }\n    }\n    this.sigBytes += thatSigBytes;\n\n    // Chainable\n    return this;\n  }\n\n  /**\n   * Removes insignificant bits.\n   *\n   * @example\n   *\n   *     wordArray.clamp();\n   */\n  clamp() {\n    // Shortcuts\n    const { words, sigBytes } = this;\n\n    // Clamp\n    words[sigBytes >>> 2] &= 0xffffffff << (32 - (sigBytes % 4) * 8);\n    words.length = Math.ceil(sigBytes / 4);\n  }\n\n  /**\n   * Creates a copy of this word array.\n   *\n   * @return {WordArray} The clone.\n   *\n   * @example\n   *\n   *     var clone = wordArray.clone();\n   */\n  clone() {\n    const clone = super.clone.call(this);\n    clone.words = this.words.slice(0);\n\n    return clone;\n  }\n}\n\n/**\n * Hex encoding strategy.\n */\nexport const Hex = {\n  /**\n   * Converts a word array to a hex string.\n   *\n   * @param {WordArray} wordArray The word array.\n   *\n   * @return {string} The hex string.\n   *\n   * @static\n   *\n   * @example\n   *\n   *     var hexString = CryptoJS.enc.Hex.stringify(wordArray);\n   */\n  stringify(wordArray) {\n    // Shortcuts\n    const { words, sigBytes } = wordArray;\n\n    // Convert\n    const hexChars = [];\n    for (let i = 0; i < sigBytes; i += 1) {\n      const bite = (words[i >>> 2] >>> (24 - (i % 4) * 8)) & 0xff;\n      hexChars.push((bite >>> 4).toString(16));\n      hexChars.push((bite & 0x0f).toString(16));\n    }\n\n    return hexChars.join('');\n  },\n\n  /**\n   * Converts a hex string to a word array.\n   *\n   * @param {string} hexStr The hex string.\n   *\n   * @return {WordArray} The word array.\n   *\n   * @static\n   *\n   * @example\n   *\n   *     var wordArray = CryptoJS.enc.Hex.parse(hexString);\n   */\n  parse(hexStr) {\n    // Shortcut\n    const hexStrLength = hexStr.length;\n\n    // Convert\n    const words = [];\n    for (let i = 0; i < hexStrLength; i += 2) {\n      words[i >>> 3] |= parseInt(hexStr.substr(i, 2), 16) << (24 - (i % 8) * 4);\n    }\n\n    return new WordArray(words, hexStrLength / 2);\n  },\n};\n\n/**\n * Latin1 encoding strategy.\n */\nexport const Latin1 = {\n  /**\n   * Converts a word array to a Latin1 string.\n   *\n   * @param {WordArray} wordArray The word array.\n   *\n   * @return {string} The Latin1 string.\n   *\n   * @static\n   *\n   * @example\n   *\n   *     var latin1String = CryptoJS.enc.Latin1.stringify(wordArray);\n   */\n  stringify(wordArray) {\n    // Shortcuts\n    const { words, sigBytes } = wordArray;\n\n    // Convert\n    const latin1Chars = [];\n    for (let i = 0; i < sigBytes; i += 1) {\n      const bite = (words[i >>> 2] >>> (24 - (i % 4) * 8)) & 0xff;\n      latin1Chars.push(String.fromCharCode(bite));\n    }\n\n    return latin1Chars.join('');\n  },\n\n  /**\n   * Converts a Latin1 string to a word array.\n   *\n   * @param {string} latin1Str The Latin1 string.\n   *\n   * @return {WordArray} The word array.\n   *\n   * @static\n   *\n   * @example\n   *\n   *     var wordArray = CryptoJS.enc.Latin1.parse(latin1String);\n   */\n  parse(latin1Str) {\n    // Shortcut\n    const latin1StrLength = latin1Str.length;\n\n    // Convert\n    const words = [];\n    for (let i = 0; i < latin1StrLength; i += 1) {\n      words[i >>> 2] |= (latin1Str.charCodeAt(i) & 0xff) << (24 - (i % 4) * 8);\n    }\n\n    return new WordArray(words, latin1StrLength);\n  },\n};\n\n/**\n * UTF-8 encoding strategy.\n */\nexport const Utf8 = {\n  /**\n   * Converts a word array to a UTF-8 string.\n   *\n   * @param {WordArray} wordArray The word array.\n   *\n   * @return {string} The UTF-8 string.\n   *\n   * @static\n   *\n   * @example\n   *\n   *     var utf8String = CryptoJS.enc.Utf8.stringify(wordArray);\n   */\n  stringify(wordArray) {\n    try {\n      return decodeURIComponent(escape(Latin1.stringify(wordArray)));\n    } catch (e) {\n      throw new Error('Malformed UTF-8 data');\n    }\n  },\n\n  /**\n   * Converts a UTF-8 string to a word array.\n   *\n   * @param {string} utf8Str The UTF-8 string.\n   *\n   * @return {WordArray} The word array.\n   *\n   * @static\n   *\n   * @example\n   *\n   *     var wordArray = CryptoJS.enc.Utf8.parse(utf8String);\n   */\n  parse(utf8Str) {\n    return Latin1.parse(unescape(encodeURIComponent(utf8Str)));\n  },\n};\n\n/**\n * Abstract buffered block algorithm template.\n *\n * The property blockSize must be implemented in a concrete subtype.\n *\n * @property {number} _minBufferSize\n *\n *     The number of blocks that should be kept unprocessed in the buffer. Default: 0\n */\nexport class BufferedBlockAlgorithm extends Base {\n  constructor() {\n    super();\n    this._minBufferSize = 0;\n  }\n\n  /**\n   * Resets this block algorithm's data buffer to its initial state.\n   *\n   * @example\n   *\n   *     bufferedBlockAlgorithm.reset();\n   */\n  reset() {\n    // Initial values\n    this._data = new WordArray();\n    this._nDataBytes = 0;\n  }\n\n  /**\n   * Adds new data to this block algorithm's buffer.\n   *\n   * @param {WordArray|string} data\n   *\n   *     The data to append. Strings are converted to a WordArray using UTF-8.\n   *\n   * @example\n   *\n   *     bufferedBlockAlgorithm._append('data');\n   *     bufferedBlockAlgorithm._append(wordArray);\n   */\n  _append(data) {\n    let m_data = data;\n\n    // Convert string to WordArray, else assume WordArray already\n    if (typeof m_data === 'string') {\n      m_data = Utf8.parse(m_data);\n    }\n\n    // Append\n    this._data.concat(m_data);\n    this._nDataBytes += m_data.sigBytes;\n  }\n\n  /**\n   * Processes available data blocks.\n   *\n   * This method invokes _doProcessBlock(offset), which must be implemented by a concrete subtype.\n   *\n   * @param {boolean} doFlush Whether all blocks and partial blocks should be processed.\n   *\n   * @return {WordArray} The processed data.\n   *\n   * @example\n   *\n   *     var processedData = bufferedBlockAlgorithm._process();\n   *     var processedData = bufferedBlockAlgorithm._process(!!'flush');\n   */\n  _process(doFlush) {\n    let processedWords;\n\n    // Shortcuts\n    const { _data: data, blockSize } = this;\n    const dataWords = data.words;\n    const dataSigBytes = data.sigBytes;\n    const blockSizeBytes = blockSize * 4;\n\n    // Count blocks ready\n    let nBlocksReady = dataSigBytes / blockSizeBytes;\n    if (doFlush) {\n      // Round up to include partial blocks\n      nBlocksReady = Math.ceil(nBlocksReady);\n    } else {\n      // Round down to include only full blocks,\n      // less the number of blocks that must remain in the buffer\n      nBlocksReady = Math.max((nBlocksReady | 0) - this._minBufferSize, 0);\n    }\n\n    // Count words ready\n    const nWordsReady = nBlocksReady * blockSize;\n\n    // Count bytes ready\n    const nBytesReady = Math.min(nWordsReady * 4, dataSigBytes);\n\n    // Process blocks\n    if (nWordsReady) {\n      for (let offset = 0; offset < nWordsReady; offset += blockSize) {\n        // Perform concrete-algorithm logic\n        this._doProcessBlock(dataWords, offset);\n      }\n\n      // Remove processed words\n      processedWords = dataWords.splice(0, nWordsReady);\n      data.sigBytes -= nBytesReady;\n    }\n\n    // Return processed words\n    return new WordArray(processedWords, nBytesReady);\n  }\n\n  /**\n   * Creates a copy of this object.\n   *\n   * @return {Object} The clone.\n   *\n   * @example\n   *\n   *     var clone = bufferedBlockAlgorithm.clone();\n   */\n  clone() {\n    const clone = super.clone.call(this);\n    clone._data = this._data.clone();\n\n    return clone;\n  }\n}\n\n/**\n * Abstract hasher template.\n *\n * @property {number} blockSize\n *\n *     The number of 32-bit words this hasher operates on. Default: 16 (512 bits)\n */\nexport class Hasher extends BufferedBlockAlgorithm {\n  constructor(cfg) {\n    super();\n\n    this.blockSize = 512 / 32;\n\n    /**\n     * Configuration options.\n     */\n    this.cfg = Object.assign(new Base(), cfg);\n\n    // Set initial values\n    this.reset();\n  }\n\n  /**\n   * Creates a shortcut function to a hasher's object interface.\n   *\n   * @param {Hasher} SubHasher The hasher to create a helper for.\n   *\n   * @return {Function} The shortcut function.\n   *\n   * @static\n   *\n   * @example\n   *\n   *     var SHA256 = CryptoJS.lib.Hasher._createHelper(CryptoJS.algo.SHA256);\n   */\n  static _createHelper(SubHasher) {\n    return (message, cfg) => new SubHasher(cfg).finalize(message);\n  }\n\n  /**\n   * Creates a shortcut function to the HMAC's object interface.\n   *\n   * @param {Hasher} SubHasher The hasher to use in this HMAC helper.\n   *\n   * @return {Function} The shortcut function.\n   *\n   * @static\n   *\n   * @example\n   *\n   *     var HmacSHA256 = CryptoJS.lib.Hasher._createHmacHelper(CryptoJS.algo.SHA256);\n   */\n  static _createHmacHelper(SubHasher) {\n    return (message, key) => new HMAC(SubHasher, key).finalize(message);\n  }\n\n  /**\n   * Resets this hasher to its initial state.\n   *\n   * @example\n   *\n   *     hasher.reset();\n   */\n  reset() {\n    // Reset data buffer\n    super.reset.call(this);\n\n    // Perform concrete-hasher logic\n    this._doReset();\n  }\n\n  /**\n   * Updates this hasher with a message.\n   *\n   * @param {WordArray|string} messageUpdate The message to append.\n   *\n   * @return {Hasher} This hasher.\n   *\n   * @example\n   *\n   *     hasher.update('message');\n   *     hasher.update(wordArray);\n   */\n  update(messageUpdate) {\n    // Append\n    this._append(messageUpdate);\n\n    // Update the hash\n    this._process();\n\n    // Chainable\n    return this;\n  }\n\n  /**\n   * Finalizes the hash computation.\n   * Note that the finalize operation is effectively a destructive, read-once operation.\n   *\n   * @param {WordArray|string} messageUpdate (Optional) A final message update.\n   *\n   * @return {WordArray} The hash.\n   *\n   * @example\n   *\n   *     var hash = hasher.finalize();\n   *     var hash = hasher.finalize('message');\n   *     var hash = hasher.finalize(wordArray);\n   */\n  finalize(messageUpdate) {\n    // Final message update\n    if (messageUpdate) {\n      this._append(messageUpdate);\n    }\n\n    // Perform concrete-hasher logic\n    const hash = this._doFinalize();\n\n    return hash;\n  }\n}\n\n/**\n * HMAC algorithm.\n */\nexport class HMAC extends Base {\n  /**\n   * Initializes a newly created HMAC.\n   *\n   * @param {Hasher} SubHasher The hash algorithm to use.\n   * @param {WordArray|string} key The secret key.\n   *\n   * @example\n   *\n   *     var hmacHasher = CryptoJS.algo.HMAC.create(CryptoJS.algo.SHA256, key);\n   */\n  constructor(SubHasher, key) {\n    super();\n\n    const hasher = new SubHasher();\n    this._hasher = hasher;\n\n    // Convert string to WordArray, else assume WordArray already\n    let _key = key;\n    if (typeof _key === 'string') {\n      _key = Utf8.parse(_key);\n    }\n\n    // Shortcuts\n    const hasherBlockSize = hasher.blockSize;\n    const hasherBlockSizeBytes = hasherBlockSize * 4;\n\n    // Allow arbitrary length keys\n    if (_key.sigBytes > hasherBlockSizeBytes) {\n      _key = hasher.finalize(key);\n    }\n\n    // Clamp excess bits\n    _key.clamp();\n\n    // Clone key for inner and outer pads\n    const oKey = _key.clone();\n    this._oKey = oKey;\n    const iKey = _key.clone();\n    this._iKey = iKey;\n\n    // Shortcuts\n    const oKeyWords = oKey.words;\n    const iKeyWords = iKey.words;\n\n    // XOR keys with pad constants\n    for (let i = 0; i < hasherBlockSize; i += 1) {\n      oKeyWords[i] ^= 0x5c5c5c5c;\n      iKeyWords[i] ^= 0x36363636;\n    }\n    oKey.sigBytes = hasherBlockSizeBytes;\n    iKey.sigBytes = hasherBlockSizeBytes;\n\n    // Set initial values\n    this.reset();\n  }\n\n  /**\n   * Resets this HMAC to its initial state.\n   *\n   * @example\n   *\n   *     hmacHasher.reset();\n   */\n  reset() {\n    // Shortcut\n    const hasher = this._hasher;\n\n    // Reset\n    hasher.reset();\n    hasher.update(this._iKey);\n  }\n\n  /**\n   * Updates this HMAC with a message.\n   *\n   * @param {WordArray|string} messageUpdate The message to append.\n   *\n   * @return {HMAC} This HMAC instance.\n   *\n   * @example\n   *\n   *     hmacHasher.update('message');\n   *     hmacHasher.update(wordArray);\n   */\n  update(messageUpdate) {\n    this._hasher.update(messageUpdate);\n\n    // Chainable\n    return this;\n  }\n\n  /**\n   * Finalizes the HMAC computation.\n   * Note that the finalize operation is effectively a destructive, read-once operation.\n   *\n   * @param {WordArray|string} messageUpdate (Optional) A final message update.\n   *\n   * @return {WordArray} The HMAC.\n   *\n   * @example\n   *\n   *     var hmac = hmacHasher.finalize();\n   *     var hmac = hmacHasher.finalize('message');\n   *     var hmac = hmacHasher.finalize(wordArray);\n   */\n  finalize(messageUpdate) {\n    // Shortcut\n    const hasher = this._hasher;\n\n    // Compute HMAC\n    const innerHash = hasher.finalize(messageUpdate);\n    hasher.reset();\n    const hmac = hasher.finalize(this._oKey.clone().concat(innerHash));\n\n    return hmac;\n  }\n}\n","import {\n  WordArray,\n} from './core.js';\n\nconst parseLoop = (base64Str, base64StrLength, reverseMap) => {\n  const words = [];\n  let nBytes = 0;\n  for (let i = 0; i < base64StrLength; i += 1) {\n    if (i % 4) {\n      const bits1 = reverseMap[base64Str.charCodeAt(i - 1)] << ((i % 4) * 2);\n      const bits2 = reverseMap[base64Str.charCodeAt(i)] >>> (6 - (i % 4) * 2);\n      const bitsCombined = bits1 | bits2;\n      words[nBytes >>> 2] |= bitsCombined << (24 - (nBytes % 4) * 8);\n      nBytes += 1;\n    }\n  }\n  return WordArray.create(words, nBytes);\n};\n\n/**\n * Base64 encoding strategy.\n */\nexport const Base64 = {\n  /**\n   * Converts a word array to a Base64 string.\n   *\n   * @param {WordArray} wordArray The word array.\n   *\n   * @return {string} The Base64 string.\n   *\n   * @static\n   *\n   * @example\n   *\n   *     const base64String = CryptoJS.enc.Base64.stringify(wordArray);\n   */\n  stringify(wordArray) {\n    // Shortcuts\n    const { words, sigBytes } = wordArray;\n    const map = this._map;\n\n    // Clamp excess bits\n    wordArray.clamp();\n\n    // Convert\n    const base64Chars = [];\n    for (let i = 0; i < sigBytes; i += 3) {\n      const byte1 = (words[i >>> 2] >>> (24 - (i % 4) * 8)) & 0xff;\n      const byte2 = (words[(i + 1) >>> 2] >>> (24 - ((i + 1) % 4) * 8)) & 0xff;\n      const byte3 = (words[(i + 2) >>> 2] >>> (24 - ((i + 2) % 4) * 8)) & 0xff;\n\n      const triplet = (byte1 << 16) | (byte2 << 8) | byte3;\n\n      for (let j = 0; (j < 4) && (i + j * 0.75 < sigBytes); j += 1) {\n        base64Chars.push(map.charAt((triplet >>> (6 * (3 - j))) & 0x3f));\n      }\n    }\n\n    // Add padding\n    const paddingChar = map.charAt(64);\n    if (paddingChar) {\n      while (base64Chars.length % 4) {\n        base64Chars.push(paddingChar);\n      }\n    }\n\n    return base64Chars.join('');\n  },\n\n  /**\n   * Converts a Base64 string to a word array.\n   *\n   * @param {string} base64Str The Base64 string.\n   *\n   * @return {WordArray} The word array.\n   *\n   * @static\n   *\n   * @example\n   *\n   *     const wordArray = CryptoJS.enc.Base64.parse(base64String);\n   */\n  parse(base64Str) {\n    // Shortcuts\n    let base64StrLength = base64Str.length;\n    const map = this._map;\n    let reverseMap = this._reverseMap;\n\n    if (!reverseMap) {\n      this._reverseMap = [];\n      reverseMap = this._reverseMap;\n      for (let j = 0; j < map.length; j += 1) {\n        reverseMap[map.charCodeAt(j)] = j;\n      }\n    }\n\n    // Ignore padding\n    const paddingChar = map.charAt(64);\n    if (paddingChar) {\n      const paddingIndex = base64Str.indexOf(paddingChar);\n      if (paddingIndex !== -1) {\n        base64StrLength = paddingIndex;\n      }\n    }\n\n    // Convert\n    return parseLoop(base64Str, base64StrLength, reverseMap);\n  },\n\n  _map: 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=',\n};\n","import {\n  Base,\n  WordArray,\n} from './core.js';\nimport { MD5Algo } from './md5.js';\n\n/**\n * This key derivation function is meant to conform with EVP_BytesToKey.\n * www.openssl.org/docs/crypto/EVP_BytesToKey.html\n */\nexport class EvpKDFAlgo extends Base {\n  /**\n   * Initializes a newly created key derivation function.\n   *\n   * @param {Object} cfg (Optional) The configuration options to use for the derivation.\n   *\n   * @example\n   *\n   *     const kdf = CryptoJS.algo.EvpKDF.create();\n   *     const kdf = CryptoJS.algo.EvpKDF.create({ keySize: 8 });\n   *     const kdf = CryptoJS.algo.EvpKDF.create({ keySize: 8, iterations: 1000 });\n   */\n  constructor(cfg) {\n    super();\n\n    /**\n     * Configuration options.\n     *\n     * @property {number} keySize The key size in words to generate. Default: 4 (128 bits)\n     * @property {Hasher} hasher The hash algorithm to use. Default: MD5\n     * @property {number} iterations The number of iterations to perform. Default: 1\n     */\n    this.cfg = Object.assign(\n      new Base(),\n      {\n        keySize: 128 / 32,\n        hasher: MD5Algo,\n        iterations: 1,\n      },\n      cfg,\n    );\n  }\n\n  /**\n   * Derives a key from a password.\n   *\n   * @param {WordArray|string} password The password.\n   * @param {WordArray|string} salt A salt.\n   *\n   * @return {WordArray} The derived key.\n   *\n   * @example\n   *\n   *     const key = kdf.compute(password, salt);\n   */\n  compute(password, salt) {\n    let block;\n\n    // Shortcut\n    const { cfg } = this;\n\n    // Init hasher\n    const hasher = cfg.hasher.create();\n\n    // Initial values\n    const derivedKey = WordArray.create();\n\n    // Shortcuts\n    const derivedKeyWords = derivedKey.words;\n    const { keySize, iterations } = cfg;\n\n    // Generate key\n    while (derivedKeyWords.length < keySize) {\n      if (block) {\n        hasher.update(block);\n      }\n      block = hasher.update(password).finalize(salt);\n      hasher.reset();\n\n      // Iterations\n      for (let i = 1; i < iterations; i += 1) {\n        block = hasher.finalize(block);\n        hasher.reset();\n      }\n\n      derivedKey.concat(block);\n    }\n    derivedKey.sigBytes = keySize * 4;\n\n    return derivedKey;\n  }\n}\n\n/**\n * Derives a key from a password.\n *\n * @param {WordArray|string} password The password.\n * @param {WordArray|string} salt A salt.\n * @param {Object} cfg (Optional) The configuration options to use for this computation.\n *\n * @return {WordArray} The derived key.\n *\n * @static\n *\n * @example\n *\n *     var key = CryptoJS.EvpKDF(password, salt);\n *     var key = CryptoJS.EvpKDF(password, salt, { keySize: 8 });\n *     var key = CryptoJS.EvpKDF(password, salt, { keySize: 8, iterations: 1000 });\n */\nexport const EvpKDF = (password, salt, cfg) => EvpKDFAlgo.create(cfg).compute(password, salt);\n","/* eslint-disable no-use-before-define */\n\nimport {\n  Base,\n  WordArray,\n  BufferedBlockAlgorithm,\n} from './core.js';\nimport { Base64 } from './enc-base64.js';\nimport { EvpKDFAlgo } from './evpkdf.js';\n\n/**\n * Abstract base cipher template.\n *\n * @property {number} keySize This cipher's key size. Default: 4 (128 bits)\n * @property {number} ivSize This cipher's IV size. Default: 4 (128 bits)\n * @property {number} _ENC_XFORM_MODE A constant representing encryption mode.\n * @property {number} _DEC_XFORM_MODE A constant representing decryption mode.\n */\nexport class Cipher extends BufferedBlockAlgorithm {\n  /**\n   * Initializes a newly created cipher.\n   *\n   * @param {number} xformMode Either the encryption or decryption transormation mode constant.\n   * @param {WordArray} key The key.\n   * @param {Object} cfg (Optional) The configuration options to use for this operation.\n   *\n   * @example\n   *\n   *     const cipher = CryptoJS.algo.AES.create(\n   *       CryptoJS.algo.AES._ENC_XFORM_MODE, keyWordArray, { iv: ivWordArray }\n   *     );\n   */\n  constructor(xformMode, key, cfg) {\n    super();\n\n    /**\n     * Configuration options.\n     *\n     * @property {WordArray} iv The IV to use for this operation.\n     */\n    this.cfg = Object.assign(new Base(), cfg);\n\n    // Store transform mode and key\n    this._xformMode = xformMode;\n    this._key = key;\n\n    // Set initial values\n    this.reset();\n  }\n\n  /**\n   * Creates this cipher in encryption mode.\n   *\n   * @param {WordArray} key The key.\n   * @param {Object} cfg (Optional) The configuration options to use for this operation.\n   *\n   * @return {Cipher} A cipher instance.\n   *\n   * @static\n   *\n   * @example\n   *\n   *     const cipher = CryptoJS.algo.AES.createEncryptor(keyWordArray, { iv: ivWordArray });\n   */\n  static createEncryptor(key, cfg) {\n    return this.create(this._ENC_XFORM_MODE, key, cfg);\n  }\n\n  /**\n   * Creates this cipher in decryption mode.\n   *\n   * @param {WordArray} key The key.\n   * @param {Object} cfg (Optional) The configuration options to use for this operation.\n   *\n   * @return {Cipher} A cipher instance.\n   *\n   * @static\n   *\n   * @example\n   *\n   *     const cipher = CryptoJS.algo.AES.createDecryptor(keyWordArray, { iv: ivWordArray });\n   */\n  static createDecryptor(key, cfg) {\n    return this.create(this._DEC_XFORM_MODE, key, cfg);\n  }\n\n  /**\n   * Creates shortcut functions to a cipher's object interface.\n   *\n   * @param {Cipher} cipher The cipher to create a helper for.\n   *\n   * @return {Object} An object with encrypt and decrypt shortcut functions.\n   *\n   * @static\n   *\n   * @example\n   *\n   *     const AES = CryptoJS.lib.Cipher._createHelper(CryptoJS.algo.AES);\n   */\n  static _createHelper(SubCipher) {\n    const selectCipherStrategy = (key) => {\n      if (typeof key === 'string') {\n        return PasswordBasedCipher;\n      }\n      return SerializableCipher;\n    };\n\n    return {\n      encrypt(message, key, cfg) {\n        return selectCipherStrategy(key).encrypt(SubCipher, message, key, cfg);\n      },\n\n      decrypt(ciphertext, key, cfg) {\n        return selectCipherStrategy(key).decrypt(SubCipher, ciphertext, key, cfg);\n      },\n    };\n  }\n\n  /**\n   * Resets this cipher to its initial state.\n   *\n   * @example\n   *\n   *     cipher.reset();\n   */\n  reset() {\n    // Reset data buffer\n    super.reset.call(this);\n\n    // Perform concrete-cipher logic\n    this._doReset();\n  }\n\n  /**\n   * Adds data to be encrypted or decrypted.\n   *\n   * @param {WordArray|string} dataUpdate The data to encrypt or decrypt.\n   *\n   * @return {WordArray} The data after processing.\n   *\n   * @example\n   *\n   *     const encrypted = cipher.process('data');\n   *     const encrypted = cipher.process(wordArray);\n   */\n  process(dataUpdate) {\n    // Append\n    this._append(dataUpdate);\n\n    // Process available blocks\n    return this._process();\n  }\n\n  /**\n   * Finalizes the encryption or decryption process.\n   * Note that the finalize operation is effectively a destructive, read-once operation.\n   *\n   * @param {WordArray|string} dataUpdate The final data to encrypt or decrypt.\n   *\n   * @return {WordArray} The data after final processing.\n   *\n   * @example\n   *\n   *     const encrypted = cipher.finalize();\n   *     const encrypted = cipher.finalize('data');\n   *     const encrypted = cipher.finalize(wordArray);\n   */\n  finalize(dataUpdate) {\n    // Final data update\n    if (dataUpdate) {\n      this._append(dataUpdate);\n    }\n\n    // Perform concrete-cipher logic\n    const finalProcessedData = this._doFinalize();\n\n    return finalProcessedData;\n  }\n}\nCipher._ENC_XFORM_MODE = 1;\nCipher._DEC_XFORM_MODE = 2;\nCipher.keySize = 128 / 32;\nCipher.ivSize = 128 / 32;\n\n/**\n * Abstract base stream cipher template.\n *\n * @property {number} blockSize\n *\n *     The number of 32-bit words this cipher operates on. Default: 1 (32 bits)\n */\nexport class StreamCipher extends Cipher {\n  constructor(...args) {\n    super(...args);\n\n    this.blockSize = 1;\n  }\n\n  _doFinalize() {\n    // Process partial blocks\n    const finalProcessedBlocks = this._process(!!'flush');\n\n    return finalProcessedBlocks;\n  }\n}\n\n/**\n * Abstract base block cipher mode template.\n */\nexport class BlockCipherMode extends Base {\n  /**\n   * Initializes a newly created mode.\n   *\n   * @param {Cipher} cipher A block cipher instance.\n   * @param {Array} iv The IV words.\n   *\n   * @example\n   *\n   *     const mode = CryptoJS.mode.CBC.Encryptor.create(cipher, iv.words);\n   */\n  constructor(cipher, iv) {\n    super();\n\n    this._cipher = cipher;\n    this._iv = iv;\n  }\n\n  /**\n   * Creates this mode for encryption.\n   *\n   * @param {Cipher} cipher A block cipher instance.\n   * @param {Array} iv The IV words.\n   *\n   * @static\n   *\n   * @example\n   *\n   *     const mode = CryptoJS.mode.CBC.createEncryptor(cipher, iv.words);\n   */\n  static createEncryptor(cipher, iv) {\n    return this.Encryptor.create(cipher, iv);\n  }\n\n  /**\n   * Creates this mode for decryption.\n   *\n   * @param {Cipher} cipher A block cipher instance.\n   * @param {Array} iv The IV words.\n   *\n   * @static\n   *\n   * @example\n   *\n   *     const mode = CryptoJS.mode.CBC.createDecryptor(cipher, iv.words);\n   */\n  static createDecryptor(cipher, iv) {\n    return this.Decryptor.create(cipher, iv);\n  }\n}\n\nfunction xorBlock(words, offset, blockSize) {\n  const _words = words;\n  let block;\n\n  // Shortcut\n  const iv = this._iv;\n\n  // Choose mixing block\n  if (iv) {\n    block = iv;\n\n    // Remove IV for subsequent blocks\n    this._iv = undefined;\n  } else {\n    block = this._prevBlock;\n  }\n\n  // XOR blocks\n  for (let i = 0; i < blockSize; i += 1) {\n    _words[offset + i] ^= block[i];\n  }\n}\n\n/**\n * Cipher Block Chaining mode.\n */\n\n/**\n * Abstract base CBC mode.\n */\nexport class CBC extends BlockCipherMode {\n}\n/**\n * CBC encryptor.\n */\nCBC.Encryptor = class extends CBC {\n  /**\n   * Processes the data block at offset.\n   *\n   * @param {Array} words The data words to operate on.\n   * @param {number} offset The offset where the block starts.\n   *\n   * @example\n   *\n   *     mode.processBlock(data.words, offset);\n   */\n  processBlock(words, offset) {\n    // Shortcuts\n    const cipher = this._cipher;\n    const { blockSize } = cipher;\n\n    // XOR and encrypt\n    xorBlock.call(this, words, offset, blockSize);\n    cipher.encryptBlock(words, offset);\n\n    // Remember this block to use with next block\n    this._prevBlock = words.slice(offset, offset + blockSize);\n  }\n};\n/**\n * CBC decryptor.\n */\nCBC.Decryptor = class extends CBC {\n  /**\n   * Processes the data block at offset.\n   *\n   * @param {Array} words The data words to operate on.\n   * @param {number} offset The offset where the block starts.\n   *\n   * @example\n   *\n   *     mode.processBlock(data.words, offset);\n   */\n  processBlock(words, offset) {\n    // Shortcuts\n    const cipher = this._cipher;\n    const { blockSize } = cipher;\n\n    // Remember this block to use with next block\n    const thisBlock = words.slice(offset, offset + blockSize);\n\n    // Decrypt and XOR\n    cipher.decryptBlock(words, offset);\n    xorBlock.call(this, words, offset, blockSize);\n\n    // This block becomes the previous block\n    this._prevBlock = thisBlock;\n  }\n};\n\n/**\n * PKCS #5/7 padding strategy.\n */\nexport const Pkcs7 = {\n  /**\n   * Pads data using the algorithm defined in PKCS #5/7.\n   *\n   * @param {WordArray} data The data to pad.\n   * @param {number} blockSize The multiple that the data should be padded to.\n   *\n   * @static\n   *\n   * @example\n   *\n   *     CryptoJS.pad.Pkcs7.pad(wordArray, 4);\n   */\n  pad(data, blockSize) {\n    // Shortcut\n    const blockSizeBytes = blockSize * 4;\n\n    // Count padding bytes\n    const nPaddingBytes = blockSizeBytes - (data.sigBytes % blockSizeBytes);\n\n    // Create padding word\n    const paddingWord = (nPaddingBytes << 24)\n      | (nPaddingBytes << 16)\n      | (nPaddingBytes << 8)\n      | nPaddingBytes;\n\n    // Create padding\n    const paddingWords = [];\n    for (let i = 0; i < nPaddingBytes; i += 4) {\n      paddingWords.push(paddingWord);\n    }\n    const padding = WordArray.create(paddingWords, nPaddingBytes);\n\n    // Add padding\n    data.concat(padding);\n  },\n\n  /**\n   * Unpads data that had been padded using the algorithm defined in PKCS #5/7.\n   *\n   * @param {WordArray} data The data to unpad.\n   *\n   * @static\n   *\n   * @example\n   *\n   *     CryptoJS.pad.Pkcs7.unpad(wordArray);\n   */\n  unpad(data) {\n    const _data = data;\n\n    // Get number of padding bytes from last byte\n    const nPaddingBytes = _data.words[(_data.sigBytes - 1) >>> 2] & 0xff;\n\n    // Remove padding\n    _data.sigBytes -= nPaddingBytes;\n  },\n};\n\n/**\n * Abstract base block cipher template.\n *\n * @property {number} blockSize\n *\n *    The number of 32-bit words this cipher operates on. Default: 4 (128 bits)\n */\nexport class BlockCipher extends Cipher {\n  constructor(xformMode, key, cfg) {\n    /**\n     * Configuration options.\n     *\n     * @property {Mode} mode The block mode to use. Default: CBC\n     * @property {Padding} padding The padding strategy to use. Default: Pkcs7\n     */\n    super(xformMode, key, Object.assign(\n      {\n        mode: CBC,\n        padding: Pkcs7,\n      },\n      cfg,\n    ));\n\n    this.blockSize = 128 / 32;\n  }\n\n  reset() {\n    let modeCreator;\n\n    // Reset cipher\n    super.reset.call(this);\n\n    // Shortcuts\n    const { cfg } = this;\n    const { iv, mode } = cfg;\n\n    // Reset block mode\n    if (this._xformMode === this.constructor._ENC_XFORM_MODE) {\n      modeCreator = mode.createEncryptor;\n    } else /* if (this._xformMode == this._DEC_XFORM_MODE) */ {\n      modeCreator = mode.createDecryptor;\n      // Keep at least one block in the buffer for unpadding\n      this._minBufferSize = 1;\n    }\n\n    this._mode = modeCreator.call(mode, this, iv && iv.words);\n    this._mode.__creator = modeCreator;\n  }\n\n  _doProcessBlock(words, offset) {\n    this._mode.processBlock(words, offset);\n  }\n\n  _doFinalize() {\n    let finalProcessedBlocks;\n\n    // Shortcut\n    const { padding } = this.cfg;\n\n    // Finalize\n    if (this._xformMode === this.constructor._ENC_XFORM_MODE) {\n      // Pad data\n      padding.pad(this._data, this.blockSize);\n\n      // Process final blocks\n      finalProcessedBlocks = this._process(!!'flush');\n    } else /* if (this._xformMode == this._DEC_XFORM_MODE) */ {\n      // Process final blocks\n      finalProcessedBlocks = this._process(!!'flush');\n\n      // Unpad data\n      padding.unpad(finalProcessedBlocks);\n    }\n\n    return finalProcessedBlocks;\n  }\n}\n\n/**\n * A collection of cipher parameters.\n *\n * @property {WordArray} ciphertext The raw ciphertext.\n * @property {WordArray} key The key to this ciphertext.\n * @property {WordArray} iv The IV used in the ciphering operation.\n * @property {WordArray} salt The salt used with a key derivation function.\n * @property {Cipher} algorithm The cipher algorithm.\n * @property {Mode} mode The block mode used in the ciphering operation.\n * @property {Padding} padding The padding scheme used in the ciphering operation.\n * @property {number} blockSize The block size of the cipher.\n * @property {Format} formatter\n *    The default formatting strategy to convert this cipher params object to a string.\n */\nexport class CipherParams extends Base {\n  /**\n   * Initializes a newly created cipher params object.\n   *\n   * @param {Object} cipherParams An object with any of the possible cipher parameters.\n   *\n   * @example\n   *\n   *     var cipherParams = CryptoJS.lib.CipherParams.create({\n   *         ciphertext: ciphertextWordArray,\n   *         key: keyWordArray,\n   *         iv: ivWordArray,\n   *         salt: saltWordArray,\n   *         algorithm: CryptoJS.algo.AES,\n   *         mode: CryptoJS.mode.CBC,\n   *         padding: CryptoJS.pad.PKCS7,\n   *         blockSize: 4,\n   *         formatter: CryptoJS.format.OpenSSL\n   *     });\n   */\n  constructor(cipherParams) {\n    super();\n\n    this.mixIn(cipherParams);\n  }\n\n  /**\n   * Converts this cipher params object to a string.\n   *\n   * @param {Format} formatter (Optional) The formatting strategy to use.\n   *\n   * @return {string} The stringified cipher params.\n   *\n   * @throws Error If neither the formatter nor the default formatter is set.\n   *\n   * @example\n   *\n   *     var string = cipherParams + '';\n   *     var string = cipherParams.toString();\n   *     var string = cipherParams.toString(CryptoJS.format.OpenSSL);\n   */\n  toString(formatter) {\n    return (formatter || this.formatter).stringify(this);\n  }\n}\n\n/**\n * OpenSSL formatting strategy.\n */\nexport const OpenSSLFormatter = {\n  /**\n   * Converts a cipher params object to an OpenSSL-compatible string.\n   *\n   * @param {CipherParams} cipherParams The cipher params object.\n   *\n   * @return {string} The OpenSSL-compatible string.\n   *\n   * @static\n   *\n   * @example\n   *\n   *     var openSSLString = CryptoJS.format.OpenSSL.stringify(cipherParams);\n   */\n  stringify(cipherParams) {\n    let wordArray;\n\n    // Shortcuts\n    const { ciphertext, salt } = cipherParams;\n\n    // Format\n    if (salt) {\n      wordArray = WordArray.create([0x53616c74, 0x65645f5f]).concat(salt).concat(ciphertext);\n    } else {\n      wordArray = ciphertext;\n    }\n\n    return wordArray.toString(Base64);\n  },\n\n  /**\n   * Converts an OpenSSL-compatible string to a cipher params object.\n   *\n   * @param {string} openSSLStr The OpenSSL-compatible string.\n   *\n   * @return {CipherParams} The cipher params object.\n   *\n   * @static\n   *\n   * @example\n   *\n   *     var cipherParams = CryptoJS.format.OpenSSL.parse(openSSLString);\n   */\n  parse(openSSLStr) {\n    let salt;\n\n    // Parse base64\n    const ciphertext = Base64.parse(openSSLStr);\n\n    // Shortcut\n    const ciphertextWords = ciphertext.words;\n\n    // Test for salt\n    if (ciphertextWords[0] === 0x53616c74 && ciphertextWords[1] === 0x65645f5f) {\n      // Extract salt\n      salt = WordArray.create(ciphertextWords.slice(2, 4));\n\n      // Remove salt from ciphertext\n      ciphertextWords.splice(0, 4);\n      ciphertext.sigBytes -= 16;\n    }\n\n    return CipherParams.create({ ciphertext, salt });\n  },\n};\n\n/**\n * A cipher wrapper that returns ciphertext as a serializable cipher params object.\n */\nexport class SerializableCipher extends Base {\n  /**\n   * Encrypts a message.\n   *\n   * @param {Cipher} cipher The cipher algorithm to use.\n   * @param {WordArray|string} message The message to encrypt.\n   * @param {WordArray} key The key.\n   * @param {Object} cfg (Optional) The configuration options to use for this operation.\n   *\n   * @return {CipherParams} A cipher params object.\n   *\n   * @static\n   *\n   * @example\n   *\n   *     var ciphertextParams = CryptoJS.lib.SerializableCipher\n   *       .encrypt(CryptoJS.algo.AES, message, key);\n   *     var ciphertextParams = CryptoJS.lib.SerializableCipher\n   *       .encrypt(CryptoJS.algo.AES, message, key, { iv: iv });\n   *     var ciphertextParams = CryptoJS.lib.SerializableCipher\n   *       .encrypt(CryptoJS.algo.AES, message, key, { iv: iv, format: CryptoJS.format.OpenSSL });\n   */\n  static encrypt(cipher, message, key, cfg) {\n    // Apply config defaults\n    const _cfg = Object.assign(new Base(), this.cfg, cfg);\n\n    // Encrypt\n    const encryptor = cipher.createEncryptor(key, _cfg);\n    const ciphertext = encryptor.finalize(message);\n\n    // Shortcut\n    const cipherCfg = encryptor.cfg;\n\n    // Create and return serializable cipher params\n    return CipherParams.create({\n      ciphertext,\n      key,\n      iv: cipherCfg.iv,\n      algorithm: cipher,\n      mode: cipherCfg.mode,\n      padding: cipherCfg.padding,\n      blockSize: encryptor.blockSize,\n      formatter: _cfg.format,\n    });\n  }\n\n  /**\n   * Decrypts serialized ciphertext.\n   *\n   * @param {Cipher} cipher The cipher algorithm to use.\n   * @param {CipherParams|string} ciphertext The ciphertext to decrypt.\n   * @param {WordArray} key The key.\n   * @param {Object} cfg (Optional) The configuration options to use for this operation.\n   *\n   * @return {WordArray} The plaintext.\n   *\n   * @static\n   *\n   * @example\n   *\n   *     var plaintext = CryptoJS.lib.SerializableCipher\n   *       .decrypt(CryptoJS.algo.AES, formattedCiphertext, key,\n   *         { iv: iv, format: CryptoJS.format.OpenSSL });\n   *     var plaintext = CryptoJS.lib.SerializableCipher\n   *       .decrypt(CryptoJS.algo.AES, ciphertextParams, key,\n   *         { iv: iv, format: CryptoJS.format.OpenSSL });\n   */\n  static decrypt(cipher, ciphertext, key, cfg) {\n    let _ciphertext = ciphertext;\n\n    // Apply config defaults\n    const _cfg = Object.assign(new Base(), this.cfg, cfg);\n\n    // Convert string to CipherParams\n    _ciphertext = this._parse(_ciphertext, _cfg.format);\n\n    // Decrypt\n    const plaintext = cipher.createDecryptor(key, _cfg).finalize(_ciphertext.ciphertext);\n\n    return plaintext;\n  }\n\n  /**\n   * Converts serialized ciphertext to CipherParams,\n   * else assumed CipherParams already and returns ciphertext unchanged.\n   *\n   * @param {CipherParams|string} ciphertext The ciphertext.\n   * @param {Formatter} format The formatting strategy to use to parse serialized ciphertext.\n   *\n   * @return {CipherParams} The unserialized ciphertext.\n   *\n   * @static\n   *\n   * @example\n   *\n   *     var ciphertextParams = CryptoJS.lib.SerializableCipher\n   *       ._parse(ciphertextStringOrParams, format);\n   */\n  static _parse(ciphertext, format) {\n    if (typeof ciphertext === 'string') {\n      return format.parse(ciphertext, this);\n    }\n    return ciphertext;\n  }\n}\n/**\n * Configuration options.\n *\n * @property {Formatter} format\n *\n *    The formatting strategy to convert cipher param objects to and from a string.\n *    Default: OpenSSL\n */\nSerializableCipher.cfg = Object.assign(\n  new Base(),\n  { format: OpenSSLFormatter },\n);\n\n/**\n * OpenSSL key derivation function.\n */\nexport const OpenSSLKdf = {\n  /**\n   * Derives a key and IV from a password.\n   *\n   * @param {string} password The password to derive from.\n   * @param {number} keySize The size in words of the key to generate.\n   * @param {number} ivSize The size in words of the IV to generate.\n   * @param {WordArray|string} salt\n   *     (Optional) A 64-bit salt to use. If omitted, a salt will be generated randomly.\n   *\n   * @return {CipherParams} A cipher params object with the key, IV, and salt.\n   *\n   * @static\n   *\n   * @example\n   *\n   *     var derivedParams = CryptoJS.kdf.OpenSSL.execute('Password', 256/32, 128/32);\n   *     var derivedParams = CryptoJS.kdf.OpenSSL.execute('Password', 256/32, 128/32, 'saltsalt');\n   */\n  execute(password, keySize, ivSize, salt) {\n    let _salt = salt;\n\n    // Generate random salt\n    if (!_salt) {\n      _salt = WordArray.random(64 / 8);\n    }\n\n    // Derive key and IV\n    const key = EvpKDFAlgo.create({ keySize: keySize + ivSize }).compute(password, _salt);\n\n    // Separate key and IV\n    const iv = WordArray.create(key.words.slice(keySize), ivSize * 4);\n    key.sigBytes = keySize * 4;\n\n    // Return params\n    return CipherParams.create({ key, iv, salt: _salt });\n  },\n};\n\n/**\n * A serializable cipher wrapper that derives the key from a password,\n * and returns ciphertext as a serializable cipher params object.\n */\nexport class PasswordBasedCipher extends SerializableCipher {\n  /**\n   * Encrypts a message using a password.\n   *\n   * @param {Cipher} cipher The cipher algorithm to use.\n   * @param {WordArray|string} message The message to encrypt.\n   * @param {string} password The password.\n   * @param {Object} cfg (Optional) The configuration options to use for this operation.\n   *\n   * @return {CipherParams} A cipher params object.\n   *\n   * @static\n   *\n   * @example\n   *\n   *     var ciphertextParams = CryptoJS.lib.PasswordBasedCipher\n   *       .encrypt(CryptoJS.algo.AES, message, 'password');\n   *     var ciphertextParams = CryptoJS.lib.PasswordBasedCipher\n   *       .encrypt(CryptoJS.algo.AES, message, 'password', { format: CryptoJS.format.OpenSSL });\n   */\n  static encrypt(cipher, message, password, cfg) {\n    // Apply config defaults\n    const _cfg = Object.assign(new Base(), this.cfg, cfg);\n\n    // Derive key and other params\n    const derivedParams = _cfg.kdf.execute(password, cipher.keySize, cipher.ivSize);\n\n    // Add IV to config\n    _cfg.iv = derivedParams.iv;\n\n    // Encrypt\n    const ciphertext = SerializableCipher.encrypt\n      .call(this, cipher, message, derivedParams.key, _cfg);\n\n    // Mix in derived params\n    ciphertext.mixIn(derivedParams);\n\n    return ciphertext;\n  }\n\n  /**\n   * Decrypts serialized ciphertext using a password.\n   *\n   * @param {Cipher} cipher The cipher algorithm to use.\n   * @param {CipherParams|string} ciphertext The ciphertext to decrypt.\n   * @param {string} password The password.\n   * @param {Object} cfg (Optional) The configuration options to use for this operation.\n   *\n   * @return {WordArray} The plaintext.\n   *\n   * @static\n   *\n   * @example\n   *\n   *     var plaintext = CryptoJS.lib.PasswordBasedCipher\n   *       .decrypt(CryptoJS.algo.AES, formattedCiphertext, 'password',\n   *         { format: CryptoJS.format.OpenSSL });\n   *     var plaintext = CryptoJS.lib.PasswordBasedCipher\n   *       .decrypt(CryptoJS.algo.AES, ciphertextParams, 'password',\n   *         { format: CryptoJS.format.OpenSSL });\n   */\n  static decrypt(cipher, ciphertext, password, cfg) {\n    let _ciphertext = ciphertext;\n\n    // Apply config defaults\n    const _cfg = Object.assign(new Base(), this.cfg, cfg);\n\n    // Convert string to CipherParams\n    _ciphertext = this._parse(_ciphertext, _cfg.format);\n\n    // Derive key and other params\n    const derivedParams = _cfg.kdf\n      .execute(password, cipher.keySize, cipher.ivSize, _ciphertext.salt);\n\n    // Add IV to config\n    _cfg.iv = derivedParams.iv;\n\n    // Decrypt\n    const plaintext = SerializableCipher.decrypt\n      .call(this, cipher, _ciphertext, derivedParams.key, _cfg);\n\n    return plaintext;\n  }\n}\n/**\n * Configuration options.\n *\n * @property {KDF} kdf\n *     The key derivation function to use to generate a key and IV from a password.\n *     Default: OpenSSL\n */\nPasswordBasedCipher.cfg = Object.assign(SerializableCipher.cfg, { kdf: OpenSSLKdf });\n","import {\n  BlockCipher,\n} from './cipher-core.js';\n\n// Lookup tables\nconst _SBOX = [];\nconst INV_SBOX = [];\nconst _SUB_MIX_0 = [];\nconst _SUB_MIX_1 = [];\nconst _SUB_MIX_2 = [];\nconst _SUB_MIX_3 = [];\nconst INV_SUB_MIX_0 = [];\nconst INV_SUB_MIX_1 = [];\nconst INV_SUB_MIX_2 = [];\nconst INV_SUB_MIX_3 = [];\n\n// Compute lookup tables\n\n// Compute double table\nconst d = [];\nfor (let i = 0; i < 256; i += 1) {\n  if (i < 128) {\n    d[i] = i << 1;\n  } else {\n    d[i] = (i << 1) ^ 0x11b;\n  }\n}\n\n// Walk GF(2^8)\nlet x = 0;\nlet xi = 0;\nfor (let i = 0; i < 256; i += 1) {\n  // Compute sbox\n  let sx = xi ^ (xi << 1) ^ (xi << 2) ^ (xi << 3) ^ (xi << 4);\n  sx = (sx >>> 8) ^ (sx & 0xff) ^ 0x63;\n  _SBOX[x] = sx;\n  INV_SBOX[sx] = x;\n\n  // Compute multiplication\n  const x2 = d[x];\n  const x4 = d[x2];\n  const x8 = d[x4];\n\n  // Compute sub bytes, mix columns tables\n  let t = (d[sx] * 0x101) ^ (sx * 0x1010100);\n  _SUB_MIX_0[x] = (t << 24) | (t >>> 8);\n  _SUB_MIX_1[x] = (t << 16) | (t >>> 16);\n  _SUB_MIX_2[x] = (t << 8) | (t >>> 24);\n  _SUB_MIX_3[x] = t;\n\n  // Compute inv sub bytes, inv mix columns tables\n  t = (x8 * 0x1010101) ^ (x4 * 0x10001) ^ (x2 * 0x101) ^ (x * 0x1010100);\n  INV_SUB_MIX_0[sx] = (t << 24) | (t >>> 8);\n  INV_SUB_MIX_1[sx] = (t << 16) | (t >>> 16);\n  INV_SUB_MIX_2[sx] = (t << 8) | (t >>> 24);\n  INV_SUB_MIX_3[sx] = t;\n\n  // Compute next counter\n  if (!x) {\n    xi = 1;\n    x = xi;\n  } else {\n    x = x2 ^ d[d[d[x8 ^ x2]]];\n    xi ^= d[d[xi]];\n  }\n}\n\n// Precomputed Rcon lookup\nconst RCON = [0x00, 0x01, 0x02, 0x04, 0x08, 0x10, 0x20, 0x40, 0x80, 0x1b, 0x36];\n\n/**\n * AES block cipher algorithm.\n */\nexport class AESAlgo extends BlockCipher {\n  _doReset() {\n    let t;\n\n    // Skip reset of nRounds has been set before and key did not change\n    if (this._nRounds && this._keyPriorReset === this._key) {\n      return;\n    }\n\n    // Shortcuts\n    this._keyPriorReset = this._key;\n    const key = this._keyPriorReset;\n    const keyWords = key.words;\n    const keySize = key.sigBytes / 4;\n\n    // Compute number of rounds\n    this._nRounds = keySize + 6;\n    const nRounds = this._nRounds;\n\n    // Compute number of key schedule rows\n    const ksRows = (nRounds + 1) * 4;\n\n    // Compute key schedule\n    this._keySchedule = [];\n    const keySchedule = this._keySchedule;\n    for (let ksRow = 0; ksRow < ksRows; ksRow += 1) {\n      if (ksRow < keySize) {\n        keySchedule[ksRow] = keyWords[ksRow];\n      } else {\n        t = keySchedule[ksRow - 1];\n\n        if (!(ksRow % keySize)) {\n          // Rot word\n          t = (t << 8) | (t >>> 24);\n\n          // Sub word\n          t = (_SBOX[t >>> 24] << 24)\n            | (_SBOX[(t >>> 16) & 0xff] << 16)\n            | (_SBOX[(t >>> 8) & 0xff] << 8)\n            | _SBOX[t & 0xff];\n\n          // Mix Rcon\n          t ^= RCON[(ksRow / keySize) | 0] << 24;\n        } else if (keySize > 6 && ksRow % keySize === 4) {\n          // Sub word\n          t = (_SBOX[t >>> 24] << 24)\n            | (_SBOX[(t >>> 16) & 0xff] << 16)\n            | (_SBOX[(t >>> 8) & 0xff] << 8)\n            | _SBOX[t & 0xff];\n        }\n\n        keySchedule[ksRow] = keySchedule[ksRow - keySize] ^ t;\n      }\n    }\n\n    // Compute inv key schedule\n    this._invKeySchedule = [];\n    const invKeySchedule = this._invKeySchedule;\n    for (let invKsRow = 0; invKsRow < ksRows; invKsRow += 1) {\n      const ksRow = ksRows - invKsRow;\n\n      if (invKsRow % 4) {\n        t = keySchedule[ksRow];\n      } else {\n        t = keySchedule[ksRow - 4];\n      }\n\n      if (invKsRow < 4 || ksRow <= 4) {\n        invKeySchedule[invKsRow] = t;\n      } else {\n        invKeySchedule[invKsRow] = INV_SUB_MIX_0[_SBOX[t >>> 24]]\n          ^ INV_SUB_MIX_1[_SBOX[(t >>> 16) & 0xff]]\n          ^ INV_SUB_MIX_2[_SBOX[(t >>> 8) & 0xff]]\n          ^ INV_SUB_MIX_3[_SBOX[t & 0xff]];\n      }\n    }\n  }\n\n  encryptBlock(M, offset) {\n    this._doCryptBlock(\n      M, offset, this._keySchedule, _SUB_MIX_0, _SUB_MIX_1, _SUB_MIX_2, _SUB_MIX_3, _SBOX,\n    );\n  }\n\n  decryptBlock(M, offset) {\n    const _M = M;\n\n    // Swap 2nd and 4th rows\n    let t = _M[offset + 1];\n    _M[offset + 1] = _M[offset + 3];\n    _M[offset + 3] = t;\n\n    this._doCryptBlock(\n      _M,\n      offset,\n      this._invKeySchedule,\n      INV_SUB_MIX_0,\n      INV_SUB_MIX_1,\n      INV_SUB_MIX_2,\n      INV_SUB_MIX_3,\n      INV_SBOX,\n    );\n\n    // Inv swap 2nd and 4th rows\n    t = _M[offset + 1];\n    _M[offset + 1] = _M[offset + 3];\n    _M[offset + 3] = t;\n  }\n\n  _doCryptBlock(M, offset, keySchedule, SUB_MIX_0, SUB_MIX_1, SUB_MIX_2, SUB_MIX_3, SBOX) {\n    const _M = M;\n\n    // Shortcut\n    const nRounds = this._nRounds;\n\n    // Get input, add round key\n    let s0 = _M[offset] ^ keySchedule[0];\n    let s1 = _M[offset + 1] ^ keySchedule[1];\n    let s2 = _M[offset + 2] ^ keySchedule[2];\n    let s3 = _M[offset + 3] ^ keySchedule[3];\n\n    // Key schedule row counter\n    let ksRow = 4;\n\n    // Rounds\n    for (let round = 1; round < nRounds; round += 1) {\n      // Shift rows, sub bytes, mix columns, add round key\n      const t0 = SUB_MIX_0[s0 >>> 24]\n        ^ SUB_MIX_1[(s1 >>> 16) & 0xff]\n        ^ SUB_MIX_2[(s2 >>> 8) & 0xff]\n        ^ SUB_MIX_3[s3 & 0xff]\n        ^ keySchedule[ksRow];\n      ksRow += 1;\n      const t1 = SUB_MIX_0[s1 >>> 24]\n        ^ SUB_MIX_1[(s2 >>> 16) & 0xff]\n        ^ SUB_MIX_2[(s3 >>> 8) & 0xff]\n        ^ SUB_MIX_3[s0 & 0xff]\n        ^ keySchedule[ksRow];\n      ksRow += 1;\n      const t2 = SUB_MIX_0[s2 >>> 24]\n        ^ SUB_MIX_1[(s3 >>> 16) & 0xff]\n        ^ SUB_MIX_2[(s0 >>> 8) & 0xff]\n        ^ SUB_MIX_3[s1 & 0xff]\n        ^ keySchedule[ksRow];\n      ksRow += 1;\n      const t3 = SUB_MIX_0[s3 >>> 24]\n        ^ SUB_MIX_1[(s0 >>> 16) & 0xff]\n        ^ SUB_MIX_2[(s1 >>> 8) & 0xff]\n        ^ SUB_MIX_3[s2 & 0xff]\n        ^ keySchedule[ksRow];\n      ksRow += 1;\n\n      // Update state\n      s0 = t0;\n      s1 = t1;\n      s2 = t2;\n      s3 = t3;\n    }\n\n    // Shift rows, sub bytes, add round key\n    const t0 = (\n      (SBOX[s0 >>> 24] << 24)\n        | (SBOX[(s1 >>> 16) & 0xff] << 16)\n        | (SBOX[(s2 >>> 8) & 0xff] << 8)\n        | SBOX[s3 & 0xff]\n    ) ^ keySchedule[ksRow];\n    ksRow += 1;\n    const t1 = (\n      (SBOX[s1 >>> 24] << 24)\n        | (SBOX[(s2 >>> 16) & 0xff] << 16)\n        | (SBOX[(s3 >>> 8) & 0xff] << 8)\n        | SBOX[s0 & 0xff]\n    ) ^ keySchedule[ksRow];\n    ksRow += 1;\n    const t2 = (\n      (SBOX[s2 >>> 24] << 24)\n        | (SBOX[(s3 >>> 16) & 0xff] << 16)\n        | (SBOX[(s0 >>> 8) & 0xff] << 8)\n        | SBOX[s1 & 0xff]\n    ) ^ keySchedule[ksRow];\n    ksRow += 1;\n    const t3 = (\n      (SBOX[s3 >>> 24] << 24)\n        | (SBOX[(s0 >>> 16) & 0xff] << 16) | (SBOX[(s1 >>> 8) & 0xff] << 8) | SBOX[s2 & 0xff]\n    ) ^ keySchedule[ksRow];\n    ksRow += 1;\n\n    // Set output\n    _M[offset] = t0;\n    _M[offset + 1] = t1;\n    _M[offset + 2] = t2;\n    _M[offset + 3] = t3;\n  }\n}\nAESAlgo.keySize = 256 / 32;\n\n/**\n * Shortcut functions to the cipher's object interface.\n *\n * @example\n *\n *     var ciphertext = CryptoJS.AES.encrypt(message, key, cfg);\n *     var plaintext  = CryptoJS.AES.decrypt(ciphertext, key, cfg);\n */\nexport const AES = BlockCipher._createHelper(AESAlgo);\n","/**\n * Counter block mode.\n */\nimport {\n  BlockCipherMode,\n} from './cipher-core.js';\n\nexport class CTR extends BlockCipherMode {\n}\nCTR.Encryptor = class extends CTR {\n  processBlock(words, offset) {\n    const _words = words;\n\n    // Shortcuts\n    const cipher = this._cipher;\n    const { blockSize } = cipher;\n    const iv = this._iv;\n    let counter = this._counter;\n\n    // Generate keystream\n    if (iv) {\n      this._counter = iv.slice(0);\n      counter = this._counter;\n\n      // Remove IV for subsequent blocks\n      this._iv = undefined;\n    }\n    const keystream = counter.slice(0);\n    cipher.encryptBlock(keystream, 0);\n\n    // Increment counter\n    counter[blockSize - 1] = (counter[blockSize - 1] + 1) | 0;\n\n    // Encrypt\n    for (let i = 0; i < blockSize; i += 1) {\n      _words[offset + i] ^= keystream[i];\n    }\n  }\n};\nCTR.Decryptor = CTR.Encryptor;\n","/**\n * A noop padding strategy.\n */\nexport const NoPadding = {\n  pad() {\n  },\n\n  unpad() {\n  },\n};\n","import { WordArray, Hex } from 'crypto-es/lib/core'\nimport { CipherParams } from 'crypto-es/lib/cipher-core'\nimport { AES } from 'crypto-es/lib/aes'\nimport { CTR } from 'crypto-es/lib/mode-ctr'\nimport { NoPadding } from 'crypto-es/lib/pad-nopadding'\nimport { formatIV } from '../../utils'\nimport Buffer from '../buffer'\n\nconst Crypto = {\n\n  decryptWordArray: function (raw, key, iv) {\n    const realKey = Hex.parse(key)\n\n    const realIV = Hex.parse(formatIV(iv))\n    const message = WordArray.create(new Uint8Array(raw))\n    const decryptWord = AES.decrypt(\n      CipherParams.create({\n        ciphertext: message\n      }),\n      realKey,\n      {\n        iv: realIV,\n        mode: CTR,\n        padding: NoPadding\n      }\n    )\n    return Crypto.wordArrayToUint8Array(decryptWord)\n  },\n  wordArrayToUint8Array: function (wordArray) {\n    const l = wordArray.sigBytes\n    const words = wordArray.words\n    const result = new Uint8Array(l)\n    let i = 0\n    let j = 0\n    while (true) {\n      if (i === l) { break }\n      const w = words[j++]\n      result[i++] = (w & 0xff000000) >>> 24\n      if (i === l) { break }\n      result[i++] = (w & 0x00ff0000) >>> 16\n      if (i === l) { break }\n      result[i++] = (w & 0x0000ff00) >>> 8\n      if (i === l) { break }\n      result[i++] = (w & 0x000000ff)\n    }\n    return result\n  },\n\n  decoderAESCTRData (videoTrack, audioTrack, customDescryptHandler) {\n    if (videoTrack.videoSenc) {\n      const key = videoTrack.kidValue\n      const senc = videoTrack.videoSenc\n      videoTrack.samples.forEach((item, index) => {\n        const sencBox = senc[index]\n        let encodeWord = item.data\n        const encodeBuffers = []\n        const decodeBuffers = []\n        const iv = sencBox.InitializationVector\n        if (sencBox.subsamples && sencBox.subsamples.length) {\n          sencBox.subsamples.forEach(function (value) {\n            const len = value.BytesOfClearData + value.BytesOfProtectedData\n            const sampleData = encodeWord.slice(0, len)\n            encodeBuffers.push(sampleData.slice(0, value.BytesOfClearData))\n            decodeBuffers.push(sampleData.slice(value.BytesOfClearData))\n            encodeWord = encodeWord.slice(len)\n          })\n        } else {\n          const len = item.size\n          encodeBuffers.push(encodeWord.slice(0, 0))\n          decodeBuffers.push(encodeWord.slice(0, len))\n          encodeWord = encodeWord.slice(len)\n        }\n        const tempBuffer = new Buffer()\n        tempBuffer.write(...decodeBuffers)\n        let decrypted = customDescryptHandler ? customDescryptHandler(tempBuffer.buffer, key, iv) : Crypto.decryptWordArray(tempBuffer.buffer, key, iv)\n        const buffer = new Buffer()\n        encodeBuffers.forEach((clearDataBuf, i) => {\n          const protectedDataLen = decodeBuffers[i].length\n          const decodeProtectedData = decrypted.slice(0, protectedDataLen)\n          buffer.write(clearDataBuf)\n          buffer.write(decodeProtectedData)\n          decrypted = decrypted.slice(protectedDataLen)\n        })\n        videoTrack.samples[index].data = buffer.buffer\n      })\n    }\n\n    if (audioTrack.audioSenc) {\n      const key = audioTrack.kidValue\n      const senc = audioTrack.audioSenc\n      audioTrack.samples.forEach((item, index) => {\n        const sencBox = senc[index]\n        const dec = customDescryptHandler ? customDescryptHandler(item.data, key, sencBox.InitializationVector) : Crypto.decryptWordArray(item.data, key, sencBox.InitializationVector)\n        audioTrack.samples[index].data = dec\n      })\n    }\n  }\n}\n\nexport default Crypto\n","import { VideoTrack, AudioTrack, MetadataTrack, AudioSample, VideoSample } from '../model'\nimport { readBig32 } from '../utils'\nimport { MP4Parser } from './mp4-parser'\nimport { Logger } from './logger'\nimport Crypto from './crypto/crypto'\nconst NEW_ARRAY_MAX_CNT = 20\nexport class MP4Demuxer {\n  _videoSamples = []\n  _audioSamples = []\n  _lastRemainBuffer = []\n  _lastRemainBufferStartPos = 0\n\n  constructor (videoSegmnents, audioSegmnents, metadataTrack, options) {\n    this.videoTrack = new VideoTrack()\n    this.audioTrack = new AudioTrack()\n    this.metadataTrack = metadataTrack || new MetadataTrack()\n    this.log = new Logger('MP4Demuxer', options && options.openLog ? !options.openLog : true)\n\n    videoSegmnents && videoSegmnents.forEach(item => {\n      this._videoSamples.push(...item.frames)\n    })\n    audioSegmnents && audioSegmnents.forEach(item => {\n      this._audioSamples.push(...item.frames)\n    })\n  }\n\n  parseSamples (moov) {\n    if (!moov) {\n      throw new Error('moov is required')\n    }\n    if (!this.videoTrack.codec && !this.audioTrack.codec) {\n      MP4Parser.moovToTrack(moov, this.videoTrack, this.audioTrack)\n      this.videoSenc = this.videoTrack.videoSenc\n      this.audioSenc = this.audioTrack.audioSenc\n    }\n    if (!this._audioSamples.length && !this._videoSamples.length) {\n      const ret = MP4Parser.moovToSamples(moov)\n      if (!ret) throw new Error('cannot parse samples from moov box')\n      this._videoSamples = ret.videoSamples || []\n      this._audioSamples = ret.audioSamples || []\n    }\n  }\n\n  demux (data, dataStart, videoIndexRange, audioIndexRange, moov) {\n    this.parseSamples(moov)\n\n    const videoTrack = this.videoTrack\n    const audioTrack = this.audioTrack\n\n    videoTrack.samples = []\n    audioTrack.samples = []\n\n    let sample\n    let sampleData\n    let startByte\n    if (videoIndexRange) {\n      let frame\n      let nalSize = 0\n      for (let i = videoIndexRange[0], l = videoIndexRange[1]; i <= l; i++) {\n        sample = this._videoSamples[i]\n        if (!sample) {\n          throw new Error(`cannot found video frame #${i}`)\n        }\n        startByte = sample.offset - dataStart\n        sampleData = data.subarray(startByte, startByte + sample.size)\n        frame = new VideoSample(sample.pts || sample.dts, sample.dts)\n        frame.duration = sample.duration\n        frame.gopId = sample.gopId\n        if (sample.keyframe) frame.setToKeyframe()\n        let start = 0\n        const len = sampleData.length - 1\n        while (start < len) {\n          nalSize = readBig32(sampleData, start)\n          start += 4\n          frame.units.push(sampleData.subarray(start, start + nalSize))\n          start += nalSize\n        }\n        videoTrack.samples.push(frame)\n      }\n\n      videoTrack.baseMediaDecodeTime = videoTrack.samples[0].dts\n    }\n    if (audioIndexRange) {\n      for (let i = audioIndexRange[0], l = audioIndexRange[1]; i <= l; i++) {\n        sample = this._audioSamples[i]\n        if (!sample) {\n          throw new Error(`cannot found video frame #${i}`)\n        }\n        startByte = sample.offset - dataStart\n        sampleData = data.subarray(startByte, startByte + sample.size)\n        audioTrack.samples.push(new AudioSample(sample.dts, sampleData, sample.duration))\n      }\n      audioTrack.baseMediaDecodeTime = audioTrack.samples[0].dts\n    }\n\n    return {\n      videoTrack,\n      audioTrack,\n      metadataTrack: this.metadataTrack\n    }\n  }\n\n  demuxPart (data, dataStart, videoIndexRange, audioIndexRange, moov, useEME, kidValue, customDescryptHandler) {\n    this.parseSamples(moov)\n\n    this.videoTrack.useEME = useEME\n    this.audioTrack.useEME = useEME\n    // this.log.debug('[demuxPart start],dataStart,', dataStart, ',dataLen,', data.byteLength, ', lastRemain,', this._lastRemainBuffer ? this._lastRemainBuffer.byteLength : 0)\n    if (this._lastRemainBuffer && this._lastRemainBuffer.byteLength > 0 && dataStart > this._lastRemainBufferStartPos && dataStart <= this._lastRemainBufferStartPos + this._lastRemainBuffer.byteLength) {\n      let tryCnt = 0\n      while (tryCnt < NEW_ARRAY_MAX_CNT) {\n        try {\n          const buffer = this._lastRemainBuffer.subarray(0, dataStart - this._lastRemainBufferStartPos)\n          const temp = new Uint8Array(data.byteLength + buffer.byteLength)\n          temp.set(buffer, 0)\n          temp.set(new Uint8Array(data), buffer.byteLength)\n          data = temp\n          dataStart -= buffer.byteLength\n          this._lastRemainBuffer = null\n          this._lastRemainBufferStartPos = 0\n          // this.log.debug('[demuxPart add lastRemain],dataStart,', dataStart, ',dataLen,', data.byteLength)\n          break\n        } catch (e) {\n          if (tryCnt < NEW_ARRAY_MAX_CNT) {\n            tryCnt++\n          } else {\n            throw new Error('new Uint8Array error:,' + e.errorMessage)\n          }\n        }\n      }\n    }\n    const videoTrack = this.videoTrack\n    const audioTrack = this.audioTrack\n\n    videoTrack.samples = []\n    audioTrack.samples = []\n    videoTrack.videoSenc = null\n    audioTrack.audioSenc = null\n\n    let sample\n    let sampleData\n    let startByte\n    let videoEndByte = 0\n    let audioEndByte = 0\n    if (this._videoSamples.length > 0 && videoIndexRange.length > 0) {\n      let frame\n      const end = data.byteLength + dataStart\n      for (let i = videoIndexRange[0]; i <= videoIndexRange[1]; i++) {\n        sample = this._videoSamples[i]\n        if (!sample) {\n          throw new Error(`cannot found video frame #${i}`)\n        }\n        if (sample.offset >= dataStart && sample.offset + sample.size <= end) {\n          startByte = sample.offset - dataStart\n          videoEndByte = startByte + sample.size\n          sampleData = data.subarray(startByte, videoEndByte)\n          frame = new VideoSample(sample.pts || sample.dts, sample.dts)\n          frame.duration = sample.duration\n          // this.log.debug('[video !!!!!!!!],frame,index，', sample.index, ',segmentIdx', segmentIdx, ', dataStart,', dataStart, ',dataEnd', end, ',Samplestart,', sample.offset, ', SampleEnd,', sample.offset + sample.size, ',size,', sample.size, 'dts,', sample.dts, ',pts,', sample.pts, ', keyframe', sample.keyframe)\n          frame.gopId = sample.gopId\n          frame.sampleOffset = sample.index\n          // frame.timeOffset = sample.timeOffset || sample.timeOffset === 0 ? sample.timeOffset : null\n          if (sample.keyframe) frame.setToKeyframe()\n          frame.data = sampleData\n          frame.size = sample.size\n          // this.log.debug('[demux video frame],frame,index，', sample.index, ', size,', sampleData.byteLength, ', hash ', hashVal(sampleData.toString()))\n          videoTrack.samples.push(frame)\n        }\n      }\n      if (videoTrack.samples.length > 0) {\n        videoTrack.gopId = videoTrack.samples[0].gopId\n        videoTrack.baseMediaDecodeTime = videoTrack.samples[0].dts\n        videoTrack.startPts = videoTrack.samples[0].pts / videoTrack.timescale\n        videoTrack.endPts = videoTrack.samples[videoTrack.samples.length - 1].pts / videoTrack.timescale\n        // this.log.debug('[demux video],frame,startPts，', videoTrack.startPts, ', endPts,', videoTrack.endPts)\n        if (this.videoSenc) {\n          videoTrack.videoSenc = this.videoSenc.slice(videoTrack.samples[0].sampleOffset, videoTrack.samples[0].sampleOffset + videoTrack.samples.length)\n          videoTrack.kidValue = kidValue\n        }\n      }\n    }\n    if (this._audioSamples.length > 0 && audioIndexRange.length > 0) {\n      for (let i = audioIndexRange[0]; i <= audioIndexRange[1]; i++) {\n        sample = this._audioSamples[i]\n        if (!sample) {\n          throw new Error(`cannot found video frame #${i}`)\n        }\n        if (sample.offset >= dataStart && sample.offset + sample.size <= data.byteLength + dataStart) {\n          startByte = sample.offset - dataStart\n          audioEndByte = startByte + sample.size\n          sampleData = data.subarray(startByte, audioEndByte)\n          // this.log.debug('[audio !!!!!!!!],audio frame,index，', sample.index, ',segmentIdx', segmentIdx, ', Samplestart,', sample.offset, ', SampleEnd,', sample.offset + sample.size, ',size,', sample.size, 'dts,', sample.dts, ',pts,', sample.pts || sample.dts)\n          // frame.gopId = sample.gopId\n          // this.log.debug('[demux audio frame],index ,', sample.index, ', size,', sampleData.byteLength, ', hash,', hashVal(sampleData.toString()))\n          audioTrack.samples.push(new AudioSample(sample.dts, sampleData, sample.duration, sample.index))\n        }\n      }\n      if (audioTrack.samples.length > 0) {\n        audioTrack.gopId = audioTrack.samples[0].gopId || videoTrack.gopId\n        audioTrack.baseMediaDecodeTime = audioTrack.samples[0].dts\n        audioTrack.startPts = audioTrack.samples[0].pts / audioTrack.timescale\n        audioTrack.endPts = audioTrack.samples[audioTrack.samples.length - 1].pts / audioTrack.timescale\n        // this.log.debug('[demux audio],frame,startPts，', audioTrack.startPts, ', endPts,', audioTrack.endPts)\n        if (this.audioSenc) {\n          audioTrack.audioSenc = this.audioSenc.slice(audioTrack.samples[0].sampleOffset, audioTrack.samples[0].sampleOffset + audioTrack.samples.length)\n          audioTrack.kidValue = kidValue\n        }\n      }\n    }\n    this.decoderData(videoTrack, audioTrack, customDescryptHandler)\n    let nalSize = 0\n    for (let i = 0; i < videoTrack.samples.length; i++) {\n      let start = 0\n      const sampleData = videoTrack.samples[i].data\n      const len = sampleData.length - 1\n      while (start < len) {\n        nalSize = readBig32(sampleData, start)\n        start += 4\n        videoTrack.samples[i].units.push(sampleData.subarray(start, start + nalSize))\n        start += nalSize\n      }\n    }\n    this._lastRemainBuffer = data.subarray(Math.max(videoEndByte, audioEndByte))\n    if (this._lastRemainBuffer.byteLength > 0) {\n      this._lastRemainBufferStartPos = dataStart + data.byteLength - this._lastRemainBuffer.byteLength\n    } else {\n      this._lastRemainBufferStartPos = 0\n    }\n    return {\n      videoTrack,\n      audioTrack,\n      metadataTrack: this.metadataTrack\n    }\n  }\n\n  reset () {\n    this._videoSamples = []\n    this._audioSamples = []\n    this._lastRemainBuffer = null\n    this._lastRemainBufferStartPos = 0\n    this.videoTrack.reset()\n    this.audioTrack.reset()\n    this.metadataTrack.reset()\n  }\n\n  decoderData (videoTrack, audioTrack, customDescryptHandler) {\n    if (videoTrack.useEME || audioTrack.useEME) return\n    Crypto.decoderAESCTRData(videoTrack, audioTrack, customDescryptHandler)\n  }\n\n  static probe (data) {\n    return MP4Parser.probe(data)\n  }\n}\n","import { TrackType } from '../model'\nimport { MP4 } from './mp4'\nimport { concatUint8Array } from '../utils'\n\nexport class MP4Remuxer {\n  /**\n   * @param {import('../model').VideoTrack} videoTrack\n   * @param {import('../model').AudioTrack} audioTrack\n   */\n  constructor (videoTrack, audioTrack) {\n    this.videoTrack = videoTrack\n    this.audioTrack = audioTrack\n  }\n\n  /**\n   * @returns {import('./fmp4-remuxer').RemuxResult}\n   */\n  remux (videoTrack, audioTrack) {\n    this.videoTrack = videoTrack || this.videoTrack\n    this.audioTrack = audioTrack || this.audioTrack\n\n    const hasVideo = videoTrack?.exist() && videoTrack?.hasSample()\n    const hasAudio = audioTrack?.exist() && audioTrack?.hasSample()\n\n    let videoSegment\n    let audioSegment\n    if (hasVideo && hasAudio) {\n      videoSegment = this._remuxMix(videoTrack, audioTrack)\n    } else if (hasVideo) {\n      videoSegment = this._remuxTrack(videoTrack)\n    } else if (hasAudio) {\n      audioSegment = this._remuxTrack(audioTrack)\n    }\n\n    if (videoTrack) {\n      videoTrack.samples = []\n    }\n\n    if (audioTrack) {\n      audioTrack.samples = []\n    }\n\n    return {\n      videoSegment,\n      audioSegment\n    }\n  }\n\n  _remuxMix (videoTrack, audioTrack) {\n    const ftyp = MP4.ftyp([videoTrack, audioTrack])\n    const { mdatData: video, chunkOffset } = this._remuxData(videoTrack, ftyp.byteLength + 8)\n    const { mdatData: audio } = this._remuxData(audioTrack, chunkOffset)\n\n    const mdat = MP4.mdat(concatUint8Array(video, audio))\n    const moov = MP4.moovMP4([videoTrack, audioTrack])\n\n    videoTrack.ext = undefined\n    audioTrack.ext = undefined\n\n    videoTrack.samples = []\n    audioTrack.samples = []\n\n    return concatUint8Array(ftyp, mdat, moov)\n  }\n\n  _remuxTrack (track) {\n    const ftyp = MP4.ftyp([track])\n\n    const { mdatData } = this._remuxData(track, ftyp.byteLength + 8)\n    const mdat = MP4.mdat(mdatData)\n    const moov = MP4.moovMP4([track])\n\n    track.ext = undefined\n    track.samples = []\n\n    return concatUint8Array(ftyp, mdat, moov)\n  }\n\n  _remuxData (track, chunkOffset) {\n    const isVideo = track.type === TrackType.VIDEO\n    const samples = track.samples\n\n    let mdatSize = 0\n    if (isVideo) {\n      samples.forEach((s) => {\n        mdatSize += s.units.reduce((t, c) => (t + c.byteLength), 0)\n        mdatSize += (s.units.length * 4)\n      })\n    } else {\n      mdatSize = samples.reduce((t, c) => (t + c.size), 0)\n    }\n\n    const mdatData = new Uint8Array(mdatSize)\n    const mdatView = new DataView(mdatData.buffer)\n\n    const ext = track.ext = {\n      stts: [],\n      stsc: [],\n      stsz: [],\n      stco: [],\n      stss: [],\n      ctts: []\n    }\n\n    const samplesPerChunk = 1\n    let dataOffset = 0\n    let totalDuration = 0\n    let sample\n    const sampleLen = samples.length\n    for (let i = 0; i < sampleLen; i++) {\n      sample = samples[i]\n      totalDuration += sample.duration\n\n      let sampleSize = isVideo ? 0 : sample.size\n      if (isVideo) {\n        sample.units.forEach((u) => {\n          mdatView.setUint32(dataOffset, u.byteLength)\n          dataOffset += 4\n          mdatData.set(u, dataOffset)\n          dataOffset += u.byteLength\n          sampleSize += (4 + u.byteLength)\n        })\n      } else {\n        mdatData.set(sample.data, dataOffset)\n        dataOffset += sampleSize\n      }\n      sample.size = sampleSize\n      ext.stsz.push(sampleSize)\n\n      if (isVideo) this._fillCttsSamples(ext.ctts, sample.cts)\n      this._fillSttsSamples(ext.stts, sample, samples[i + 1])\n      this._fillStcoSamples(ext.stco, i, samplesPerChunk, chunkOffset)\n      chunkOffset += sampleSize\n\n      if (isVideo && sample.keyframe) {\n        ext.stss.push(i + 1)\n      }\n    }\n\n    track.duration = totalDuration\n    this._fillStscSamples(ext.stsc, sampleLen, samplesPerChunk)\n\n    return {\n      mdatData,\n      chunkOffset\n    }\n  }\n\n  _fillSttsSamples (sttsSamples, cur, next) {\n    const lastSample = sttsSamples[sttsSamples.length - 1]\n\n    if (next) {\n      if (!lastSample || lastSample.value !== cur.duration) {\n        sttsSamples.push({ value: cur.duration, count: 1 })\n      } else {\n        lastSample.count++\n      }\n      return\n    }\n\n    if (lastSample) {\n      lastSample.count++\n    } else {\n      sttsSamples.push({ value: 40, count: 1 })\n    }\n  }\n\n  _fillCttsSamples (cttsSamples, cts) {\n    const lastSample = cttsSamples[cttsSamples.length - 1]\n\n    if (!lastSample || lastSample.value !== cts) {\n      cttsSamples.push({ value: cts, count: 1 })\n    } else {\n      lastSample.count++\n    }\n  }\n\n  _fillStcoSamples (stcoSamples, index, samplePerChunk, chunkOffset) {\n    if (!(index % samplePerChunk)) {\n      stcoSamples.push(chunkOffset)\n    }\n  }\n\n  _fillStscSamples (samples, sampleCount, samplesPerChunk) {\n    if (sampleCount <= samplesPerChunk) {\n      samples.push({ firstChunk: 1, samplesPerChunk: sampleCount, sampleDescIndex: 1 })\n    } else {\n      const len = Math.floor(sampleCount / samplesPerChunk)\n      const remaining = sampleCount % samplesPerChunk\n      samples.push({ firstChunk: 1, samplesPerChunk, sampleDescIndex: 1 })\n      if (remaining) {\n        samples.push({ firstChunk: len + 1, samplesPerChunk: remaining, sampleDescIndex: 1 })\n      }\n    }\n  }\n}\n","import * as flv from './flv'\nimport * as mpegTs from './mpeg-ts'\nimport * as mp4 from './mp4'\nimport * as model from './model'\nimport { Logger } from './utils'\n\nexport default {\n  ...flv,\n  ...mpegTs,\n  ...mp4,\n  ...model,\n  Logger\n}\n"],"names":["TrackType","VIDEO","AUDIO","METADATA","VideoCodecType","AVC","HEVC","AudioCodecType","AAC","G711PCMA","G711PCMU","WarningType","LARGE_AV_SHIFT","LARGE_VIDEO_GAP","LARGE_VIDEO_GAP_BETWEEN_CHUNK","LARGE_AUDIO_GAP","AUDIO_FILLED","AUDIO_DROPPED","VideoTrack","_classCallCheck","_defineProperty","this","undefined","_createClass","key","value","sequenceNumber","width","height","fpsDen","fpsNum","duration","baseMediaDecodeTime","timescale","codec","present","pid","pps","sps","vps","sarRatio","samples","warnings","hvcC","get","length","dts","pts","first","last","isVideoEncryption","AudioTrack","sampleDuration","sampleRate","channelCount","config","codecType","isAudioEncryption","VideoSample","units","originPts","originDts","keyframe","flag","dependsOn","isNonSyncSample","AudioSample","data","sampleOffset","size","byteLength","Sample","FlvScriptSample","_Sample","_inherits","_super","_createSuper","apply","arguments","SeiSample","_Sample2","_super2","MetadataTrack","flvScriptSamples","seiSamples","ExpGolomb","Error","_data","_bytesAvailable","_loadWord","_bitsAvailable","position","availableBytes","Math","min","workingBytes","Uint8Array","set","subarray","_word","DataView","buffer","getUint32","count","skipBytes","floor","bits","val","readBits","leadingZeroCount","skipLZ","skipBits","clz","readUEG","lastScale","nextScale","j","readEG","Logger","name","_prefix","concat","_console","disabled","_len","args","Array","_key","console","warn","UTF8","uint8array","out","input","i","push","String","fromCharCode","_checkContinuation","ucs4","_ucs2","join","start","checkLength","array","isBrowser","window","ua","navigator","userAgent","toLocaleLowerCase","isSafari","test","isFirefox","includes","isAndroid","concatUint8Array","arr","filter","Boolean","reduce","p","c","prevLen","forEach","d","MAX_SIZE","pow","readBig16","readBig32","readBig64","getAvcCodec","codecs","h","toString","formatIV","iv","Number","slice","toUpperCase","bufferToString","len","parse","a","isArray","parseInt","map","item","NALu","end","offset","dataLen","unit","isHevc","type","uuid","payload","uint","emulationPreventionBytesPositions","newLength","newData","sourceIndex","shift","nalUnitSize","spsParsed","spsSize","spsArr","ppsArr","spsCount","parseSPS","removeEPB","ppsSize","ppsCount","eg","readUByte","profileIdc","profileCompatibility","levelIdc","skipUEG","chromaFormat","chromaFormatIdc","readBool","scalingListCount","skipScalingList","picOrderCntType","numRefFramesInPicOrderCntCycle","picWidthInMbsMinus1","picHeightInMapUnitsMinus1","frameMbsOnlyFlag","fixedFrame","fps","frameCropLeftOffset","frameCropRightOffset","frameCropTopOffset","frameCropBottomOffset","aspectRatioIdc","numUnitsInTick","timeScale","ceil","rate","FREQ","indexOf","skip","frames","samplingFrequencyIndex","protectionSkipBytes","frameLength","objectType","_AAC$_getConfig","_getConfig","frameIndex","getFrameDuration","remaining","originCodec","_AAC$_getConfig2","samplingIndex","originObjectType","extensionSamplingIndex","vpsParsed","nalUnitType","numNalus","nalSize","vpsArr","numOfArrays","parseVPS","vpsMaxSubLayersMinus1","numTemporalLayers","max","_parseProfileTierLevel","spsMaxSubLayersMinus1","temporalIdNested","separateColourPlaneFlag","confWinLeftOffset","confWinRightOffset","confWinTopOffset","confWinBottomOffset","conformanceWindowFlag","bitDepthLumaMinus8","bitDepthChromaMinus8","subWidthC","subHeightC","maxSubLayersMinus1","generalTierFlag","generalProfileSpace","generalProfileIdc","generalProfileCompatibilityFlags","generalConstraintIndicatorFlags","generalLevelIdc","subLayerProfilePresentFlag","subLayerLevelPresentFlag","bitsAvailable","MAX_SILENT_FRAME_DURATION","AUDIO_EXCETION_LOG_EMIT_DURATION","FlvFixer","videoTrack","audioTrack","metadataTrack","_baseDts","_baseDtsInited","_audioNextPts","_videoNextDts","_audioTimestampBreak","_videoTimestampBreak","_lastVideoDuration","_keyFrameInNextChunk","_lastAudioExceptionGapDot","Infinity","_lastAudioExceptionOverlapDot","_lastAudioExceptionLargeGapDot","_lastVideoExceptionLargeGapDot","_lastVideoExceptionChunkFirstDtsDot","_this","startTime","discontinuity","contiguous","round","_videoLastSample","_calculateBaseDts","resetBaseDts","exist","_resetBaseDtsWhenStreamBreaked","_fixAudio","_fixVideo","s","time","_this2","refSampleDurationInt","x","lastSample","pop","unshift","samp0","firstSample","vDelta","abs","_samples$","nextDts","firstSampleDts","nextSampleDts","nextSample","refSampleDuration","_this3","_doFixAudioInternal","audioSamps","videoSamps","audioBasePts","videoBaseDts","baseDts","delta","isFinite","_getG711Duration","sampleDurationInSampleRate","nextPts","sample","silentFrame","_getSilentFrame","silentSample","splice","track","sampleSize","getSilentFrame","AMF","ret","_parseValue","byteOffset","view","isEnd","getUint8","getFloat64","_AMF$_parseString","_parseString","terminal","_AMF$_parseObject","_parseObject","_terminal","_AMF$_parseObject2","strictArrayLength","_AMF$_parseValue","timestamp","getInt16","Date","decode","getUint16","logger","FlvDemuxer","_fixer","_remainingData","_headerParsed","reset","probe","tagType","dataSize","bodyData","prevTagSize","_parseAudio","_parseVideo","_parseScript","formatTimescale","hasSample","fix","demux","format","soundRate","soundSize","soundType","AUDIO_RATE","_parseAac","_parseG711","parseAudioSpecificConfig","sampleRateIndex","frameType","codecId","packetType","cts","configData","parseHEVCDecoderConfigurationRecord","parseAVCDecoderConfigurationRecord","parseAvcC","_checkAddMetaNalToUnits","setToKeyframe","parseSEI","_gopId","gopId","hevc","_needAddMetaBeforeKeyFrameNal","MAX_VIDEO_FRAME_DURATION","TsFixer","vSamples","aSamples","firstVideoSample","firstAudioSample","vaDelta","vDeltaToNextDts","aDeltaToNextDts","_samples$i","prevDts","second","expectFragEnd","_audioLastSample","TsDemuxer","_pmtId","_remainingPacketData","_videoPesData","_audioPesData","remainingLength","videoPid","audioPid","payloadUnitStartIndicator","adaptationFiledControl","tableEnd","programInfoLength","esPid","_parseVideoData","_parseAudioData","pes","_parsePES","_toConsumableArray","parseAnnexB","_createVideoSample","spsInfo","ffByteFound","_pushVideoSample","_parseAacData","_track$samples","parseADTS","headerDataLen","pesLen","ptsDtsFlags","MP4Parser","names","headerSize","subData","findBox","box","parseBox","trackId","baseDataOffsetPresent","flags","sampleDescriptionIndexPresent","defaultSampleDurationPresent","defaultSampleSizePresent","defaultSampleFlagsPresent","baseDataOffset","sampleDescriptionIndex","defaultSampleDuration","defaultSampleSize","defaultSampleFlags","reference_ID","version","earliest_presentation_time","first_offset","references","ref","tmp32","reference_type","referenced_size","subsegment_duration","starts_with_SAP","SAP_type","SAP_delta_time","mvhd","trak","pssh","nextTrackId","tkhd","mdia","mdhd","hdlr","minf","lang","language","handlerType","vmhd","smhd","stbl","graphicsmode","opcolor","balance","_ret$stsd$entries$","_ret$stsd$entries$$si","_ret$stsd$entries$$si2","stsd","stts","ctts","stsc","stsz","stco","co64","default_IV_size","entries","sinf","schi","tenc","stss","senc","sampleCount","InitializationVector","subsamples","subsampleCount","subsample","BytesOfClearData","BytesOfProtectedData","keyIds","systemId","toHex","numKeyIds","keyId","data_size","kid","system_id","entryCount","b","avc1","hvc1","mp4a","alaw","samplesize","esds","horizresolution","vertresolution","avcC","pasp","default_IsEncrypted","default_KID","frma","data_format","bodyStart","parseVisualSampleEntry","configurationVersion","AVCProfileIndication","AVCLevelIndication","lengthSizeMinusOne","spsLength","ppsLength","tmp","generalProfileCompatibility","avgFrameRate","_ret$vps","nalus","_ret$sps","_ret$pps","hSpacing","vSpacing","parseAudioSampleEntry","byteRead","tag","substring","padStart","firstChunk","samplesPerChunk","entrySizes","mfhd","traf","t","tfhd","tfdt","trun","dataOffset","firstSampleFlags","isLeading","isDependedOn","hasRedundancy","paddingValue","degradationPriority","moov","_e$esds","_e$esds2","tracks","vTrack","find","_t$mdia","_t$mdia$hdlr","aTrack","_t$mdia2","_t$mdia2$hdlr","_vTrack$tkhd","_vTrack$mdia","_vTrack$mdia$minf","_vTrack$mdia$minf$stb","_vTrack$mdia2","_vTrack$mdia2$minf","_vTrack$mdia2$minf$st","v","_vTrackId","id","tkhdDuration","mvhdDurtion","mvhdTimecale","_e1$sinf","_e1$sinf$schi","_e1$sinf2","_e1$sinf2$schi","_e1$sinf3","_e1$sinf3$schi","_e1$sinf4","_e1$sinf4$frma","e1","ext","videoSenc","useEME","kidValue","encv","_aTrack$tkhd","_e$esds3","_e$esds4","_aTrack$mdia","_aTrack$mdia$minf","_aTrack$mdia$minf$stb","_aTrack$mdia2","_aTrack$mdia2$minf","_aTrack$mdia2$minf$st","_aTrackId","_e$sinf","_e$sinf$frma","_e$sinf2","_e$sinf2$schi","_e$sinf3","_e$sinf3$schi","_e$sinf4","_e$sinf4$schi","getRateIndexByRate","from","audioSenc","enca","_videoTrack$encv","_audioTrack$enca","vkid","akid","videoSampleCount","_audioTrack$samples","audioSampleCount","moof","_ref","defaultSize","defaultDuration","evaluateDefaultDuration","index","_t$mdia3","_t$mdia3$hdlr","_t$mdia4","_t$mdia4$hdlr","videoSamples","audioSamples","_vTrack$mdia3","_vTrack$mdia3$minf","videoStbl","getSamples","_aTrack$mdia3","_aTrack$mdia3$minf","_aTrack$mdia$mdhd","audioStbl","keyframeMap","cttsArr","cttsEntries","stscEntries","stcoEntries","stszEntrySizes","stssEntries","_ref2","pos","chunkIndex","chunkRunIndex","offsetInChunk","lastSampleInChunk","lastChunkInRun","_ref3","dataReferenceIndex","frameCount","depth","isFullBox","readBig24","str","pad","charstr","maxlen","chars","r","hex","FMP4Demuxer","videoData","audioData","videoExist","audioExist","moovBox","moovToTrack","moofBox","moofToSamples","baseOffset","sampleData","videoBaseMediaDecodeTime","audioBaseMediaDecodeTime","Object","keys","k","Concat","ResultConstructor","totalLength","arrays","result","Buffer","self","_len2","_key2","UINT32_MAX","MP4","FTYPHEV1","FTYPAVC1","init","ftyp","content","types","mvex","HDLR_TYPES","VMHD","SMHD","DINF","extBox","STTS","STSC","STSZ","STCO","avc1hev1","_concat$concat","avcc","btrt","charCodeAt","schm","typ","boxes","fiel","_concat$concat2","ArrayBuffer","pcf","cif","write","_ref4","_slicedToArray","trex","sencLength","isVideo","videoSencLength","saiz","saio","trun1","sbgp","sdtp","extension","writeUint32","samplesLength","writeUint16","upperWordBaseMediaDecodeTime","lowerWordBaseMediaDecodeTime","sampleLen","_samples$i$flag","_samples$i$cts","trackMP4","mdiaMP4","minfMP4","stblMP4","_ref5","_ref6","sampleDescIndex","samplesSizes","offsets","keyframeIndexes","_ref7","styp","durationCount","earliestTime","mdatSize","sidx","mdat","create","video","audio","dinf","dref","StblTable","enable","debug","_console2","log","_console3","_len3","_key3","_console4","_len4","_key4","error","_console5","group","table","groupEnd","FMP4Remuxer","options","browserVersions","exec","forceFirstIDR","openLog","createInit","videoInitSegment","audioInitSegment","initSegment","videoSegment","audioSegment","hasVideo","hasAudio","initMerge","_remuxVideo","_remuxAudio","mdata","mdatView","_loop","_offset","_sample","u","setUint32","l","Base","properties","assign","clone","constructor","_construct","WordArray","_Base","words","sigBytes","call","typedArray","Int8Array","Uint8ClampedArray","Int16Array","Uint16Array","Int32Array","Uint32Array","Float32Array","Float64Array","typedArrayByteLength","_words","encoder","Hex","stringify","wordArray","thisWords","thatWords","thisSigBytes","thatSigBytes","clamp","thatByte","_get","_getPrototypeOf","prototype","nBytes","rcache","m_w","_m_w","_m_z","mask","random","_r","hexChars","bite","hexStr","hexStrLength","substr","Latin1","latin1Str","latin1StrLength","Utf8","utf8Str","unescape","encodeURIComponent","BufferedBlockAlgorithm","_Base2","_minBufferSize","_nDataBytes","m_data","doFlush","processedWords","blockSize","dataWords","dataSigBytes","nBlocksReady","nWordsReady","nBytesReady","_doProcessBlock","Hasher","_BufferedBlockAlgorit","_super3","cfg","_doReset","messageUpdate","_append","_process","hash","_doFinalize","SubHasher","message","finalize","HMAC","_Base3","_super4","_this4","hasher","_hasher","hasherBlockSize","hasherBlockSizeBytes","oKey","_oKey","iKey","_iKey","oKeyWords","iKeyWords","update","innerHash","hmac","Base64","_map","base64Chars","triplet","charAt","paddingChar","base64Str","base64StrLength","reverseMap","_reverseMap","paddingIndex","parseLoop","bits1","bitsCombined","T","sin","FF","n","GG","HH","II","MD5Algo","_Hasher","_hash","M","_M","offset_i","M_offset_i","H","M_offset_0","M_offset_1","M_offset_2","M_offset_3","M_offset_4","M_offset_5","M_offset_6","M_offset_7","M_offset_8","M_offset_9","M_offset_10","M_offset_11","M_offset_12","M_offset_13","M_offset_14","M_offset_15","nBitsTotal","nBitsLeft","nBitsTotalH","nBitsTotalL","H_i","_createHelper","_createHmacHelper","EvpKDFAlgo","keySize","iterations","password","salt","derivedKeyWords","block","derivedKey","Cipher","xformMode","_xformMode","dataUpdate","finalProcessedData","_ENC_XFORM_MODE","_DEC_XFORM_MODE","SubCipher","selectCipherStrategy","PasswordBasedCipher","SerializableCipher","encrypt","decrypt","ciphertext","ivSize","BlockCipherMode","cipher","_cipher","_iv","Encryptor","Decryptor","xorBlock","_prevBlock","CBC","_BlockCipherMode","_CBC","_class","_super5","encryptBlock","_CBC2","_class2","_super6","thisBlock","decryptBlock","Pkcs7","blockSizeBytes","nPaddingBytes","paddingWord","paddingWords","padding","unpad","BlockCipher","_Cipher2","_super7","mode","modeCreator","createEncryptor","createDecryptor","_mode","__creator","processBlock","finalProcessedBlocks","CipherParams","_super8","cipherParams","_this5","mixIn","formatter","OpenSSLFormatter","openSSLStr","ciphertextWords","_super9","_cfg","encryptor","cipherCfg","algorithm","_ciphertext","plaintext","_parse","OpenSSLKdf","execute","_salt","compute","_SerializableCipher","_super10","derivedParams","kdf","_SBOX","INV_SBOX","_SUB_MIX_0","_SUB_MIX_1","_SUB_MIX_2","_SUB_MIX_3","INV_SUB_MIX_0","INV_SUB_MIX_1","INV_SUB_MIX_2","INV_SUB_MIX_3","xi","sx","x2","x4","x8","RCON","AESAlgo","_BlockCipher","_nRounds","_keyPriorReset","keyWords","ksRows","_keySchedule","keySchedule","ksRow","_invKeySchedule","invKeySchedule","invKsRow","_doCryptBlock","SUB_MIX_0","SUB_MIX_1","SUB_MIX_2","SUB_MIX_3","SBOX","nRounds","s0","s1","s2","s3","t0","t1","t2","t3","AES","CTR","_CTR","counter","_counter","keystream","NoPadding","Crypto","decryptWordArray","raw","realKey","realIV","decryptWord","wordArrayToUint8Array","w","decoderAESCTRData","customDescryptHandler","sencBox","encodeWord","encodeBuffers","decodeBuffers","tempBuffer","decrypted","clearDataBuf","protectedDataLen","decodeProtectedData","dec","MP4Demuxer","videoSegmnents","audioSegmnents","_this$_videoSamples","_videoSamples","_this$_audioSamples","_audioSamples","moovToSamples","dataStart","videoIndexRange","audioIndexRange","parseSamples","startByte","frame","_lastRemainBuffer","_lastRemainBufferStartPos","tryCnt","temp","e","errorMessage","videoEndByte","audioEndByte","startPts","endPts","decoderData","MP4Remuxer","_remuxMix","_remuxTrack","_this$_remuxData","_remuxData","mdatData","chunkOffset","moovMP4","totalDuration","_fillCttsSamples","_fillSttsSamples","_fillStcoSamples","_fillStscSamples","sttsSamples","cur","next","cttsSamples","stcoSamples","samplePerChunk","_objectSpread","flv","mpegTs","mp4","model"],"mappings":"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"}