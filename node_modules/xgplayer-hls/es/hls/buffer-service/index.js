import { createClass as _createClass, classCallCheck as _classCallCheck, defineProperty as _defineProperty, asyncToGenerator as _asyncToGenerator, regeneratorRuntime as _regeneratorRuntime, slicedToArray as _slicedToArray, objectWithoutProperties as _objectWithoutProperties } from "../../_virtual/_rollupPluginBabelHelpers.js";
import { TsDemuxer, MP4Parser } from "xgplayer-transmuxer";
import { Logger, StreamingError, ERR, MSE, EVENT, Buffer } from "xgplayer-streaming-shared";
import { Decryptor } from "./decrypt/index.js";
import { Transmuxer } from "./transmuxer/index.js";
import { Event } from "../constants.js";
var _excluded = ["data"], _excluded2 = ["data"];
var logger = new Logger("BufferService");
var BufferService = /* @__PURE__ */ function() {
  function BufferService2(hls) {
    var _this = this;
    _classCallCheck(this, BufferService2);
    _defineProperty(this, "_decryptor", new Decryptor());
    _defineProperty(this, "_transmuxer", null);
    _defineProperty(this, "_mse", null);
    _defineProperty(this, "_softVideo", null);
    _defineProperty(this, "_sourceCreated", false);
    _defineProperty(this, "_needInitSegment", true);
    _defineProperty(this, "_directAppend", false);
    this.hls = hls;
    if (hls.config.softDecode) {
      this._softVideo = hls.media;
    } else {
      this._mse = new MSE(null, {
        preferMMS: hls.config.preferMMS
      });
      if (hls.config.url) {
        this._mse.bindMedia(hls.media).then(function(e) {
          _this.hls.emit(EVENT.MEDIASOURCE_OPENED, e);
        });
      }
    }
    if (hls.config.decryptor) {
      this._decryptor.externalDecryptor = hls.config.decryptor;
    }
  }
  _createClass(BufferService2, [{
    key: "baseDts",
    get: function get() {
      var _this$_transmuxer, _this$_transmuxer$_de, _this$_transmuxer$_de2;
      return (_this$_transmuxer = this._transmuxer) === null || _this$_transmuxer === void 0 ? void 0 : (_this$_transmuxer$_de = _this$_transmuxer._demuxer) === null || _this$_transmuxer$_de === void 0 ? void 0 : (_this$_transmuxer$_de2 = _this$_transmuxer$_de._fixer) === null || _this$_transmuxer$_de2 === void 0 ? void 0 : _this$_transmuxer$_de2._baseDts;
    }
  }, {
    key: "nbSb",
    get: function get() {
      var _this$_mse;
      if (!((_this$_mse = this._mse) !== null && _this$_mse !== void 0 && _this$_mse._sourceBuffer))
        return 0;
      return Object.keys(this._mse._sourceBuffer).length;
    }
  }, {
    key: "msIsOpened",
    get: function get() {
      var _this$_mse2;
      return (_this$_mse2 = this._mse) === null || _this$_mse2 === void 0 ? void 0 : _this$_mse2.isOpened;
    }
  }, {
    key: "msHasOpTasks",
    get: function get() {
      var _this$_mse3;
      return (_this$_mse3 = this._mse) === null || _this$_mse3 === void 0 ? void 0 : _this$_mse3.hasOpTasks;
    }
  }, {
    key: "msStreaming",
    get: function get() {
      var _this$_mse4;
      return (_this$_mse4 = this._mse) === null || _this$_mse4 === void 0 ? void 0 : _this$_mse4.streaming;
    }
  }, {
    key: "updateDuration",
    value: function() {
      var _updateDuration = _asyncToGenerator(/* @__PURE__ */ _regeneratorRuntime().mark(function _callee(duration) {
        return _regeneratorRuntime().wrap(function _callee$(_context) {
          while (1)
            switch (_context.prev = _context.next) {
              case 0:
                logger.debug("update duration", duration);
                if (!this._mse) {
                  _context.next = 9;
                  break;
                }
                if (this._mse.isOpened) {
                  _context.next = 5;
                  break;
                }
                _context.next = 5;
                return this._mse.open();
              case 5:
                _context.next = 7;
                return this._mse.updateDuration(duration);
              case 7:
                _context.next = 10;
                break;
              case 9:
                if (this._softVideo) {
                  this._softVideo.duration = duration;
                }
              case 10:
              case "end":
                return _context.stop();
            }
        }, _callee, this);
      }));
      function updateDuration(_x) {
        return _updateDuration.apply(this, arguments);
      }
      return updateDuration;
    }()
  }, {
    key: "createSource",
    value: function createSource(videoChunk, audioChunk, videoCodec, audioCodec) {
      if (this._sourceCreated)
        return;
      var chunk = videoChunk || audioChunk;
      if (!chunk)
        return;
      if (TsDemuxer.probe(chunk)) {
        if (!this._transmuxer)
          this._transmuxer = new Transmuxer(this.hls, false, !this._softVideo);
      } else if (MP4Parser.probe(chunk)) {
        if (this._softVideo) {
          if (!this._transmuxer)
            this._transmuxer = new Transmuxer(this.hls, true);
        } else {
          this._directAppend = true;
          var mix = false;
          if (videoChunk && !videoCodec) {
            MP4Parser.findBox(videoChunk, ["moov", "trak"]).forEach(function(t) {
              var box = MP4Parser.findBox(t.data, ["trak", "mdia", "minf", "stbl", "stsd"])[0];
              if (box) {
                var e = MP4Parser.stsd(box).entries[0];
                if (e) {
                  if (e.hvcC) {
                    videoCodec = e.hvcC.codec || "hev1.1.6.L93.B0";
                  } else if (e.avcC) {
                    videoCodec = e.avcC.codec;
                  } else if (e.sampleRate || e.esds) {
                    var _e$esds;
                    audioCodec = ((_e$esds = e.esds) === null || _e$esds === void 0 ? void 0 : _e$esds.codec) || "mp4a.40.2";
                    mix = true;
                  }
                }
              }
            });
          }
          if (audioChunk && !audioCodec) {
            MP4Parser.findBox(audioChunk, ["moov", "trak", "mdia", "minf", "stbl", "stsd"]).forEach(function(stsd) {
              var e = MP4Parser.stsd(stsd).entries[0];
              if (e && e.esds)
                audioCodec = e.esds.codec;
            });
          }
          if (videoChunk && !videoCodec)
            videoCodec = "avc1.42e01e";
          if (audioChunk && !audioCodec)
            audioCodec = "mp4a.40.2";
          if (mix) {
            videoCodec += ", ".concat(audioCodec);
            audioCodec = "";
          }
          this._createMseSource(videoCodec, audioCodec);
        }
      } else {
        throw new StreamingError(ERR.OTHER, null, null, null, "unsupported stream");
      }
      if (this._softVideo)
        this._sourceCreated = true;
    }
  }, {
    key: "appendBuffer",
    value: function() {
      var _appendBuffer = _asyncToGenerator(/* @__PURE__ */ _regeneratorRuntime().mark(function _callee2(segment, audioSegment, videoChunk, audioChunk, discontinuity, contiguous, startTime) {
        var p, needInit, _this$_transmuxer$tra, _this$_transmuxer$tra2, video, audio, isFirstAppend, mse, _p, videoData, videoRest, audioData, audioRest;
        return _regeneratorRuntime().wrap(function _callee2$(_context2) {
          while (1)
            switch (_context2.prev = _context2.next) {
              case 0:
                if (!(!(videoChunk !== null && videoChunk !== void 0 && videoChunk.length) && !(audioChunk !== null && audioChunk !== void 0 && audioChunk.length))) {
                  _context2.next = 2;
                  break;
                }
                return _context2.abrupt("return");
              case 2:
                if (!this._directAppend) {
                  _context2.next = 7;
                  break;
                }
                p = [];
                if (videoChunk)
                  p.push(this._mse.append(MSE.VIDEO, videoChunk));
                if (audioChunk)
                  p.push(this._mse.append(MSE.AUDIO, audioChunk));
                return _context2.abrupt("return", Promise.all(p));
              case 7:
                needInit = this._needInitSegment || discontinuity;
                _this$_transmuxer$tra = this._transmuxer.transmux(videoChunk, audioChunk, needInit, contiguous, startTime, this._needInitSegment || discontinuity), _this$_transmuxer$tra2 = _slicedToArray(_this$_transmuxer$tra, 2), video = _this$_transmuxer$tra2[0], audio = _this$_transmuxer$tra2[1];
                if (audioChunk && audioSegment) {
                  audioSegment === null || audioSegment === void 0 ? void 0 : audioSegment.setTrackExist(false, true);
                }
                if (audioChunk && segment) {
                  segment === null || segment === void 0 ? void 0 : segment.setTrackExist(true, false);
                }
                if (!audioSegment) {
                  segment === null || segment === void 0 ? void 0 : segment.setTrackExist(!!video, !!audio);
                }
                if (video && !audio) {
                  this.hls.emit(Event.NO_AUDIO_TRACK);
                }
                if (!this._softVideo) {
                  _context2.next = 18;
                  break;
                }
                this._softVideo.appendBuffer(video, audio);
                this._needInitSegment = false;
                _context2.next = 28;
                break;
              case 18:
                if (!this._mse) {
                  _context2.next = 28;
                  break;
                }
                isFirstAppend = !this._sourceCreated;
                if (isFirstAppend) {
                  this._createMseSource(video === null || video === void 0 ? void 0 : video.codec, audio === null || audio === void 0 ? void 0 : audio.codec);
                }
                this._needInitSegment = false;
                mse = this._mse;
                _p = [];
                if (needInit && !isFirstAppend) {
                  this._handleCodecChange(video, audio);
                }
                if (video) {
                  videoData = video.data, videoRest = _objectWithoutProperties(video, _excluded);
                  _p.push(mse.append(MSE.VIDEO, videoData, videoRest));
                }
                if (audio) {
                  audioData = audio.data, audioRest = _objectWithoutProperties(audio, _excluded2);
                  _p.push(mse.append(MSE.AUDIO, audioData, audioRest));
                }
                return _context2.abrupt("return", Promise.all(_p));
              case 28:
              case "end":
                return _context2.stop();
            }
        }, _callee2, this);
      }));
      function appendBuffer(_x2, _x3, _x4, _x5, _x6, _x7, _x8) {
        return _appendBuffer.apply(this, arguments);
      }
      return appendBuffer;
    }()
  }, {
    key: "removeBuffer",
    value: function() {
      var _removeBuffer = _asyncToGenerator(/* @__PURE__ */ _regeneratorRuntime().mark(function _callee3() {
        var _this2 = this;
        var start, end, media, _args3 = arguments;
        return _regeneratorRuntime().wrap(function _callee3$(_context3) {
          while (1)
            switch (_context3.prev = _context3.next) {
              case 0:
                start = _args3.length > 0 && _args3[0] !== void 0 ? _args3[0] : 0;
                end = _args3.length > 1 && _args3[1] !== void 0 ? _args3[1] : Infinity;
                media = this.hls.media;
                if (!(!this._mse || !media || start < 0 || end < start || start >= this._mse.duration)) {
                  _context3.next = 5;
                  break;
                }
                return _context3.abrupt("return");
              case 5:
                return _context3.abrupt("return", this._mse.clearBuffer(start, end).then(function() {
                  return _this2.hls.emit(EVENT.REMOVE_BUFFER, {
                    start,
                    end,
                    removeEnd: end
                  });
                }));
              case 6:
              case "end":
                return _context3.stop();
            }
        }, _callee3, this);
      }));
      function removeBuffer() {
        return _removeBuffer.apply(this, arguments);
      }
      return removeBuffer;
    }()
  }, {
    key: "evictBuffer",
    value: function() {
      var _evictBuffer = _asyncToGenerator(/* @__PURE__ */ _regeneratorRuntime().mark(function _callee4(bufferBehind) {
        var media, currentTime, removeEnd, start;
        return _regeneratorRuntime().wrap(function _callee4$(_context4) {
          while (1)
            switch (_context4.prev = _context4.next) {
              case 0:
                media = this.hls.media;
                if (!(!this._mse || !media || !bufferBehind || bufferBehind < 0)) {
                  _context4.next = 3;
                  break;
                }
                return _context4.abrupt("return");
              case 3:
                currentTime = media.currentTime;
                removeEnd = currentTime - bufferBehind;
                if (!(removeEnd <= 0)) {
                  _context4.next = 7;
                  break;
                }
                return _context4.abrupt("return");
              case 7:
                start = Buffer.start(Buffer.get(media));
                if (!(start + 1 >= removeEnd)) {
                  _context4.next = 10;
                  break;
                }
                return _context4.abrupt("return");
              case 10:
                return _context4.abrupt("return", this.removeBuffer(0, removeEnd));
              case 11:
              case "end":
                return _context4.stop();
            }
        }, _callee4, this);
      }));
      function evictBuffer(_x9) {
        return _evictBuffer.apply(this, arguments);
      }
      return evictBuffer;
    }()
  }, {
    key: "clearAllBuffer",
    value: function() {
      var _clearAllBuffer = _asyncToGenerator(/* @__PURE__ */ _regeneratorRuntime().mark(function _callee5() {
        return _regeneratorRuntime().wrap(function _callee5$(_context5) {
          while (1)
            switch (_context5.prev = _context5.next) {
              case 0:
                if (!this._mse) {
                  _context5.next = 2;
                  break;
                }
                return _context5.abrupt("return", this._mse.clearAllBuffer());
              case 2:
              case "end":
                return _context5.stop();
            }
        }, _callee5, this);
      }));
      function clearAllBuffer() {
        return _clearAllBuffer.apply(this, arguments);
      }
      return clearAllBuffer;
    }()
  }, {
    key: "decryptBuffer",
    value: function decryptBuffer(video, audio) {
      return this._decryptor.decrypt(video, audio);
    }
  }, {
    key: "reset",
    value: function() {
      var _reset = _asyncToGenerator(/* @__PURE__ */ _regeneratorRuntime().mark(function _callee6() {
        var reuseMse, _args6 = arguments;
        return _regeneratorRuntime().wrap(function _callee6$(_context6) {
          while (1)
            switch (_context6.prev = _context6.next) {
              case 0:
                reuseMse = _args6.length > 0 && _args6[0] !== void 0 ? _args6[0] : false;
                if (!(this._mse && !reuseMse)) {
                  _context6.next = 8;
                  break;
                }
                this._transmuxer = null;
                this._sourceCreated = false;
                _context6.next = 6;
                return this._mse.unbindMedia();
              case 6:
                _context6.next = 8;
                return this._mse.bindMedia(this.hls.media);
              case 8:
                this._needInitSegment = true;
                this._directAppend = false;
              case 10:
              case "end":
                return _context6.stop();
            }
        }, _callee6, this);
      }));
      function reset() {
        return _reset.apply(this, arguments);
      }
      return reset;
    }()
  }, {
    key: "endOfStream",
    value: function() {
      var _endOfStream = _asyncToGenerator(/* @__PURE__ */ _regeneratorRuntime().mark(function _callee7() {
        return _regeneratorRuntime().wrap(function _callee7$(_context7) {
          while (1)
            switch (_context7.prev = _context7.next) {
              case 0:
                if (!this._mse) {
                  _context7.next = 5;
                  break;
                }
                if (!this._sourceCreated) {
                  _context7.next = 5;
                  break;
                }
                _context7.next = 4;
                return this._mse.endOfStream();
              case 4:
                this.hls.emit(EVENT.BUFFEREOS);
              case 5:
                if (this._softVideo) {
                  this._softVideo.endOfStream();
                }
              case 6:
              case "end":
                return _context7.stop();
            }
        }, _callee7, this);
      }));
      function endOfStream() {
        return _endOfStream.apply(this, arguments);
      }
      return endOfStream;
    }()
  }, {
    key: "setLiveSeekableRange",
    value: function() {
      var _setLiveSeekableRange = _asyncToGenerator(/* @__PURE__ */ _regeneratorRuntime().mark(function _callee8(start, end) {
        return _regeneratorRuntime().wrap(function _callee8$(_context8) {
          while (1)
            switch (_context8.prev = _context8.next) {
              case 0:
                if (this._mse)
                  this._mse.setLiveSeekableRange(start, end);
              case 1:
              case "end":
                return _context8.stop();
            }
        }, _callee8, this);
      }));
      function setLiveSeekableRange(_x10, _x11) {
        return _setLiveSeekableRange.apply(this, arguments);
      }
      return setLiveSeekableRange;
    }()
  }, {
    key: "destroy",
    value: function() {
      var _destroy = _asyncToGenerator(/* @__PURE__ */ _regeneratorRuntime().mark(function _callee9() {
        var _this$_decryptor;
        return _regeneratorRuntime().wrap(function _callee9$(_context9) {
          while (1)
            switch (_context9.prev = _context9.next) {
              case 0:
                (_this$_decryptor = this._decryptor) === null || _this$_decryptor === void 0 ? void 0 : _this$_decryptor.destroy();
                if (!this._mse) {
                  _context9.next = 4;
                  break;
                }
                _context9.next = 4;
                return this._mse.unbindMedia();
              case 4:
                this._decryptor = null;
                this._mse = null;
                this._softVideo = null;
              case 7:
              case "end":
                return _context9.stop();
            }
        }, _callee9, this);
      }));
      function destroy() {
        return _destroy.apply(this, arguments);
      }
      return destroy;
    }()
  }, {
    key: "_createMseSource",
    value: function _createMseSource(videoCodec, audioCodec) {
      logger.debug("create mse source, videoCodec=".concat(videoCodec, ", audioCodec=").concat(audioCodec));
      var mse = this._mse;
      if (!mse)
        return;
      if (videoCodec) {
        mse.createSource(MSE.VIDEO, "video/mp4;codecs=".concat(videoCodec));
        this._sourceCreated = true;
      }
      if (audioCodec) {
        mse.createSource(MSE.AUDIO, "audio/mp4;codecs=".concat(audioCodec));
        this._sourceCreated = true;
      }
      this.hls.emit(EVENT.SOURCEBUFFER_CREATED);
    }
  }, {
    key: "_handleCodecChange",
    value: function _handleCodecChange(video, audio) {
      var mse = this._mse;
      var codecList = [{
        type: MSE.VIDEO,
        codecs: video === null || video === void 0 ? void 0 : video.codec
      }, {
        type: MSE.AUDIO,
        codecs: audio === null || audio === void 0 ? void 0 : audio.codec
      }];
      codecList.filter(function(item) {
        return !!item.codecs;
      }).forEach(function(_ref) {
        var type = _ref.type, codecs = _ref.codecs;
        var sourceBuffer = mse.getSourceBuffer(type);
        if (sourceBuffer) {
          var codec = codecs.split(",")[0];
          if (!new RegExp(codec, "ig").test(sourceBuffer.mimeType)) {
            mse.changeType(type, "".concat(type, "/mp4;codecs=").concat(codecs));
          }
        }
      });
    }
  }, {
    key: "seamlessSwitch",
    value: function seamlessSwitch() {
      this._needInitSegment = true;
    }
  }, {
    key: "isFull",
    value: function isFull() {
      var _this$_mse5;
      var mediaType = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : MSE.VIDEO;
      return (_this$_mse5 = this._mse) === null || _this$_mse5 === void 0 ? void 0 : _this$_mse5.isFull(mediaType);
    }
  }]);
  return BufferService2;
}();
export { BufferService };
