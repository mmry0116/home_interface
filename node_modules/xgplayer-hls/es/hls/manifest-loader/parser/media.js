import { slicedToArray as _slicedToArray } from "../../../_virtual/_rollupPluginBabelHelpers.js";
import { MediaPlaylist, MediaSegment, MediaSegmentKey } from "./model.js";
import { getAbsoluteUrl, parseTag, parseAttr } from "./utils.js";
function parseMediaPlaylist(lines, parentUrl, useLowLatency) {
  var media = new MediaPlaylist();
  media.url = parentUrl;
  var curSegment = new MediaSegment(parentUrl);
  var curInitSegment = null;
  var curKey = null;
  var totalDuration = 0;
  var curSN = 0;
  var curCC = 0;
  var index = 0;
  var line;
  var endOfList = false;
  var partSegmentIndex = 0;
  while (line = lines[index++]) {
    if (endOfList) {
      break;
    }
    if (line[0] !== "#") {
      if (media.lowLatency) {
        curSN++;
        continue;
      }
      curSegment.sn = curSN;
      curSegment.cc = curCC;
      curSegment.url = getAbsoluteUrl(line, parentUrl);
      if (curKey)
        curSegment.key = curKey.clone(curSN);
      if (curInitSegment)
        curSegment.initSegment = curInitSegment;
      media.segments.push(curSegment);
      curSegment = new MediaSegment(parentUrl);
      curSN++;
      continue;
    }
    var tag = parseTag(line);
    if (!tag)
      continue;
    var _tag = _slicedToArray(tag, 2), name = _tag[0], data = _tag[1];
    switch (name) {
      case "VERSION":
        media.version = parseInt(data);
        break;
      case "PLAYLIST-TYPE":
        media.type = data === null || data === void 0 ? void 0 : data.toUpperCase();
        break;
      case "TARGETDURATION":
        media.targetDuration = parseFloat(data);
        break;
      case "PART-INF":
        {
          if (useLowLatency) {
            media.lowLatency = true;
          }
          var attr = parseAttr(data);
          if (attr["PART-TARGET"]) {
            media.partTargetDuration = parseFloat(attr["PART-TARGET"]);
          }
        }
        break;
      case "SERVER-CONTROL":
        {
          var _attr = parseAttr(data);
          media.canBlockReload = _attr["CAN-BLOCK-RELOAD"] === "YES";
          media.partHoldBack = parseFloat(_attr["PART-HOLD-BACK"] || 0);
          media.canSkipUntil = parseFloat(_attr["CAN-SKIP-UNTIL"] || 0);
          media.canSkipDateRanges = _attr["CAN-SKIP-DATERANGES"] === "YES";
        }
        break;
      case "ENDLIST":
        {
          var _lastSegment = media.segments[media.segments.length - 1];
          if (_lastSegment) {
            _lastSegment.isLast = true;
          }
          media.live = false;
          endOfList = true;
        }
        break;
      case "MEDIA-SEQUENCE":
        curSN = media.startSN = parseInt(data);
        break;
      case "DISCONTINUITY-SEQUENCE":
        curCC = media.startCC = parseInt(data);
        break;
      case "DISCONTINUITY":
        curCC++;
        break;
      case "BYTERANGE":
        curSegment.setByteRange(data, media.segments[media.segments.length - 1]);
        break;
      case "PART":
        {
          if (!media.lowLatency)
            break;
          var _attr2 = parseAttr(data);
          curSegment.duration = parseFloat(_attr2["DURATION"]);
          curSegment.independent = _attr2["INDEPENDENT"] === "YES";
          curSegment.sn = curSN;
          curSegment.cc = curCC;
          curSegment.partIndex = partSegmentIndex;
          curSegment.start = totalDuration;
          curSegment.duration = parseFloat(_attr2["DURATION"]);
          totalDuration += curSegment.duration;
          curSegment.url = getAbsoluteUrl(_attr2["URI"], parentUrl);
          if (curKey)
            curSegment.key = curKey.clone(curSN);
          if (curInitSegment)
            curSegment.initSegment = curInitSegment;
          media.segments.push(curSegment);
          curSegment = new MediaSegment(parentUrl);
          partSegmentIndex++;
        }
        break;
      case "PRELOAD-HINT":
        break;
      case "PROGRAM-DATE-TIME":
        curSegment.dataTime = data;
        break;
      case "EXTINF":
        {
          if (media.lowLatency) {
            partSegmentIndex = 0;
            break;
          }
          var _data$split = data.split(","), _data$split2 = _slicedToArray(_data$split, 2), duration = _data$split2[0], title = _data$split2[1];
          curSegment.start = totalDuration;
          curSegment.duration = parseFloat(duration);
          totalDuration += curSegment.duration;
          curSegment.title = title;
        }
        break;
      case "KEY":
        {
          var _attr3 = parseAttr(data);
          if (_attr3.METHOD === "NONE") {
            curKey = null;
            break;
          }
          curKey = new MediaSegmentKey();
          curKey.method = _attr3.METHOD;
          curKey.url = /^blob:/.test(_attr3.URI) ? _attr3.URI : getAbsoluteUrl(_attr3.URI, parentUrl);
          curKey.keyFormat = _attr3.KEYFORMAT || "identity";
          curKey.keyFormatVersions = _attr3.KEYFORMATVERSIONS;
          if (!curKey.isSupported()) {
            throw new Error("encrypt ".concat(_attr3.METHOD, "/").concat(_attr3.KEYFORMAT, " is not supported"));
          }
          if (_attr3.IV) {
            var str = _attr3.IV.slice(2);
            str = (str.length & 1 ? "0" : "") + str;
            curKey.iv = new Uint8Array(str.length / 2);
            for (var i = 0, l = str.length / 2; i < l; i++) {
              curKey.iv[i] = parseInt(str.slice(i * 2, i * 2 + 2), 16);
            }
          }
        }
        break;
      case "MAP":
        {
          var _attr4 = parseAttr(data);
          curSegment.url = getAbsoluteUrl(_attr4.URI, parentUrl);
          if (_attr4.BYTERANGE)
            curSegment.setByteRange(_attr4.BYTERANGE);
          curSegment.isInitSegment = true;
          curSegment.sn = 0;
          if (curKey) {
            curSegment.key = curKey.clone(0);
          }
          curInitSegment = curSegment;
          curSegment = new MediaSegment(parentUrl);
        }
        break;
    }
  }
  media.segments = media.segments.filter(function(x) {
    return x.duration !== 0;
  });
  var lastSegment = media.segments[media.segments.length - 1];
  if (lastSegment) {
    media.endSN = lastSegment.sn;
    media.endPartIndex = lastSegment.partIndex;
    if (endOfList && !lastSegment.isLast) {
      lastSegment.isLast = true;
    }
  }
  media.totalDuration = totalDuration;
  media.endCC = curCC;
  return media;
}
export { parseMediaPlaylist };
