import { createClass as _createClass, classCallCheck as _classCallCheck, defineProperty as _defineProperty } from "../../_virtual/_rollupPluginBabelHelpers.js";
import { Logger } from "xgplayer-streaming-shared";
var logger = new Logger("playlist");
var Stream = /* @__PURE__ */ function() {
  function Stream2(playlist, audioPlaylist, subtitlePlaylist) {
    _classCallCheck(this, Stream2);
    _defineProperty(this, "live", void 0);
    _defineProperty(this, "id", 0);
    _defineProperty(this, "bitrate", 0);
    _defineProperty(this, "width", 0);
    _defineProperty(this, "height", 0);
    _defineProperty(this, "name", "");
    _defineProperty(this, "url", "");
    _defineProperty(this, "audioCodec", "");
    _defineProperty(this, "videoCodec", "");
    _defineProperty(this, "textCodec", "");
    _defineProperty(this, "startCC", 0);
    _defineProperty(this, "endCC", 0);
    _defineProperty(this, "startSN", 0);
    _defineProperty(this, "endSN", -1);
    _defineProperty(this, "totalDuration", 0);
    _defineProperty(this, "targetDuration", 0);
    _defineProperty(this, "partTargetDuration", 0);
    _defineProperty(this, "canSkipUntil", 0);
    _defineProperty(this, "canSkipDateRanges", false);
    _defineProperty(this, "skippedSegments", 0);
    _defineProperty(this, "canBlockReload", false);
    _defineProperty(this, "partHoldBack", 0);
    _defineProperty(this, "lowLatency", false);
    _defineProperty(this, "endPartIndex", 0);
    _defineProperty(this, "snDiff", null);
    _defineProperty(this, "segments", []);
    _defineProperty(this, "audioStreams", []);
    _defineProperty(this, "subtitleStreams", []);
    _defineProperty(this, "closedCaptions", []);
    _defineProperty(this, "currentAudioStream", null);
    _defineProperty(this, "currentSubtitleStream", null);
    this.update(this._setLLPlaybackPoint(playlist), audioPlaylist, subtitlePlaylist);
  }
  _createClass(Stream2, [{
    key: "lastSegment",
    get: function get() {
      if (this.segments.length) {
        return this.segments[this.segments.length - 1];
      }
      return null;
    }
  }, {
    key: "segmentDuration",
    get: function get() {
      var _this$segments$;
      return this.targetDuration || ((_this$segments$ = this.segments[0]) === null || _this$segments$ === void 0 ? void 0 : _this$segments$.duration) || 0;
    }
  }, {
    key: "liveEdge",
    get: function get() {
      return this.endTime;
    },
    set: function set(end) {
      this.endTime = end;
    }
  }, {
    key: "endTime",
    get: function get() {
      var _this$lastSegment;
      return ((_this$lastSegment = this.lastSegment) === null || _this$lastSegment === void 0 ? void 0 : _this$lastSegment.end) || 0;
    },
    set: function set(end) {
      var lastSeg = this.lastSegment;
      if (lastSeg)
        lastSeg.duration = end - lastSeg.start;
    }
  }, {
    key: "currentSubtitleEndSn",
    get: function get() {
      var _this$currentSubtitle;
      return ((_this$currentSubtitle = this.currentSubtitleStream) === null || _this$currentSubtitle === void 0 ? void 0 : _this$currentSubtitle.endSN) || 0;
    }
  }, {
    key: "clearOldSegment",
    value: function clearOldSegment(startTime, pointer) {
      if (this.currentAudioStream) {
        this._clearSegments(startTime, pointer);
      }
      return this._clearSegments(startTime, pointer);
    }
  }, {
    key: "getAudioSegment",
    value: function getAudioSegment(seg) {
      if (!seg || !this.currentAudioStream)
        return;
      var sn = seg.sn - this.snDiff;
      return this.currentAudioStream.segments.find(function(x) {
        return x.sn === sn;
      });
    }
  }, {
    key: "update",
    value: function update(playlist, audioPlaylist) {
      this.url = playlist.url;
      if (Array.isArray(playlist.segments)) {
        if (this.live === null || this.live === void 0)
          this.live = playlist.live;
        this._updateSegments(playlist, this);
        this.startCC = playlist.startCC;
        this.endCC = playlist.endCC;
        this.startSN = playlist.startSN;
        this.endSN = playlist.endSN || -1;
        this.totalDuration = playlist.totalDuration;
        this.targetDuration = playlist.targetDuration;
        this.live = playlist.live;
        this.lowLatency = playlist.lowLatency;
        this.canBlockReload = playlist.canBlockReload;
        this.canSkipDateRanges = playlist.canSkipDateRanges;
        this.canSkipUntil = playlist.canSkipUntil;
        this.partHoldBack = playlist.partHoldBack;
        this.partTargetDuration = playlist.partTargetDuration;
        this.skippedSegments = playlist.skippedSegments;
        this.endPartIndex = playlist.endPartIndex;
        if (audioPlaylist && this.currentAudioStream && Array.isArray(audioPlaylist.segments)) {
          this._updateSegments(audioPlaylist, this.currentAudioStream);
          if ((this.snDiff === null || this.snDiff === void 0) && playlist.segments.length && audioPlaylist.segments.length) {
            this.snDiff = playlist.segments[0].sn - audioPlaylist.segments[0].sn;
          }
        }
      } else {
        this.id = playlist.id;
        this.bitrate = playlist.bitrate;
        this.width = playlist.width;
        this.height = playlist.height;
        this.name = playlist.name;
        this.audioCodec = playlist.audioCodec;
        this.videoCodec = playlist.videoCodec;
        this.textCodec = playlist.textCodec;
        this.audioStreams = playlist.audioStreams;
        this.subtitleStreams = playlist.subtitleStreams;
        if (!this.currentAudioStream && this.audioStreams.length) {
          this.currentAudioStream = this.audioStreams.find(function(x) {
            return x.default;
          }) || this.audioStreams[0];
        }
        if (!this.currentSubtitleStream && this.subtitleStreams.length) {
          this.currentSubtitleStream = this.subtitleStreams.find(function(x) {
            return x.default;
          }) || this.subtitleStreams[0];
        }
      }
    }
  }, {
    key: "updateSubtitle",
    value: function updateSubtitle(subtitlePlaylist) {
      var _this = this;
      if (!(subtitlePlaylist && this.currentSubtitleStream && Array.isArray(subtitlePlaylist.segments)))
        return;
      var newSegs = this._updateSegments(subtitlePlaylist, this.currentSubtitleStream);
      var segs = this.currentSubtitleStream.segments;
      if (segs.length > 100) {
        this.currentSubtitleStream.segments = segs.slice(100);
      }
      if (!newSegs)
        return;
      return newSegs.map(function(x) {
        return {
          sn: x.sn,
          url: x.url,
          duration: x.duration,
          start: x.start,
          end: x.end,
          lang: _this.currentSubtitleStream.lang
        };
      });
    }
  }, {
    key: "switchSubtitle",
    value: function switchSubtitle(lang) {
      var toSwitch = this.subtitleStreams.find(function(x) {
        return x.lang === lang;
      });
      var origin = this.currentSubtitleStream;
      if (toSwitch) {
        this.currentSubtitleStream = toSwitch;
        origin.segments = [];
      }
    }
  }, {
    key: "_setLLPlaybackPoint",
    value: function _setLLPlaybackPoint(playlist) {
      if (!playlist.lowLatency || !playlist.segments.length)
        return playlist;
      var maxStartPoint = playlist.totalDuration - playlist.partHoldBack;
      var segs = playlist.segments;
      var index = 0;
      for (var i = 0, l = segs.length; i < l; i++) {
        if (segs[i].start <= maxStartPoint && segs[i].independent) {
          index = i;
        }
      }
      var usefulSegs = segs.slice(index);
      var endTime = 0;
      usefulSegs.forEach(function(s) {
        s.start = endTime;
        endTime = s.end;
      });
      playlist.segments = usefulSegs;
      playlist.totalDuration = endTime;
      playlist.startSN = usefulSegs[0].sn;
      playlist.startCC = usefulSegs[0].cc;
      logger.log("set ll-hls playback point: SN=".concat(playlist.startSN, " partIndex=").concat(usefulSegs[0].partIndex, ", duration=").concat(endTime));
      return playlist;
    }
  }, {
    key: "_clearSegments",
    value: function _clearSegments(startTime, pointer) {
      var sliceStart = 0;
      var segments = this.segments;
      for (var i = 0, l = segments.length; i < l; i++) {
        if (segments[i].end >= startTime) {
          sliceStart = i;
          break;
        }
      }
      if (sliceStart > pointer) {
        sliceStart = pointer;
      }
      if (sliceStart) {
        this.segments = this.segments.slice(sliceStart);
        if (this.currentAudioStream) {
          this.currentAudioStream.segments = this.currentAudioStream.segments.slice(sliceStart);
        }
      }
      return pointer - sliceStart;
    }
  }, {
    key: "_updateSegments",
    value: function _updateSegments(playlist, segObj) {
      var segments = segObj.segments;
      if (this.live) {
        var _endSeg$sn;
        var lowLatency = playlist.lowLatency;
        var endSeg = segments[segments.length - 1];
        var endSN = (_endSeg$sn = endSeg === null || endSeg === void 0 ? void 0 : endSeg.sn) !== null && _endSeg$sn !== void 0 ? _endSeg$sn : -1;
        var endPartIndex = (endSeg === null || endSeg === void 0 ? void 0 : endSeg.partIndex) || 0;
        var hasNew = endSN < playlist.endSN && playlist.segments.length;
        if (lowLatency) {
          hasNew = hasNew || endPartIndex < playlist.endPartIndex;
        }
        if (hasNew) {
          logger.log("update segments: endSN:".concat(endSN, ", partIndex:").concat(endPartIndex, " --> endSN:").concat(playlist.endSN, ", partIndex:").concat(playlist.endPartIndex));
          var index = playlist.segments.findIndex(function(x) {
            return x.sn === endSN && x.partIndex === endPartIndex;
          });
          var toAppend = index < 0 ? playlist.segments : playlist.segments.slice(index + 1);
          if (segments.length && toAppend.length) {
            var endTime = endSeg.end;
            var endTimeBeforeAppend = endTime;
            toAppend.forEach(function(seg) {
              seg.start = endTime;
              endTime = seg.end;
            });
            logger.log("liveEdge: ".concat(endTimeBeforeAppend, " -> ").concat(endTime));
            var lastCC = (endSeg === null || endSeg === void 0 ? void 0 : endSeg.cc) || -1;
            if (lastCC > toAppend[0].cc) {
              toAppend.forEach(function(seg) {
                return seg.cc += lastCC;
              });
            }
          }
          segObj.endSN = playlist.endSN;
          segObj.segments = segments.concat(toAppend);
          return toAppend;
        }
      } else {
        segObj.segments = playlist.segments;
      }
    }
  }]);
  return Stream2;
}();
export { Stream };
