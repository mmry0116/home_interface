import { createClass as _createClass, classCallCheck as _classCallCheck, defineProperty as _defineProperty, objectSpread2 as _objectSpread2, asyncToGenerator as _asyncToGenerator, regeneratorRuntime as _regeneratorRuntime, slicedToArray as _slicedToArray } from "../../_virtual/_rollupPluginBabelHelpers.js";
import { EVENT, StreamingError, BandwidthService, NetLoader } from "xgplayer-streaming-shared";
var SegmentLoader = /* @__PURE__ */ function() {
  function SegmentLoader2(hls) {
    var _this = this;
    _classCallCheck(this, SegmentLoader2);
    _defineProperty(this, "error", null);
    _defineProperty(this, "_emitOnLoaded", function(res, url) {
      var data = res.data, response = res.response, options = res.options;
      var _ref = options || {}, firstByteTime = _ref.firstByteTime, startTime = _ref.startTime, endTime = _ref.endTime, contentLength = _ref.contentLength;
      var time = endTime - startTime;
      _this._bandwidthService.addRecord(contentLength || data.byteLength, time);
      _this.hls.emit(EVENT.SPEED, {
        time,
        byteLength: contentLength,
        url
      });
      _this.hls.emit(EVENT.LOAD_COMPLETE, {
        url,
        elapsed: time || 0
      });
      _this.hls.emit(EVENT.TTFB, {
        url,
        responseUrl: response.url,
        elapsed: firstByteTime - startTime
      });
      _this.hls.emit(EVENT.LOAD_RESPONSE_HEADERS, {
        headers: response.headers,
        url
      });
    });
    _defineProperty(this, "_onLoaderRetry", function(error, retryTime) {
      _this.hls.emit(EVENT.LOAD_RETRY, {
        error: StreamingError.network(error),
        retryTime
      });
    });
    this.hls = hls;
    this._bandwidthService = new BandwidthService();
    this._mapCache = {};
    this._keyCache = {};
    var _this$hls$config = this.hls.config, retryCount = _this$hls$config.retryCount, retryDelay = _this$hls$config.retryDelay, loadTimeout = _this$hls$config.loadTimeout, fetchOptions = _this$hls$config.fetchOptions;
    this._segmentLoader = new NetLoader(_objectSpread2(_objectSpread2({}, fetchOptions), {}, {
      responseType: "arraybuffer",
      retry: retryCount,
      retryDelay,
      timeout: loadTimeout,
      onRetryError: this._onLoaderRetry
    }));
    this._audioSegmentLoader = new NetLoader(_objectSpread2(_objectSpread2({}, fetchOptions), {}, {
      responseType: "arraybuffer",
      retry: retryCount,
      retryDelay,
      timeout: loadTimeout,
      onRetryError: this._onLoaderRetry
    }));
    this._keyLoader = new NetLoader(_objectSpread2(_objectSpread2({}, fetchOptions), {}, {
      responseType: "arraybuffer",
      retry: retryCount,
      retryDelay,
      timeout: loadTimeout,
      onRetryError: this._onLoaderRetry
    }));
  }
  _createClass(SegmentLoader2, [{
    key: "speedInfo",
    value: function speedInfo() {
      return {
        speed: this._bandwidthService.getLatestSpeed(),
        avgSpeed: this._bandwidthService.getAvgSpeed()
      };
    }
  }, {
    key: "load",
    value: function load(seg, audioSeg, loadInit) {
      var loadAudioInit = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : loadInit;
      var toLoad = [];
      if (seg)
        toLoad[0] = this.loadVideoSegment(seg, loadInit);
      if (audioSeg)
        toLoad[1] = this.loadAudioSegment(audioSeg, loadAudioInit);
      return Promise.all(toLoad);
    }
  }, {
    key: "loadVideoSegment",
    value: function loadVideoSegment(seg, loadInit) {
      return this._loadSegment(this._segmentLoader, seg, loadInit);
    }
  }, {
    key: "loadAudioSegment",
    value: function loadAudioSegment(seg, loadInit) {
      return this._loadSegment(this._audioSegmentLoader, seg, loadInit);
    }
  }, {
    key: "_loadSegment",
    value: function() {
      var _loadSegment2 = _asyncToGenerator(/* @__PURE__ */ _regeneratorRuntime().mark(function _callee(segLoader, seg, loadInit) {
        var _this2 = this, _seg$key;
        var map, key, keyIv, mapKey, mapKeyIv, toLoad, _seg$initSegment$key, mapUrl, _keyUrl, keyUrl, _yield$Promise$all, _yield$Promise$all2, s, data;
        return _regeneratorRuntime().wrap(function _callee$(_context) {
          while (1)
            switch (_context.prev = _context.next) {
              case 0:
                toLoad = [];
                this.hls.emit(EVENT.LOAD_START, {
                  url: seg.url
                });
                toLoad[0] = segLoader.load(seg.url);
                if (loadInit && seg.initSegment) {
                  mapUrl = seg.initSegment.url;
                  map = this._mapCache[mapUrl];
                  if (!map) {
                    this.hls.emit(EVENT.LOAD_START, {
                      url: mapUrl
                    });
                    toLoad[1] = segLoader.load(mapUrl).then(function(r) {
                      if (r) {
                        var l = Object.keys(_this2._mapCache);
                        if (l > 30)
                          _this2._mapCache = {};
                        map = _this2._mapCache[mapUrl] = r.data;
                        _this2._emitOnLoaded(r, mapUrl);
                      }
                    });
                  }
                  _keyUrl = (_seg$initSegment$key = seg.initSegment.key) === null || _seg$initSegment$key === void 0 ? void 0 : _seg$initSegment$key.url;
                  if (_keyUrl) {
                    mapKeyIv = seg.initSegment.key.iv;
                    mapKey = this._keyCache[_keyUrl];
                    if (!mapKey) {
                      this.hls.emit(EVENT.LOAD_START, {
                        url: _keyUrl
                      });
                      toLoad[2] = this._keyLoader.load(_keyUrl).then(function(r) {
                        if (r) {
                          mapKey = _this2._keyCache[_keyUrl] = r.data;
                          _this2._emitOnLoaded(r, _keyUrl);
                        }
                      });
                    }
                  }
                }
                keyUrl = (_seg$key = seg.key) === null || _seg$key === void 0 ? void 0 : _seg$key.url;
                if (keyUrl && seg.key.isSegmentEncrypted()) {
                  keyIv = seg.key.iv;
                  key = this._keyCache[keyUrl];
                  if (!key) {
                    this.hls.emit(EVENT.LOAD_START, {
                      url: keyUrl
                    });
                    toLoad[3] = this._keyLoader.load(keyUrl).then(function(r) {
                      if (r) {
                        key = _this2._keyCache[keyUrl] = r.data;
                        _this2._emitOnLoaded(r, keyUrl);
                      }
                    });
                  }
                }
                _context.next = 8;
                return Promise.all(toLoad);
              case 8:
                _yield$Promise$all = _context.sent;
                _yield$Promise$all2 = _slicedToArray(_yield$Promise$all, 1);
                s = _yield$Promise$all2[0];
                if (s) {
                  _context.next = 13;
                  break;
                }
                return _context.abrupt("return");
              case 13:
                data = s.data;
                this._emitOnLoaded(s, seg.url);
                return _context.abrupt("return", {
                  data,
                  map,
                  key,
                  mapKey,
                  keyIv,
                  mapKeyIv
                });
              case 16:
              case "end":
                return _context.stop();
            }
        }, _callee, this);
      }));
      function _loadSegment(_x, _x2, _x3) {
        return _loadSegment2.apply(this, arguments);
      }
      return _loadSegment;
    }()
  }, {
    key: "reset",
    value: function reset() {
      this.error = null;
      this._mapCache = {};
      this._keyCache = {};
      this._bandwidthService.reset();
    }
  }, {
    key: "cancel",
    value: function() {
      var _cancel = _asyncToGenerator(/* @__PURE__ */ _regeneratorRuntime().mark(function _callee2() {
        return _regeneratorRuntime().wrap(function _callee2$(_context2) {
          while (1)
            switch (_context2.prev = _context2.next) {
              case 0:
                _context2.next = 2;
                return Promise.all([this._keyLoader.cancel(), this._segmentLoader.cancel(), this._audioSegmentLoader.cancel()]);
              case 2:
              case "end":
                return _context2.stop();
            }
        }, _callee2, this);
      }));
      function cancel() {
        return _cancel.apply(this, arguments);
      }
      return cancel;
    }()
  }]);
  return SegmentLoader2;
}();
export { SegmentLoader };
