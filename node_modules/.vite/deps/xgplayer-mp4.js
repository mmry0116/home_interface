import {
  BasePlugin,
  Errors,
  events_exports,
  require_eventemitter3,
  sniffer,
  util
} from "./chunk-XZQZDOFT.js";
import {
  __commonJS,
  __toESM
} from "./chunk-3EJPJMEH.js";

// node_modules/concat-typed-array/lib/concat.js
var require_concat = __commonJS({
  "node_modules/concat-typed-array/lib/concat.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = function(ResultConstructor) {
      var totalLength = 0;
      for (var _len = arguments.length, arrays = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
        arrays[_key - 1] = arguments[_key];
      }
      var _iteratorNormalCompletion = true;
      var _didIteratorError = false;
      var _iteratorError = void 0;
      try {
        for (var _iterator = arrays[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
          var arr = _step.value;
          totalLength += arr.length;
        }
      } catch (err) {
        _didIteratorError = true;
        _iteratorError = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion && _iterator.return) {
            _iterator.return();
          }
        } finally {
          if (_didIteratorError) {
            throw _iteratorError;
          }
        }
      }
      var result = new ResultConstructor(totalLength);
      var offset = 0;
      var _iteratorNormalCompletion2 = true;
      var _didIteratorError2 = false;
      var _iteratorError2 = void 0;
      try {
        for (var _iterator2 = arrays[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
          var _arr = _step2.value;
          result.set(_arr, offset);
          offset += _arr.length;
        }
      } catch (err) {
        _didIteratorError2 = true;
        _iteratorError2 = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion2 && _iterator2.return) {
            _iterator2.return();
          }
        } finally {
          if (_didIteratorError2) {
            throw _iteratorError2;
          }
        }
      }
      return result;
    };
  }
});

// node_modules/concat-typed-array/lib/index.js
var require_lib = __commonJS({
  "node_modules/concat-typed-array/lib/index.js"(exports, module) {
    "use strict";
    var _concat = require_concat();
    var _concat2 = _interopRequireDefault(_concat);
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    module.exports = _concat2.default;
  }
});

// node_modules/xgplayer-mp4/es/_virtual/_rollupPluginBabelHelpers.js
function ownKeys(object, enumerableOnly) {
  var keys = Object.keys(object);
  if (Object.getOwnPropertySymbols) {
    var symbols = Object.getOwnPropertySymbols(object);
    enumerableOnly && (symbols = symbols.filter(function(sym) {
      return Object.getOwnPropertyDescriptor(object, sym).enumerable;
    })), keys.push.apply(keys, symbols);
  }
  return keys;
}
function _objectSpread2(target) {
  for (var i = 1; i < arguments.length; i++) {
    var source = null != arguments[i] ? arguments[i] : {};
    i % 2 ? ownKeys(Object(source), true).forEach(function(key) {
      _defineProperty(target, key, source[key]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function(key) {
      Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
    });
  }
  return target;
}
function _regeneratorRuntime() {
  _regeneratorRuntime = function() {
    return exports;
  };
  var exports = {}, Op = Object.prototype, hasOwn = Op.hasOwnProperty, defineProperty = Object.defineProperty || function(obj, key, desc) {
    obj[key] = desc.value;
  }, $Symbol = "function" == typeof Symbol ? Symbol : {}, iteratorSymbol = $Symbol.iterator || "@@iterator", asyncIteratorSymbol = $Symbol.asyncIterator || "@@asyncIterator", toStringTagSymbol = $Symbol.toStringTag || "@@toStringTag";
  function define(obj, key, value) {
    return Object.defineProperty(obj, key, {
      value,
      enumerable: true,
      configurable: true,
      writable: true
    }), obj[key];
  }
  try {
    define({}, "");
  } catch (err) {
    define = function(obj, key, value) {
      return obj[key] = value;
    };
  }
  function wrap(innerFn, outerFn, self, tryLocsList) {
    var protoGenerator = outerFn && outerFn.prototype instanceof Generator ? outerFn : Generator, generator = Object.create(protoGenerator.prototype), context = new Context(tryLocsList || []);
    return defineProperty(generator, "_invoke", {
      value: makeInvokeMethod(innerFn, self, context)
    }), generator;
  }
  function tryCatch(fn, obj, arg) {
    try {
      return {
        type: "normal",
        arg: fn.call(obj, arg)
      };
    } catch (err) {
      return {
        type: "throw",
        arg: err
      };
    }
  }
  exports.wrap = wrap;
  var ContinueSentinel = {};
  function Generator() {
  }
  function GeneratorFunction() {
  }
  function GeneratorFunctionPrototype() {
  }
  var IteratorPrototype = {};
  define(IteratorPrototype, iteratorSymbol, function() {
    return this;
  });
  var getProto = Object.getPrototypeOf, NativeIteratorPrototype = getProto && getProto(getProto(values([])));
  NativeIteratorPrototype && NativeIteratorPrototype !== Op && hasOwn.call(NativeIteratorPrototype, iteratorSymbol) && (IteratorPrototype = NativeIteratorPrototype);
  var Gp = GeneratorFunctionPrototype.prototype = Generator.prototype = Object.create(IteratorPrototype);
  function defineIteratorMethods(prototype) {
    ["next", "throw", "return"].forEach(function(method) {
      define(prototype, method, function(arg) {
        return this._invoke(method, arg);
      });
    });
  }
  function AsyncIterator(generator, PromiseImpl) {
    function invoke(method, arg, resolve, reject) {
      var record = tryCatch(generator[method], generator, arg);
      if ("throw" !== record.type) {
        var result = record.arg, value = result.value;
        return value && "object" == typeof value && hasOwn.call(value, "__await") ? PromiseImpl.resolve(value.__await).then(function(value2) {
          invoke("next", value2, resolve, reject);
        }, function(err) {
          invoke("throw", err, resolve, reject);
        }) : PromiseImpl.resolve(value).then(function(unwrapped) {
          result.value = unwrapped, resolve(result);
        }, function(error) {
          return invoke("throw", error, resolve, reject);
        });
      }
      reject(record.arg);
    }
    var previousPromise;
    defineProperty(this, "_invoke", {
      value: function(method, arg) {
        function callInvokeWithMethodAndArg() {
          return new PromiseImpl(function(resolve, reject) {
            invoke(method, arg, resolve, reject);
          });
        }
        return previousPromise = previousPromise ? previousPromise.then(callInvokeWithMethodAndArg, callInvokeWithMethodAndArg) : callInvokeWithMethodAndArg();
      }
    });
  }
  function makeInvokeMethod(innerFn, self, context) {
    var state = "suspendedStart";
    return function(method, arg) {
      if ("executing" === state)
        throw new Error("Generator is already running");
      if ("completed" === state) {
        if ("throw" === method)
          throw arg;
        return doneResult();
      }
      for (context.method = method, context.arg = arg; ; ) {
        var delegate = context.delegate;
        if (delegate) {
          var delegateResult = maybeInvokeDelegate(delegate, context);
          if (delegateResult) {
            if (delegateResult === ContinueSentinel)
              continue;
            return delegateResult;
          }
        }
        if ("next" === context.method)
          context.sent = context._sent = context.arg;
        else if ("throw" === context.method) {
          if ("suspendedStart" === state)
            throw state = "completed", context.arg;
          context.dispatchException(context.arg);
        } else
          "return" === context.method && context.abrupt("return", context.arg);
        state = "executing";
        var record = tryCatch(innerFn, self, context);
        if ("normal" === record.type) {
          if (state = context.done ? "completed" : "suspendedYield", record.arg === ContinueSentinel)
            continue;
          return {
            value: record.arg,
            done: context.done
          };
        }
        "throw" === record.type && (state = "completed", context.method = "throw", context.arg = record.arg);
      }
    };
  }
  function maybeInvokeDelegate(delegate, context) {
    var methodName = context.method, method = delegate.iterator[methodName];
    if (void 0 === method)
      return context.delegate = null, "throw" === methodName && delegate.iterator.return && (context.method = "return", context.arg = void 0, maybeInvokeDelegate(delegate, context), "throw" === context.method) || "return" !== methodName && (context.method = "throw", context.arg = new TypeError("The iterator does not provide a '" + methodName + "' method")), ContinueSentinel;
    var record = tryCatch(method, delegate.iterator, context.arg);
    if ("throw" === record.type)
      return context.method = "throw", context.arg = record.arg, context.delegate = null, ContinueSentinel;
    var info = record.arg;
    return info ? info.done ? (context[delegate.resultName] = info.value, context.next = delegate.nextLoc, "return" !== context.method && (context.method = "next", context.arg = void 0), context.delegate = null, ContinueSentinel) : info : (context.method = "throw", context.arg = new TypeError("iterator result is not an object"), context.delegate = null, ContinueSentinel);
  }
  function pushTryEntry(locs) {
    var entry = {
      tryLoc: locs[0]
    };
    1 in locs && (entry.catchLoc = locs[1]), 2 in locs && (entry.finallyLoc = locs[2], entry.afterLoc = locs[3]), this.tryEntries.push(entry);
  }
  function resetTryEntry(entry) {
    var record = entry.completion || {};
    record.type = "normal", delete record.arg, entry.completion = record;
  }
  function Context(tryLocsList) {
    this.tryEntries = [{
      tryLoc: "root"
    }], tryLocsList.forEach(pushTryEntry, this), this.reset(true);
  }
  function values(iterable) {
    if (iterable) {
      var iteratorMethod = iterable[iteratorSymbol];
      if (iteratorMethod)
        return iteratorMethod.call(iterable);
      if ("function" == typeof iterable.next)
        return iterable;
      if (!isNaN(iterable.length)) {
        var i = -1, next = function next2() {
          for (; ++i < iterable.length; )
            if (hasOwn.call(iterable, i))
              return next2.value = iterable[i], next2.done = false, next2;
          return next2.value = void 0, next2.done = true, next2;
        };
        return next.next = next;
      }
    }
    return {
      next: doneResult
    };
  }
  function doneResult() {
    return {
      value: void 0,
      done: true
    };
  }
  return GeneratorFunction.prototype = GeneratorFunctionPrototype, defineProperty(Gp, "constructor", {
    value: GeneratorFunctionPrototype,
    configurable: true
  }), defineProperty(GeneratorFunctionPrototype, "constructor", {
    value: GeneratorFunction,
    configurable: true
  }), GeneratorFunction.displayName = define(GeneratorFunctionPrototype, toStringTagSymbol, "GeneratorFunction"), exports.isGeneratorFunction = function(genFun) {
    var ctor = "function" == typeof genFun && genFun.constructor;
    return !!ctor && (ctor === GeneratorFunction || "GeneratorFunction" === (ctor.displayName || ctor.name));
  }, exports.mark = function(genFun) {
    return Object.setPrototypeOf ? Object.setPrototypeOf(genFun, GeneratorFunctionPrototype) : (genFun.__proto__ = GeneratorFunctionPrototype, define(genFun, toStringTagSymbol, "GeneratorFunction")), genFun.prototype = Object.create(Gp), genFun;
  }, exports.awrap = function(arg) {
    return {
      __await: arg
    };
  }, defineIteratorMethods(AsyncIterator.prototype), define(AsyncIterator.prototype, asyncIteratorSymbol, function() {
    return this;
  }), exports.AsyncIterator = AsyncIterator, exports.async = function(innerFn, outerFn, self, tryLocsList, PromiseImpl) {
    void 0 === PromiseImpl && (PromiseImpl = Promise);
    var iter = new AsyncIterator(wrap(innerFn, outerFn, self, tryLocsList), PromiseImpl);
    return exports.isGeneratorFunction(outerFn) ? iter : iter.next().then(function(result) {
      return result.done ? result.value : iter.next();
    });
  }, defineIteratorMethods(Gp), define(Gp, toStringTagSymbol, "Generator"), define(Gp, iteratorSymbol, function() {
    return this;
  }), define(Gp, "toString", function() {
    return "[object Generator]";
  }), exports.keys = function(val) {
    var object = Object(val), keys = [];
    for (var key in object)
      keys.push(key);
    return keys.reverse(), function next() {
      for (; keys.length; ) {
        var key2 = keys.pop();
        if (key2 in object)
          return next.value = key2, next.done = false, next;
      }
      return next.done = true, next;
    };
  }, exports.values = values, Context.prototype = {
    constructor: Context,
    reset: function(skipTempReset) {
      if (this.prev = 0, this.next = 0, this.sent = this._sent = void 0, this.done = false, this.delegate = null, this.method = "next", this.arg = void 0, this.tryEntries.forEach(resetTryEntry), !skipTempReset)
        for (var name in this)
          "t" === name.charAt(0) && hasOwn.call(this, name) && !isNaN(+name.slice(1)) && (this[name] = void 0);
    },
    stop: function() {
      this.done = true;
      var rootRecord = this.tryEntries[0].completion;
      if ("throw" === rootRecord.type)
        throw rootRecord.arg;
      return this.rval;
    },
    dispatchException: function(exception) {
      if (this.done)
        throw exception;
      var context = this;
      function handle(loc, caught) {
        return record.type = "throw", record.arg = exception, context.next = loc, caught && (context.method = "next", context.arg = void 0), !!caught;
      }
      for (var i = this.tryEntries.length - 1; i >= 0; --i) {
        var entry = this.tryEntries[i], record = entry.completion;
        if ("root" === entry.tryLoc)
          return handle("end");
        if (entry.tryLoc <= this.prev) {
          var hasCatch = hasOwn.call(entry, "catchLoc"), hasFinally = hasOwn.call(entry, "finallyLoc");
          if (hasCatch && hasFinally) {
            if (this.prev < entry.catchLoc)
              return handle(entry.catchLoc, true);
            if (this.prev < entry.finallyLoc)
              return handle(entry.finallyLoc);
          } else if (hasCatch) {
            if (this.prev < entry.catchLoc)
              return handle(entry.catchLoc, true);
          } else {
            if (!hasFinally)
              throw new Error("try statement without catch or finally");
            if (this.prev < entry.finallyLoc)
              return handle(entry.finallyLoc);
          }
        }
      }
    },
    abrupt: function(type, arg) {
      for (var i = this.tryEntries.length - 1; i >= 0; --i) {
        var entry = this.tryEntries[i];
        if (entry.tryLoc <= this.prev && hasOwn.call(entry, "finallyLoc") && this.prev < entry.finallyLoc) {
          var finallyEntry = entry;
          break;
        }
      }
      finallyEntry && ("break" === type || "continue" === type) && finallyEntry.tryLoc <= arg && arg <= finallyEntry.finallyLoc && (finallyEntry = null);
      var record = finallyEntry ? finallyEntry.completion : {};
      return record.type = type, record.arg = arg, finallyEntry ? (this.method = "next", this.next = finallyEntry.finallyLoc, ContinueSentinel) : this.complete(record);
    },
    complete: function(record, afterLoc) {
      if ("throw" === record.type)
        throw record.arg;
      return "break" === record.type || "continue" === record.type ? this.next = record.arg : "return" === record.type ? (this.rval = this.arg = record.arg, this.method = "return", this.next = "end") : "normal" === record.type && afterLoc && (this.next = afterLoc), ContinueSentinel;
    },
    finish: function(finallyLoc) {
      for (var i = this.tryEntries.length - 1; i >= 0; --i) {
        var entry = this.tryEntries[i];
        if (entry.finallyLoc === finallyLoc)
          return this.complete(entry.completion, entry.afterLoc), resetTryEntry(entry), ContinueSentinel;
      }
    },
    catch: function(tryLoc) {
      for (var i = this.tryEntries.length - 1; i >= 0; --i) {
        var entry = this.tryEntries[i];
        if (entry.tryLoc === tryLoc) {
          var record = entry.completion;
          if ("throw" === record.type) {
            var thrown = record.arg;
            resetTryEntry(entry);
          }
          return thrown;
        }
      }
      throw new Error("illegal catch attempt");
    },
    delegateYield: function(iterable, resultName, nextLoc) {
      return this.delegate = {
        iterator: values(iterable),
        resultName,
        nextLoc
      }, "next" === this.method && (this.arg = void 0), ContinueSentinel;
    }
  }, exports;
}
function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) {
  try {
    var info = gen[key](arg);
    var value = info.value;
  } catch (error) {
    reject(error);
    return;
  }
  if (info.done) {
    resolve(value);
  } else {
    Promise.resolve(value).then(_next, _throw);
  }
}
function _asyncToGenerator(fn) {
  return function() {
    var self = this, args = arguments;
    return new Promise(function(resolve, reject) {
      var gen = fn.apply(self, args);
      function _next(value) {
        asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value);
      }
      function _throw(err) {
        asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err);
      }
      _next(void 0);
    });
  };
}
function _classCallCheck(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}
function _defineProperties(target, props) {
  for (var i = 0; i < props.length; i++) {
    var descriptor = props[i];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor)
      descriptor.writable = true;
    Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor);
  }
}
function _createClass(Constructor, protoProps, staticProps) {
  if (protoProps)
    _defineProperties(Constructor.prototype, protoProps);
  if (staticProps)
    _defineProperties(Constructor, staticProps);
  Object.defineProperty(Constructor, "prototype", {
    writable: false
  });
  return Constructor;
}
function _defineProperty(obj, key, value) {
  key = _toPropertyKey(key);
  if (key in obj) {
    Object.defineProperty(obj, key, {
      value,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key] = value;
  }
  return obj;
}
function _inherits(subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function");
  }
  subClass.prototype = Object.create(superClass && superClass.prototype, {
    constructor: {
      value: subClass,
      writable: true,
      configurable: true
    }
  });
  Object.defineProperty(subClass, "prototype", {
    writable: false
  });
  if (superClass)
    _setPrototypeOf(subClass, superClass);
}
function _getPrototypeOf(o) {
  _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf22(o2) {
    return o2.__proto__ || Object.getPrototypeOf(o2);
  };
  return _getPrototypeOf(o);
}
function _setPrototypeOf(o, p) {
  _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf22(o2, p2) {
    o2.__proto__ = p2;
    return o2;
  };
  return _setPrototypeOf(o, p);
}
function _isNativeReflectConstruct() {
  if (typeof Reflect === "undefined" || !Reflect.construct)
    return false;
  if (Reflect.construct.sham)
    return false;
  if (typeof Proxy === "function")
    return true;
  try {
    Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
    }));
    return true;
  } catch (e) {
    return false;
  }
}
function _assertThisInitialized(self) {
  if (self === void 0) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }
  return self;
}
function _possibleConstructorReturn(self, call) {
  if (call && (typeof call === "object" || typeof call === "function")) {
    return call;
  } else if (call !== void 0) {
    throw new TypeError("Derived constructors may only return object or undefined");
  }
  return _assertThisInitialized(self);
}
function _createSuper(Derived) {
  var hasNativeReflectConstruct = _isNativeReflectConstruct();
  return function _createSuperInternal() {
    var Super = _getPrototypeOf(Derived), result;
    if (hasNativeReflectConstruct) {
      var NewTarget = _getPrototypeOf(this).constructor;
      result = Reflect.construct(Super, arguments, NewTarget);
    } else {
      result = Super.apply(this, arguments);
    }
    return _possibleConstructorReturn(this, result);
  };
}
function _toPrimitive(input, hint) {
  if (typeof input !== "object" || input === null)
    return input;
  var prim = input[Symbol.toPrimitive];
  if (prim !== void 0) {
    var res = prim.call(input, hint || "default");
    if (typeof res !== "object")
      return res;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return (hint === "string" ? String : Number)(input);
}
function _toPropertyKey(arg) {
  var key = _toPrimitive(arg, "string");
  return typeof key === "symbol" ? key : String(key);
}

// node_modules/xgplayer-mp4/es/mp4.js
var import_eventemitter37 = __toESM(require_eventemitter3());
var import_concat_typed_array = __toESM(require_lib());

// node_modules/xgplayer-transmuxer/es/_virtual/_rollupPluginBabelHelpers.js
function _iterableToArrayLimit(arr, i) {
  var _i = null == arr ? null : "undefined" != typeof Symbol && arr[Symbol.iterator] || arr["@@iterator"];
  if (null != _i) {
    var _s, _e, _x, _r, _arr = [], _n = true, _d = false;
    try {
      if (_x = (_i = _i.call(arr)).next, 0 === i) {
        if (Object(_i) !== _i)
          return;
        _n = false;
      } else
        for (; !(_n = (_s = _x.call(_i)).done) && (_arr.push(_s.value), _arr.length !== i); _n = true)
          ;
    } catch (err) {
      _d = true, _e = err;
    } finally {
      try {
        if (!_n && null != _i.return && (_r = _i.return(), Object(_r) !== _r))
          return;
      } finally {
        if (_d)
          throw _e;
      }
    }
    return _arr;
  }
}
function _classCallCheck2(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}
function _defineProperties2(target, props) {
  for (var i = 0; i < props.length; i++) {
    var descriptor = props[i];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor)
      descriptor.writable = true;
    Object.defineProperty(target, _toPropertyKey2(descriptor.key), descriptor);
  }
}
function _createClass2(Constructor, protoProps, staticProps) {
  if (protoProps)
    _defineProperties2(Constructor.prototype, protoProps);
  if (staticProps)
    _defineProperties2(Constructor, staticProps);
  Object.defineProperty(Constructor, "prototype", {
    writable: false
  });
  return Constructor;
}
function _defineProperty2(obj, key, value) {
  key = _toPropertyKey2(key);
  if (key in obj) {
    Object.defineProperty(obj, key, {
      value,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key] = value;
  }
  return obj;
}
function _inherits2(subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function");
  }
  subClass.prototype = Object.create(superClass && superClass.prototype, {
    constructor: {
      value: subClass,
      writable: true,
      configurable: true
    }
  });
  Object.defineProperty(subClass, "prototype", {
    writable: false
  });
  if (superClass)
    _setPrototypeOf2(subClass, superClass);
}
function _getPrototypeOf2(o) {
  _getPrototypeOf2 = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf22(o2) {
    return o2.__proto__ || Object.getPrototypeOf(o2);
  };
  return _getPrototypeOf2(o);
}
function _setPrototypeOf2(o, p) {
  _setPrototypeOf2 = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf22(o2, p2) {
    o2.__proto__ = p2;
    return o2;
  };
  return _setPrototypeOf2(o, p);
}
function _isNativeReflectConstruct2() {
  if (typeof Reflect === "undefined" || !Reflect.construct)
    return false;
  if (Reflect.construct.sham)
    return false;
  if (typeof Proxy === "function")
    return true;
  try {
    Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
    }));
    return true;
  } catch (e) {
    return false;
  }
}
function _assertThisInitialized2(self) {
  if (self === void 0) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }
  return self;
}
function _possibleConstructorReturn2(self, call) {
  if (call && (typeof call === "object" || typeof call === "function")) {
    return call;
  } else if (call !== void 0) {
    throw new TypeError("Derived constructors may only return object or undefined");
  }
  return _assertThisInitialized2(self);
}
function _createSuper2(Derived) {
  var hasNativeReflectConstruct = _isNativeReflectConstruct2();
  return function _createSuperInternal() {
    var Super = _getPrototypeOf2(Derived), result;
    if (hasNativeReflectConstruct) {
      var NewTarget = _getPrototypeOf2(this).constructor;
      result = Reflect.construct(Super, arguments, NewTarget);
    } else {
      result = Super.apply(this, arguments);
    }
    return _possibleConstructorReturn2(this, result);
  };
}
function _slicedToArray(arr, i) {
  return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest();
}
function _toConsumableArray(arr) {
  return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread();
}
function _arrayWithoutHoles(arr) {
  if (Array.isArray(arr))
    return _arrayLikeToArray(arr);
}
function _arrayWithHoles(arr) {
  if (Array.isArray(arr))
    return arr;
}
function _iterableToArray(iter) {
  if (typeof Symbol !== "undefined" && iter[Symbol.iterator] != null || iter["@@iterator"] != null)
    return Array.from(iter);
}
function _unsupportedIterableToArray(o, minLen) {
  if (!o)
    return;
  if (typeof o === "string")
    return _arrayLikeToArray(o, minLen);
  var n = Object.prototype.toString.call(o).slice(8, -1);
  if (n === "Object" && o.constructor)
    n = o.constructor.name;
  if (n === "Map" || n === "Set")
    return Array.from(o);
  if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n))
    return _arrayLikeToArray(o, minLen);
}
function _arrayLikeToArray(arr, len) {
  if (len == null || len > arr.length)
    len = arr.length;
  for (var i = 0, arr2 = new Array(len); i < len; i++)
    arr2[i] = arr[i];
  return arr2;
}
function _nonIterableSpread() {
  throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}
function _nonIterableRest() {
  throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}
function _toPrimitive2(input, hint) {
  if (typeof input !== "object" || input === null)
    return input;
  var prim = input[Symbol.toPrimitive];
  if (prim !== void 0) {
    var res = prim.call(input, hint || "default");
    if (typeof res !== "object")
      return res;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return (hint === "string" ? String : Number)(input);
}
function _toPropertyKey2(arg) {
  var key = _toPrimitive2(arg, "string");
  return typeof key === "symbol" ? key : String(key);
}

// node_modules/xgplayer-transmuxer/es/model/types.js
var TrackType = {
  VIDEO: "video",
  AUDIO: "audio",
  METADATA: "metadata"
};
var VideoCodecType = {
  AVC: "avc",
  HEVC: "hevc"
};
var AudioCodecType = {
  AAC: "aac",
  G711PCMA: "g7110a",
  G711PCMU: "g7110m"
};
var WarningType = {
  LARGE_AV_SHIFT: "LARGE_AV_SHIFT",
  LARGE_VIDEO_GAP: "LARGE_VIDEO_GAP",
  LARGE_VIDEO_GAP_BETWEEN_CHUNK: "LARGE_VIDEO_GAP_BETWEEN_CHUNK",
  LARGE_AUDIO_GAP: "LARGE_AUDIO_GAP",
  AUDIO_FILLED: "AUDIO_FILLED",
  AUDIO_DROPPED: "AUDIO_DROPPED"
};

// node_modules/xgplayer-transmuxer/es/model/video-track.js
var VideoTrack = function() {
  function VideoTrack2() {
    _classCallCheck2(this, VideoTrack2);
    _defineProperty2(this, "id", 1);
    _defineProperty2(this, "type", TrackType.VIDEO);
    _defineProperty2(this, "codecType", VideoCodecType.AVC);
    _defineProperty2(this, "pid", -1);
    _defineProperty2(this, "hvcC", void 0);
    _defineProperty2(this, "codec", "");
    _defineProperty2(this, "timescale", 0);
    _defineProperty2(this, "formatTimescale", 0);
    _defineProperty2(this, "sequenceNumber", 0);
    _defineProperty2(this, "baseMediaDecodeTime", 0);
    _defineProperty2(this, "baseDts", 0);
    _defineProperty2(this, "duration", 0);
    _defineProperty2(this, "warnings", []);
    _defineProperty2(this, "samples", []);
    _defineProperty2(this, "pps", []);
    _defineProperty2(this, "sps", []);
    _defineProperty2(this, "vps", []);
    _defineProperty2(this, "fpsNum", 0);
    _defineProperty2(this, "fpsDen", 0);
    _defineProperty2(this, "sarRatio", []);
    _defineProperty2(this, "width", 0);
    _defineProperty2(this, "height", 0);
    _defineProperty2(this, "nalUnitSize", 4);
    _defineProperty2(this, "present", false);
    _defineProperty2(this, "isVideoEncryption", false);
    _defineProperty2(this, "isAudioEncryption", false);
    _defineProperty2(this, "isVideo", true);
    _defineProperty2(this, "kid", null);
    _defineProperty2(this, "pssh", null);
    _defineProperty2(this, "ext", void 0);
  }
  _createClass2(VideoTrack2, [{
    key: "reset",
    value: function reset() {
      this.sequenceNumber = this.width = this.height = this.fpsDen = this.fpsNum = this.duration = this.baseMediaDecodeTime = this.timescale = 0;
      this.codec = "";
      this.present = false;
      this.pid = -1;
      this.pps = [];
      this.sps = [];
      this.vps = [];
      this.sarRatio = [];
      this.samples = [];
      this.warnings = [];
      this.hvcC = null;
    }
  }, {
    key: "firstDts",
    get: function get() {
      return this.samples.length ? this.samples[0].dts : null;
    }
  }, {
    key: "firstPts",
    get: function get() {
      return this.samples.length ? this.samples[0].pts : null;
    }
  }, {
    key: "samplesDuration",
    get: function get() {
      if (this.samples.length > 0) {
        var first = this.samples[0];
        var last = this.samples[this.samples.length - 1];
        return last.dts - first.dts + last.duration;
      }
      return 0;
    }
  }, {
    key: "exist",
    value: function exist() {
      return !!(this.pps.length && this.sps.length && this.codec);
    }
  }, {
    key: "hasSample",
    value: function hasSample() {
      return !!this.samples.length;
    }
  }, {
    key: "isEncryption",
    get: function get() {
      return this.isVideoEncryption;
    }
  }]);
  return VideoTrack2;
}();

// node_modules/xgplayer-transmuxer/es/model/audio-track.js
var AudioTrack = function() {
  function AudioTrack2() {
    _classCallCheck2(this, AudioTrack2);
    _defineProperty2(this, "id", 2);
    _defineProperty2(this, "type", TrackType.AUDIO);
    _defineProperty2(this, "codecType", AudioCodecType.AAC);
    _defineProperty2(this, "pid", -1);
    _defineProperty2(this, "codec", "");
    _defineProperty2(this, "sequenceNumber", 0);
    _defineProperty2(this, "sampleDuration", 0);
    _defineProperty2(this, "timescale", 0);
    _defineProperty2(this, "formatTimescale", 0);
    _defineProperty2(this, "baseMediaDecodeTime", 0);
    _defineProperty2(this, "duration", 0);
    _defineProperty2(this, "warnings", []);
    _defineProperty2(this, "samples", []);
    _defineProperty2(this, "baseDts", 0);
    _defineProperty2(this, "sampleSize", 16);
    _defineProperty2(this, "sampleRate", 0);
    _defineProperty2(this, "channelCount", 0);
    _defineProperty2(this, "objectType", 0);
    _defineProperty2(this, "sampleRateIndex", 0);
    _defineProperty2(this, "config", []);
    _defineProperty2(this, "present", false);
    _defineProperty2(this, "isVideoEncryption", false);
    _defineProperty2(this, "isAudioEncryption", false);
    _defineProperty2(this, "kid", null);
    _defineProperty2(this, "ext", void 0);
  }
  _createClass2(AudioTrack2, [{
    key: "reset",
    value: function reset() {
      this.sequenceNumber = 0;
      this.timescale = 0;
      this.sampleDuration = 0;
      this.sampleRate = 0;
      this.channelCount = 0;
      this.baseMediaDecodeTime = 0;
      this.present = false;
      this.pid = -1;
      this.codec = "";
      this.samples = [];
      this.config = [];
      this.warnings = [];
    }
  }, {
    key: "exist",
    value: function exist() {
      return !!(this.sampleRate && this.channelCount && this.codec && this.codecType === AudioCodecType.AAC);
    }
  }, {
    key: "hasSample",
    value: function hasSample() {
      return !!this.samples.length;
    }
  }, {
    key: "isEncryption",
    get: function get() {
      return this.isAudioEncryption;
    }
  }, {
    key: "firstDts",
    get: function get() {
      return this.samples.length ? this.samples[0].dts : null;
    }
  }, {
    key: "firstPts",
    get: function get() {
      return this.samples.length ? this.samples[0].pts : null;
    }
  }, {
    key: "samplesDuration",
    get: function get() {
      if (this.samples.length > 0) {
        var first = this.samples[0];
        var last = this.samples[this.samples.length - 1];
        return last.dts - first.dts + last.duration;
      }
      return 0;
    }
  }]);
  return AudioTrack2;
}();

// node_modules/xgplayer-transmuxer/es/model/video-sample.js
var VideoSample = function() {
  function VideoSample2(pts, dts, units) {
    _classCallCheck2(this, VideoSample2);
    _defineProperty2(this, "flag", {});
    _defineProperty2(this, "keyframe", false);
    _defineProperty2(this, "gopId", 0);
    _defineProperty2(this, "duration", 0);
    _defineProperty2(this, "size", 0);
    _defineProperty2(this, "units", []);
    _defineProperty2(this, "chromaFormat", 420);
    this.originPts = this.pts = pts;
    this.originDts = this.dts = dts;
    if (units)
      this.units = units;
  }
  _createClass2(VideoSample2, [{
    key: "cts",
    get: function get() {
      return this.pts - this.dts;
    }
  }, {
    key: "setToKeyframe",
    value: function setToKeyframe() {
      this.keyframe = true;
      this.flag.dependsOn = 2;
      this.flag.isNonSyncSample = 0;
    }
  }]);
  return VideoSample2;
}();

// node_modules/xgplayer-transmuxer/es/model/audio-sample.js
var AudioSample = _createClass2(
  function AudioSample2(pts, data, duration, sampleOffset) {
    _classCallCheck2(this, AudioSample2);
    _defineProperty2(this, "duration", 1024);
    _defineProperty2(this, "flag", {
      dependsOn: 2,
      isNonSyncSample: 0
    });
    _defineProperty2(this, "keyframe", true);
    this.originPts = this.pts = this.dts = pts;
    this.data = data;
    this.size = data.byteLength;
    this.sampleOffset = sampleOffset;
    if (duration)
      this.duration = duration;
  }
);

// node_modules/xgplayer-transmuxer/es/model/metadata-track.js
var Sample = _createClass2(
  function Sample2(data, pts) {
    _classCallCheck2(this, Sample2);
    _defineProperty2(this, "time", 0);
    this.data = data;
    this.originPts = this.pts = pts;
  }
);
var FlvScriptSample = function(_Sample) {
  _inherits2(FlvScriptSample2, _Sample);
  var _super = _createSuper2(FlvScriptSample2);
  function FlvScriptSample2() {
    _classCallCheck2(this, FlvScriptSample2);
    return _super.apply(this, arguments);
  }
  return _createClass2(FlvScriptSample2);
}(Sample);
var SeiSample = function(_Sample2) {
  _inherits2(SeiSample2, _Sample2);
  var _super2 = _createSuper2(SeiSample2);
  function SeiSample2() {
    _classCallCheck2(this, SeiSample2);
    return _super2.apply(this, arguments);
  }
  return _createClass2(SeiSample2);
}(Sample);
var MetadataTrack = function() {
  function MetadataTrack2() {
    _classCallCheck2(this, MetadataTrack2);
    _defineProperty2(this, "id", 3);
    _defineProperty2(this, "type", TrackType.METADATA);
    _defineProperty2(this, "timescale", 0);
    _defineProperty2(this, "flvScriptSamples", []);
    _defineProperty2(this, "seiSamples", []);
  }
  _createClass2(MetadataTrack2, [{
    key: "exist",
    value: function exist() {
      return !!((this.flvScriptSamples.length || this.seiSamples.length) && this.timescale);
    }
  }, {
    key: "reset",
    value: function reset() {
      this.timescale = 0;
      this.flvScriptSamples = [];
      this.seiSamples = [];
    }
  }, {
    key: "hasSample",
    value: function hasSample() {
      return !!(this.flvScriptSamples.length || this.seiSamples.length);
    }
  }]);
  return MetadataTrack2;
}();

// node_modules/xgplayer-transmuxer/es/utils/logger.js
var Logger = function() {
  function Logger22(name) {
    _classCallCheck2(this, Logger22);
    this.name = name || "";
    this._prefix = "[".concat(this.name, "]");
  }
  _createClass2(Logger22, [{
    key: "warn",
    value: function warn() {
      var _console;
      if (Logger22.disabled)
        return;
      for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
        args[_key] = arguments[_key];
      }
      (_console = console).warn.apply(_console, [this._prefix].concat(args));
    }
  }], [{
    key: "enable",
    value: function enable() {
      Logger22.disabled = false;
    }
  }, {
    key: "disable",
    value: function disable() {
      Logger22.disabled = true;
    }
  }]);
  return Logger22;
}();
_defineProperty2(Logger, "disabled", true);

// node_modules/xgplayer-transmuxer/es/utils/env.js
var isBrowser = typeof window !== "undefined";
var ua = isBrowser && navigator.userAgent.toLocaleLowerCase();
var isSafari = isBrowser && /^((?!chrome|android).)*safari/.test(ua);
var isFirefox = isBrowser && ua.includes("firefox");
var isAndroid = isBrowser && ua.includes("android");

// node_modules/xgplayer-transmuxer/es/codec/aac.js
var AAC = function() {
  function AAC2() {
    _classCallCheck2(this, AAC2);
  }
  _createClass2(AAC2, null, [{
    key: "getRateIndexByRate",
    value: function getRateIndexByRate(rate) {
      return AAC2.FREQ.indexOf(rate);
    }
  }, {
    key: "parseADTS",
    value: function parseADTS(data, pts) {
      var len = data.length;
      var i = 0;
      while (i + 2 < len) {
        if (data[i] === 255 && (data[i + 1] & 246) === 240) {
          break;
        }
        i++;
      }
      if (i >= len)
        return;
      var skip = i;
      var frames = [];
      var samplingFrequencyIndex = (data[i + 2] & 60) >>> 2;
      var sampleRate = AAC2.FREQ[samplingFrequencyIndex];
      if (!sampleRate)
        throw new Error("Invalid sampling index: ".concat(samplingFrequencyIndex));
      var objectType = ((data[i + 2] & 192) >>> 6) + 1;
      var channelCount = (data[i + 2] & 1) << 2 | (data[i + 3] & 192) >>> 6;
      var _AAC$_getConfig = AAC2._getConfig(samplingFrequencyIndex, channelCount, objectType), config = _AAC$_getConfig.config, codec = _AAC$_getConfig.codec;
      var protectionSkipBytes;
      var frameLength;
      var frameIndex = 0;
      var duration = AAC2.getFrameDuration(sampleRate);
      while (i + 7 < len) {
        if (data[i] !== 255 || (data[i + 1] & 246) !== 240) {
          i++;
          continue;
        }
        frameLength = (data[i + 3] & 3) << 11 | data[i + 4] << 3 | (data[i + 5] & 224) >> 5;
        if (len - i < frameLength)
          break;
        protectionSkipBytes = (~data[i + 1] & 1) * 2;
        frames.push({
          pts: pts + frameIndex * duration,
          data: data.subarray(i + 7 + protectionSkipBytes, i + frameLength)
        });
        frameIndex++;
        i += frameLength;
      }
      return {
        skip,
        remaining: i >= len ? void 0 : data.subarray(i),
        frames,
        samplingFrequencyIndex,
        sampleRate,
        objectType,
        channelCount,
        codec,
        config,
        originCodec: "mp4a.40.".concat(objectType)
      };
    }
  }, {
    key: "parseAudioSpecificConfig",
    value: function parseAudioSpecificConfig(data) {
      if (!data.length)
        return;
      var objectType = data[0] >>> 3;
      var samplingFrequencyIndex = (data[0] & 7) << 1 | data[1] >>> 7;
      var channelCount = (data[1] & 120) >>> 3;
      var sampleRate = AAC2.FREQ[samplingFrequencyIndex];
      if (!sampleRate)
        return;
      var _AAC$_getConfig2 = AAC2._getConfig(samplingFrequencyIndex, channelCount, objectType), config = _AAC$_getConfig2.config, codec = _AAC$_getConfig2.codec;
      return {
        samplingFrequencyIndex,
        sampleRate,
        objectType,
        channelCount,
        config,
        codec,
        originCodec: "mp4a.40.".concat(objectType)
      };
    }
  }, {
    key: "getFrameDuration",
    value: function getFrameDuration(rate) {
      var timescale = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 9e4;
      return 1024 * timescale / rate;
    }
  }, {
    key: "_getConfig",
    value: function _getConfig(samplingIndex, channelCount, originObjectType) {
      var config = [];
      var objectType;
      var extensionSamplingIndex;
      if (isFirefox) {
        if (samplingIndex >= 6) {
          objectType = 5;
          extensionSamplingIndex = samplingIndex - 3;
        } else {
          objectType = 2;
          extensionSamplingIndex = samplingIndex;
        }
      } else if (isAndroid) {
        objectType = 2;
        extensionSamplingIndex = samplingIndex;
      } else {
        objectType = originObjectType === 2 || originObjectType === 5 ? originObjectType : 5;
        extensionSamplingIndex = samplingIndex;
        if (samplingIndex >= 6) {
          extensionSamplingIndex = samplingIndex - 3;
        } else if (channelCount === 1) {
          objectType = 2;
          extensionSamplingIndex = samplingIndex;
        }
      }
      config[0] = objectType << 3;
      config[0] |= (samplingIndex & 14) >> 1;
      config[1] = (samplingIndex & 1) << 7;
      config[1] |= channelCount << 3;
      if (objectType === 5) {
        config[1] |= (extensionSamplingIndex & 14) >> 1;
        config[2] = (extensionSamplingIndex & 1) << 7;
        config[2] |= 2 << 2;
        config[3] = 0;
      }
      return {
        config,
        codec: "mp4a.40.".concat(objectType)
      };
    }
  }, {
    key: "getSilentFrame",
    value: function getSilentFrame(codec, channelCount) {
      switch (codec) {
        case "mp4a.40.2":
          if (channelCount === 1) {
            return new Uint8Array([0, 200, 0, 128, 35, 128]);
          }
          if (channelCount === 2) {
            return new Uint8Array([33, 0, 73, 144, 2, 25, 0, 35, 128]);
          }
          if (channelCount === 3) {
            return new Uint8Array([0, 200, 0, 128, 32, 132, 1, 38, 64, 8, 100, 0, 142]);
          }
          if (channelCount === 4) {
            return new Uint8Array([0, 200, 0, 128, 32, 132, 1, 38, 64, 8, 100, 0, 128, 44, 128, 8, 2, 56]);
          }
          if (channelCount === 5) {
            return new Uint8Array([0, 200, 0, 128, 32, 132, 1, 38, 64, 8, 100, 0, 130, 48, 4, 153, 0, 33, 144, 2, 56]);
          }
          if (channelCount === 6) {
            return new Uint8Array([0, 200, 0, 128, 32, 132, 1, 38, 64, 8, 100, 0, 130, 48, 4, 153, 0, 33, 144, 2, 0, 178, 0, 32, 8, 224]);
          }
          break;
        default:
          if (channelCount === 1) {
            return new Uint8Array([1, 64, 34, 128, 163, 78, 230, 128, 186, 8, 0, 0, 0, 28, 6, 241, 193, 10, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 94]);
          }
          if (channelCount === 2) {
            return new Uint8Array([1, 64, 34, 128, 163, 94, 230, 128, 186, 8, 0, 0, 0, 0, 149, 0, 6, 241, 161, 10, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 94]);
          }
          if (channelCount === 3) {
            return new Uint8Array([1, 64, 34, 128, 163, 94, 230, 128, 186, 8, 0, 0, 0, 0, 149, 0, 6, 241, 161, 10, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 94]);
          }
          break;
      }
    }
  }]);
  return AAC2;
}();
_defineProperty2(AAC, "FREQ", [96e3, 88200, 64e3, 48e3, 44100, 32e3, 24e3, 22050, 16e3, 12e3, 11025, 8e3, 7350]);

// node_modules/xgplayer-transmuxer/es/flv/fixer.js
var LARGE_AV_FIRST_FRAME_GAP = 500;
var AUDIO_GAP_OVERLAP_THRESHOLD_COUNT = 3;
var MAX_SILENT_FRAME_DURATION = 1e3;
var AUDIO_EXCETION_LOG_EMIT_DURATION = 5e3;
var MAX_VIDEO_FRAME_DURATION = 1e3;
var MAX_DTS_DELTA_WITH_NEXT_CHUNK = 200;
var VIDEO_EXCETION_LOG_EMIT_DURATION = 5e3;
var TRACK_BREACKED_CHECK_TIME = 5;
var FlvFixer = function() {
  function FlvFixer2(videoTrack, audioTrack, metadataTrack) {
    _classCallCheck2(this, FlvFixer2);
    this.videoTrack = videoTrack;
    this.audioTrack = audioTrack;
    this.metadataTrack = metadataTrack;
    this._baseDts = -1;
    this._baseDtsInited = false;
    this._audioNextPts = void 0;
    this._videoNextDts = void 0;
    this._audioTimestampBreak = 0;
    this._videoTimestampBreak = 0;
    this._lastVideoDuration = 0;
    this._keyFrameInNextChunk = false;
    this._lastAudioExceptionGapDot = -Infinity;
    this._lastAudioExceptionOverlapDot = -Infinity;
    this._lastAudioExceptionLargeGapDot = -Infinity;
    this._lastVideoExceptionLargeGapDot = -Infinity;
    this._lastVideoExceptionChunkFirstDtsDot = -Infinity;
  }
  _createClass2(FlvFixer2, [{
    key: "fix",
    value: function fix() {
      var _this = this;
      var startTime = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : 0;
      var discontinuity = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : false;
      var contiguous = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : true;
      startTime = Math.round(startTime * 1e3);
      var videoTrack = this.videoTrack;
      var audioTrack = this.audioTrack;
      if (discontinuity || !contiguous) {
        this._videoLastSample = null;
        this._audioNextPts = void 0;
        this._videoNextDts = void 0;
        this._audioTimestampBreak = 0;
        this._videoTimestampBreak = 0;
        this._lastAudioExceptionGapDot = -Infinity;
        this._lastAudioExceptionOverlapDot = -Infinity;
        this._lastAudioExceptionLargeGapDot = -Infinity;
        this._lastVideoExceptionLargeGapDot = -Infinity;
        this._lastVideoExceptionChunkFirstDtsDot = -Infinity;
      }
      if (discontinuity && !contiguous) {
        this._baseDtsInited = false;
      }
      if (!this._baseDtsInited) {
        this._calculateBaseDts(audioTrack, videoTrack);
      }
      if (!contiguous && startTime) {
        this._audioNextPts = this._videoNextDts = startTime;
      }
      var resetBaseDts = this._baseDtsInited && (this._videoTimestampBreak || !this.videoTrack.exist()) && (this._audioTimestampBreak || !this.audioTrack.exist());
      if (resetBaseDts) {
        this._resetBaseDtsWhenStreamBreaked();
      }
      this._fixAudio(audioTrack);
      this._keyFrameInNextChunk = false;
      this._fixVideo(videoTrack);
      if (this.metadataTrack.exist()) {
        var timescale = this.metadataTrack.timescale;
        this.metadataTrack.seiSamples.forEach(function(s) {
          s.pts = s.originPts - _this._baseDts;
          s.time = Math.max(0, s.pts) / timescale;
        });
        this.metadataTrack.flvScriptSamples.forEach(function(s) {
          s.pts = s.originPts - _this._baseDts;
          s.time = Math.max(0, s.pts) / timescale;
        });
      }
      if (videoTrack.samples.length) {
        videoTrack.baseMediaDecodeTime = videoTrack.samples[0].dts;
      }
      if (audioTrack.samples.length) {
        audioTrack.baseMediaDecodeTime = audioTrack.samples[0].pts * audioTrack.timescale / 1e3;
      }
    }
  }, {
    key: "_fixVideo",
    value: function _fixVideo(videoTrack) {
      var _this2 = this;
      var samples = videoTrack.samples;
      if (!samples.length)
        return;
      samples.forEach(function(x2) {
        x2.dts -= _this2._baseDts;
        x2.pts -= _this2._baseDts;
        if (x2.keyframe)
          _this2._keyFrameInNextChunk = true;
      });
      var refSampleDurationInt;
      if (videoTrack.fpsNum && videoTrack.fpsDen) {
        refSampleDurationInt = videoTrack.timescale * (videoTrack.fpsDen / videoTrack.fpsNum);
      } else if (videoTrack.length > 1) {
        var first = videoTrack.samples[0];
        var last = videoTrack.samples[samples.length - 1];
        refSampleDurationInt = Math.floor((last.dts - first.dts) / (samples.length - 1));
      } else {
        refSampleDurationInt = this._lastVideoDuration || 40;
      }
      var lastSample = samples.pop();
      if (this._videoLastSample) {
        samples.unshift(this._videoLastSample);
      }
      this._videoLastSample = lastSample;
      if (!samples.length)
        return;
      if (this._videoNextDts === void 0) {
        var samp0 = samples[0];
        this._videoNextDts = samp0.dts;
      }
      var len = samples.length;
      var sampleDuration = 0;
      var firstSample = samples[0];
      var vDelta = this._videoNextDts - firstSample.dts;
      if (Math.abs(vDelta) > MAX_DTS_DELTA_WITH_NEXT_CHUNK) {
        if (Math.abs(firstSample.dts - this._lastVideoExceptionChunkFirstDtsDot) > VIDEO_EXCETION_LOG_EMIT_DURATION) {
          var _samples$;
          this._lastVideoExceptionChunkFirstDtsDot = firstSample.dts;
          videoTrack.warnings.push({
            type: WarningType.LARGE_VIDEO_GAP_BETWEEN_CHUNK,
            nextDts: this._videoNextDts,
            firstSampleDts: firstSample.dts,
            nextSampleDts: (_samples$ = samples[1]) === null || _samples$ === void 0 ? void 0 : _samples$.dts,
            sampleDuration: vDelta
          });
        }
        if (this._videoTimestampBreak >= TRACK_BREACKED_CHECK_TIME) {
          this._videoNextDts = firstSample.dts;
          this._videoTimestampBreak = 0;
        } else {
          firstSample.dts += vDelta;
          firstSample.pts += vDelta;
          if (!this.audioTrack.exist()) {
            this._videoTimestampBreak = 1;
          }
        }
      }
      for (var i = 0; i < len; i++) {
        var dts = samples[i].dts;
        var nextSample = samples[i + 1];
        if (i < len - 1) {
          sampleDuration = nextSample.dts - dts;
        } else if (lastSample) {
          sampleDuration = lastSample.dts - dts;
        } else {
          sampleDuration = refSampleDurationInt;
        }
        if (sampleDuration > MAX_VIDEO_FRAME_DURATION || sampleDuration < 0) {
          this._videoTimestampBreak++;
          if (Math.abs(dts - this._lastVideoExceptionLargeGapDot) > VIDEO_EXCETION_LOG_EMIT_DURATION) {
            this._lastVideoExceptionLargeGapDot = dts;
            videoTrack.warnings.push({
              type: WarningType.LARGE_VIDEO_GAP,
              time: dts / videoTrack.timescale,
              dts,
              originDts: samples[i].originDts,
              nextDts: this._videoNextDts,
              sampleDuration,
              refSampleDuration: refSampleDurationInt
            });
          }
          sampleDuration = refSampleDurationInt;
        }
        samples[i].duration = sampleDuration;
        this._videoNextDts += sampleDuration;
        this._lastVideoDuration = sampleDuration;
      }
    }
  }, {
    key: "_fixAudio",
    value: function _fixAudio(audioTrack) {
      var _this3 = this;
      var samples = audioTrack.samples;
      if (!samples.length)
        return;
      samples.forEach(function(x2) {
        x2.dts = x2.pts -= _this3._baseDts;
      });
      this._doFixAudioInternal(audioTrack, samples, 1e3);
    }
  }, {
    key: "_calculateBaseDts",
    value: function _calculateBaseDts(audioTrack, videoTrack) {
      var audioSamps = audioTrack.samples;
      var videoSamps = videoTrack.samples;
      if (!audioSamps.length && !videoSamps.length) {
        return false;
      }
      var audioBasePts = Infinity;
      var videoBaseDts = Infinity;
      if (audioSamps.length) {
        audioTrack.baseDts = audioBasePts = audioSamps[0].pts;
      }
      if (videoSamps.length) {
        videoTrack.baseDts = videoBaseDts = videoSamps[0].dts;
      }
      this._baseDts = Math.min(audioBasePts, videoBaseDts);
      var delta = videoBaseDts - audioBasePts;
      if (Number.isFinite(delta) && Math.abs(delta) > LARGE_AV_FIRST_FRAME_GAP) {
        videoTrack.warnings.push({
          type: WarningType.LARGE_AV_SHIFT,
          videoBaseDts,
          audioBasePts,
          baseDts: this._baseDts,
          delta
        });
      }
      this._baseDtsInited = true;
      return true;
    }
  }, {
    key: "_resetBaseDtsWhenStreamBreaked",
    value: function _resetBaseDtsWhenStreamBreaked() {
      var calc = this._calculateBaseDts(this.audioTrack, this.videoTrack);
      if (!calc)
        return;
      if (!this.audioTrack.exist()) {
        this._baseDts -= this._videoNextDts;
      } else if (!this.videoTrack.exist()) {
        this._baseDts -= this._audioNextPts;
      } else {
        this._baseDts -= Math.min(this._audioNextPts, this._videoNextDts);
      }
      this._videoTimestampBreak = 0;
      this._audioTimestampBreak = 0;
    }
  }, {
    key: "_doFixAudioInternal",
    value: function _doFixAudioInternal(audioTrack, samples, timescale) {
      if (!audioTrack.sampleDuration) {
        audioTrack.sampleDuration = audioTrack.codecType === AudioCodecType.AAC ? AAC.getFrameDuration(audioTrack.timescale, timescale) : this._getG711Duration(audioTrack);
      }
      var refSampleDuration = audioTrack.sampleDuration;
      var sampleDurationInSampleRate = audioTrack.codecType === AudioCodecType.AAC ? 1024 : refSampleDuration * audioTrack.timescale / 1e3;
      if (this._audioNextPts === void 0) {
        var samp0 = samples[0];
        this._audioNextPts = samp0.pts;
      }
      for (var i = 0; i < samples.length; i++) {
        var nextPts = this._audioNextPts;
        var sample = samples[i];
        var delta = sample.pts - nextPts;
        if (i === 0 && this._audioTimestampBreak >= TRACK_BREACKED_CHECK_TIME && this._keyFrameInNextChunk) {
          nextPts = this._audioNextPts = sample.dts;
          delta = 0;
          this._audioTimestampBreak = 0;
        }
        if (!this._audioTimestampBreak && delta >= AUDIO_GAP_OVERLAP_THRESHOLD_COUNT * refSampleDuration && delta <= MAX_SILENT_FRAME_DURATION && !isSafari) {
          var silentFrame = this._getSilentFrame(audioTrack) || samples[0].data.subarray();
          var count = Math.floor(delta / refSampleDuration);
          if (Math.abs(sample.pts - this._lastAudioExceptionGapDot) > AUDIO_EXCETION_LOG_EMIT_DURATION) {
            this._lastAudioExceptionGapDot = sample.pts;
            audioTrack.warnings.push({
              type: WarningType.AUDIO_FILLED,
              pts: sample.pts,
              originPts: sample.originPts,
              count,
              nextPts,
              refSampleDuration
            });
          }
          for (var j = 0; j < count; j++) {
            var silentSample = new AudioSample(Math.floor(this._audioNextPts + refSampleDuration) - Math.floor(this._audioNextPts), silentFrame, sampleDurationInSampleRate);
            silentSample.originPts = Math.floor(this._baseDts + nextPts);
            samples.splice(i, 0, silentSample);
            this._audioNextPts += refSampleDuration;
            i++;
          }
          i--;
        } else if (delta <= -AUDIO_GAP_OVERLAP_THRESHOLD_COUNT * refSampleDuration && delta >= -1 * MAX_SILENT_FRAME_DURATION) {
          if (Math.abs(sample.pts - this._lastAudioExceptionOverlapDot) > AUDIO_EXCETION_LOG_EMIT_DURATION) {
            this._lastAudioExceptionOverlapDot = sample.pts;
            audioTrack.warnings.push({
              type: WarningType.AUDIO_DROPPED,
              pts: sample.pts,
              originPts: sample.originPts,
              nextPts,
              refSampleDuration
            });
          }
          samples.splice(i, 1);
          i--;
        } else {
          if (Math.abs(delta) > MAX_SILENT_FRAME_DURATION) {
            this._audioTimestampBreak++;
            if (Math.abs(sample.pts - this._lastAudioExceptionLargeGapDot) > AUDIO_EXCETION_LOG_EMIT_DURATION) {
              this._lastAudioExceptionLargeGapDot = sample.pts;
              audioTrack.warnings.push({
                type: WarningType.LARGE_AUDIO_GAP,
                time: sample.pts / 1e3,
                pts: sample.pts,
                originPts: sample.originPts,
                nextPts,
                sampleDuration: delta,
                refSampleDuration
              });
            }
          }
          sample.dts = sample.pts = nextPts;
          sample.duration = sampleDurationInSampleRate;
          this._audioNextPts += refSampleDuration;
        }
      }
    }
  }, {
    key: "_getG711Duration",
    value: function _getG711Duration(track) {
      var sampleSize = track.sampleSize, channelCount = track.channelCount, sampleRate = track.sampleRate;
      var samp0 = track.samples[0];
      if (!samp0)
        return;
      return samp0.data.byteLength * 2 / channelCount / (sampleSize / 8) / sampleRate * 1e3;
    }
  }, {
    key: "_getSilentFrame",
    value: function _getSilentFrame(track) {
      if (track.codecType === AudioCodecType.AAC)
        return AAC.getSilentFrame(track.codec, track.channelCount);
      return new Uint8Array(8 * track.sampleDuration * track.channelCount);
    }
  }]);
  return FlvFixer2;
}();

// node_modules/xgplayer-transmuxer/es/utils/index.js
function concatUint8Array() {
  for (var _len = arguments.length, arr = new Array(_len), _key = 0; _key < _len; _key++) {
    arr[_key] = arguments[_key];
  }
  arr = arr.filter(Boolean);
  var data = new Uint8Array(arr.reduce(function(p, c) {
    return p + c.byteLength;
  }, 0));
  var prevLen = 0;
  arr.forEach(function(d2) {
    data.set(d2, prevLen);
    prevLen += d2.byteLength;
  });
  return data;
}
var MAX_SIZE = Math.pow(2, 32);
function readBig16(data) {
  var i = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 0;
  return (data[i] << 8) + (data[i + 1] || 0);
}
function readBig24(data) {
  var i = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 0;
  return (data[i] << 16) + (data[i + 1] << 8) + (data[i + 2] || 0);
}
function readBig32(data) {
  var i = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 0;
  return (data[i] << 24 >>> 0) + (data[i + 1] << 16) + (data[i + 2] << 8) + (data[i + 3] || 0);
}
function readBig64(data) {
  var i = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 0;
  return readBig32(data, i) * MAX_SIZE + readBig32(data, i + 4);
}
function getAvcCodec(codecs) {
  var codec = "avc1.";
  var h;
  for (var i = 0; i < 3; i++) {
    h = codecs[i].toString(16);
    if (h.length < 2)
      h = "0".concat(h);
    codec += h;
  }
  return codec;
}
function formatIV(arr) {
  var iv = "";
  arr.forEach(function(value) {
    iv += bufferToString(value);
  });
  if (iv.length <= 32) {
    var len = 32 - iv.length;
    for (var i = 0; i < len; i++) {
      iv += "0";
    }
  }
  return iv;
}
function parse(a) {
  if (!Array.isArray(a)) {
    var arr = [];
    var value = "";
    for (var i = 0; i < a.length; i++) {
      if (i % 2) {
        value = a[i - 1] + a[i];
        arr.push(parseInt(value, 16));
        value = "";
      }
    }
    return arr;
  }
  return a.map(function(item) {
    return parseInt(item, 16);
  });
}
function bufferToString(value) {
  return ("0" + Number(value).toString(16)).slice(-2).toUpperCase();
}

// node_modules/xgplayer-transmuxer/es/codec/nalu.js
var NALu = function() {
  function NALu2() {
    _classCallCheck2(this, NALu2);
  }
  _createClass2(NALu2, null, [{
    key: "parseAnnexB",
    value: function parseAnnexB(data) {
      var len = data.length;
      var start = 2;
      var end = 0;
      while (data[start] !== null && data[start] !== void 0 && data[start] !== 1) {
        start++;
      }
      start++;
      end = start + 2;
      if (end >= len)
        return [];
      var units = [];
      while (end < len) {
        switch (data[end]) {
          case 0:
            if (data[end - 1] !== 0) {
              end += 2;
              break;
            } else if (data[end - 2] !== 0) {
              end++;
              break;
            }
            if (start !== end - 2)
              units.push(data.subarray(start, end - 2));
            do {
              end++;
            } while (data[end] !== 1 && end < len);
            start = end + 1;
            end = start + 2;
            break;
          case 1:
            if (data[end - 1] !== 0 || data[end - 2] !== 0) {
              end += 3;
              break;
            }
            if (start !== end - 2)
              units.push(data.subarray(start, end - 2));
            start = end + 1;
            end = start + 2;
            break;
          default:
            end += 3;
            break;
        }
      }
      if (start < len)
        units.push(data.subarray(start));
      return units;
    }
  }, {
    key: "parseAvcC",
    value: function parseAvcC(data) {
      var size = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 4;
      if (data.length < 4)
        return;
      var dataLen = data.length;
      var units = [];
      var offset = 0;
      var length;
      while (offset + size < dataLen) {
        length = readBig32(data, offset);
        if (size === 3)
          length >>>= 8;
        offset += size;
        if (!length)
          continue;
        if (offset + length > dataLen) {
          break;
        }
        units.push(data.subarray(offset, offset + length));
        offset += length;
      }
      return units;
    }
  }, {
    key: "parseSEI",
    value: function parseSEI(unit, isHevc) {
      var len = unit.length;
      var i = isHevc ? 2 : 1;
      var type = 0;
      var size = 0;
      var uuid = "";
      while (unit[i] === 255) {
        type += 255;
        i++;
      }
      type += unit[i++];
      while (unit[i] === 255) {
        size += 255;
        i++;
      }
      size += unit[i++];
      if (type === 5 && len > i + 16) {
        for (var j = 0; j < 16; j++) {
          uuid += unit[i].toString(16);
          i++;
        }
      }
      return {
        payload: unit.subarray(i, i + size),
        type,
        size,
        uuid
      };
    }
  }, {
    key: "removeEPB",
    value: function removeEPB(uint) {
      var length = uint.byteLength;
      var emulationPreventionBytesPositions = [];
      var i = 1;
      while (i < length - 2) {
        if (uint[i] === 0 && uint[i + 1] === 0 && uint[i + 2] === 3) {
          emulationPreventionBytesPositions.push(i + 2);
          i += 2;
        } else {
          i++;
        }
      }
      if (!emulationPreventionBytesPositions.length)
        return uint;
      var newLength = length - emulationPreventionBytesPositions.length;
      var newData = new Uint8Array(newLength);
      var sourceIndex = 0;
      for (i = 0; i < newLength; sourceIndex++, i++) {
        if (sourceIndex === emulationPreventionBytesPositions[0]) {
          sourceIndex++;
          emulationPreventionBytesPositions.shift();
        }
        newData[i] = uint[sourceIndex];
      }
      return newData;
    }
  }]);
  return NALu2;
}();

// node_modules/xgplayer-transmuxer/es/utils/exp-golomb.js
var ExpGolomb = function() {
  function ExpGolomb2(data) {
    _classCallCheck2(this, ExpGolomb2);
    _defineProperty2(this, "_bytesAvailable", void 0);
    _defineProperty2(this, "_bitsAvailable", 0);
    _defineProperty2(this, "_word", 0);
    if (!data)
      throw new Error("ExpGolomb data params is required");
    this._data = data;
    this._bytesAvailable = data.byteLength;
    if (this._bytesAvailable)
      this._loadWord();
  }
  _createClass2(ExpGolomb2, [{
    key: "bitsAvailable",
    get: function get() {
      return this._bitsAvailable;
    }
  }, {
    key: "_loadWord",
    value: function _loadWord() {
      var position = this._data.byteLength - this._bytesAvailable;
      var availableBytes = Math.min(4, this._bytesAvailable);
      if (availableBytes === 0)
        throw new Error("No bytes available");
      var workingBytes = new Uint8Array(4);
      workingBytes.set(this._data.subarray(position, position + availableBytes));
      this._word = new DataView(workingBytes.buffer).getUint32(0);
      this._bitsAvailable = availableBytes * 8;
      this._bytesAvailable -= availableBytes;
    }
  }, {
    key: "skipBits",
    value: function skipBits(count) {
      if (this._bitsAvailable > count) {
        this._word <<= count;
        this._bitsAvailable -= count;
      } else {
        count -= this._bitsAvailable;
        var skipBytes = Math.floor(count / 8);
        count -= skipBytes * 8;
        this._bytesAvailable -= skipBytes;
        this._loadWord();
        this._word <<= count;
        this._bitsAvailable -= count;
      }
    }
  }, {
    key: "readBits",
    value: function readBits(size) {
      if (size > 32) {
        throw new Error("Cannot read more than 32 bits");
      }
      var bits = Math.min(this._bitsAvailable, size);
      var val = this._word >>> 32 - bits;
      this._bitsAvailable -= bits;
      if (this._bitsAvailable > 0) {
        this._word <<= bits;
      } else if (this._bytesAvailable > 0) {
        this._loadWord();
      }
      bits = size - bits;
      if (bits > 0 && this._bitsAvailable) {
        return val << bits | this.readBits(bits);
      }
      return val;
    }
  }, {
    key: "skipLZ",
    value: function skipLZ() {
      var leadingZeroCount;
      for (leadingZeroCount = 0; leadingZeroCount < this._bitsAvailable; ++leadingZeroCount) {
        if ((this._word & 2147483648 >>> leadingZeroCount) !== 0) {
          this._word <<= leadingZeroCount;
          this._bitsAvailable -= leadingZeroCount;
          return leadingZeroCount;
        }
      }
      this._loadWord();
      return leadingZeroCount + this.skipLZ();
    }
  }, {
    key: "skipUEG",
    value: function skipUEG() {
      this.skipBits(1 + this.skipLZ());
    }
  }, {
    key: "readUEG",
    value: function readUEG() {
      var clz = this.skipLZ();
      return this.readBits(clz + 1) - 1;
    }
  }, {
    key: "readEG",
    value: function readEG() {
      var val = this.readUEG();
      if (1 & val) {
        return 1 + val >>> 1;
      }
      return -1 * (val >>> 1);
    }
  }, {
    key: "readBool",
    value: function readBool() {
      return this.readBits(1) === 1;
    }
  }, {
    key: "readUByte",
    value: function readUByte() {
      return this.readBits(8);
    }
  }, {
    key: "skipScalingList",
    value: function skipScalingList(count) {
      var lastScale = 8;
      var nextScale = 8;
      var deltaScale;
      for (var j = 0; j < count; j++) {
        if (nextScale !== 0) {
          deltaScale = this.readEG();
          nextScale = (lastScale + deltaScale + 256) % 256;
        }
        lastScale = nextScale === 0 ? lastScale : nextScale;
      }
    }
  }]);
  return ExpGolomb2;
}();

// node_modules/xgplayer-transmuxer/es/codec/avc.js
var AVC = function() {
  function AVC2() {
    _classCallCheck2(this, AVC2);
  }
  _createClass2(AVC2, null, [{
    key: "parseAVCDecoderConfigurationRecord",
    value: function parseAVCDecoderConfigurationRecord(data) {
      if (data.length < 7)
        return;
      var nalUnitSize = (data[4] & 3) + 1;
      var spsParsed;
      var spsArr = [];
      var ppsArr = [];
      var offset = 6;
      var spsCount = data[5] & 31;
      var spsSize;
      for (var i = 0; i < spsCount; i++) {
        spsSize = data[offset] << 8 | data[offset + 1];
        offset += 2;
        if (!spsSize)
          continue;
        var sps = data.subarray(offset, offset + spsSize);
        offset += spsSize;
        spsArr.push(sps);
        if (!spsParsed) {
          spsParsed = AVC2.parseSPS(NALu.removeEPB(sps));
        }
      }
      var ppsCount = data[offset];
      offset++;
      var ppsSize;
      for (var _i = 0; _i < ppsCount; _i++) {
        ppsSize = data[offset] << 8 | data[offset + 1];
        offset += 2;
        if (!ppsSize)
          continue;
        ppsArr.push(data.subarray(offset, offset + ppsSize));
        offset += ppsSize;
      }
      return {
        sps: spsParsed,
        spsArr,
        ppsArr,
        nalUnitSize
      };
    }
  }, {
    key: "parseSPS",
    value: function parseSPS(unit) {
      var eg = new ExpGolomb(unit);
      eg.readUByte();
      var profileIdc = eg.readUByte();
      var profileCompatibility = eg.readUByte();
      var levelIdc = eg.readUByte();
      eg.skipUEG();
      var chromaFormat = 420;
      if (profileIdc === 100 || profileIdc === 110 || profileIdc === 122 || profileIdc === 244 || profileIdc === 44 || profileIdc === 83 || profileIdc === 86 || profileIdc === 118 || profileIdc === 128 || profileIdc === 138 || profileIdc === 144) {
        var chromaFormatIdc = eg.readUEG();
        if (chromaFormatIdc <= 3)
          chromaFormat = [0, 420, 422, 444][chromaFormatIdc];
        if (chromaFormatIdc === 3)
          eg.skipBits(1);
        eg.skipUEG();
        eg.skipUEG();
        eg.skipBits(1);
        if (eg.readBool()) {
          var scalingListCount = chromaFormatIdc !== 3 ? 8 : 12;
          for (var i = 0; i < scalingListCount; i++) {
            if (eg.readBool()) {
              if (i < 6) {
                eg.skipScalingList(16);
              } else {
                eg.skipScalingList(64);
              }
            }
          }
        }
      }
      eg.skipUEG();
      var picOrderCntType = eg.readUEG();
      if (picOrderCntType === 0) {
        eg.readUEG();
      } else if (picOrderCntType === 1) {
        eg.skipBits(1);
        eg.skipUEG();
        eg.skipUEG();
        var numRefFramesInPicOrderCntCycle = eg.readUEG();
        for (var _i2 = 0; _i2 < numRefFramesInPicOrderCntCycle; _i2++) {
          eg.skipUEG();
        }
      }
      eg.skipUEG();
      eg.skipBits(1);
      var picWidthInMbsMinus1 = eg.readUEG();
      var picHeightInMapUnitsMinus1 = eg.readUEG();
      var frameMbsOnlyFlag = eg.readBits(1);
      if (frameMbsOnlyFlag === 0)
        eg.skipBits(1);
      eg.skipBits(1);
      var frameCropLeftOffset = 0;
      var frameCropRightOffset = 0;
      var frameCropTopOffset = 0;
      var frameCropBottomOffset = 0;
      if (eg.readBool()) {
        frameCropLeftOffset = eg.readUEG();
        frameCropRightOffset = eg.readUEG();
        frameCropTopOffset = eg.readUEG();
        frameCropBottomOffset = eg.readUEG();
      }
      var sarRatio;
      var fixedFrame;
      var fpsNum;
      var fpsDen;
      var fps;
      if (eg.readBool()) {
        if (eg.readBool()) {
          var aspectRatioIdc = eg.readUByte();
          switch (aspectRatioIdc) {
            case 1:
              sarRatio = [1, 1];
              break;
            case 2:
              sarRatio = [12, 11];
              break;
            case 3:
              sarRatio = [10, 11];
              break;
            case 4:
              sarRatio = [16, 11];
              break;
            case 5:
              sarRatio = [40, 33];
              break;
            case 6:
              sarRatio = [24, 11];
              break;
            case 7:
              sarRatio = [20, 11];
              break;
            case 8:
              sarRatio = [32, 11];
              break;
            case 9:
              sarRatio = [80, 33];
              break;
            case 10:
              sarRatio = [18, 11];
              break;
            case 11:
              sarRatio = [15, 11];
              break;
            case 12:
              sarRatio = [64, 33];
              break;
            case 13:
              sarRatio = [160, 99];
              break;
            case 14:
              sarRatio = [4, 3];
              break;
            case 15:
              sarRatio = [3, 2];
              break;
            case 16:
              sarRatio = [2, 1];
              break;
            case 255: {
              sarRatio = [eg.readUByte() << 8 | eg.readUByte(), eg.readUByte() << 8 | eg.readUByte()];
              break;
            }
          }
        }
        if (eg.readBool())
          eg.readBool();
        if (eg.readBool()) {
          eg.readBits(4);
          if (eg.readBool())
            eg.readBits(24);
        }
        if (eg.readBool()) {
          eg.readUEG();
          eg.readUEG();
        }
        if (eg.readBool()) {
          var numUnitsInTick = eg.readBits(32);
          var timeScale = eg.readBits(32);
          fixedFrame = eg.readBool();
          fpsNum = timeScale;
          fpsDen = numUnitsInTick * 2;
          fps = fpsNum / fpsDen;
        }
      }
      return {
        codec: getAvcCodec(unit.subarray(1, 4)),
        profileIdc,
        profileCompatibility,
        levelIdc,
        chromaFormat,
        width: Math.ceil((picWidthInMbsMinus1 + 1) * 16 - 2 * (frameCropLeftOffset + frameCropRightOffset)),
        height: (2 - frameMbsOnlyFlag) * (picHeightInMapUnitsMinus1 + 1) * 16 - (frameMbsOnlyFlag ? 2 : 4) * (frameCropTopOffset + frameCropBottomOffset),
        sarRatio,
        fpsNum,
        fpsDen,
        fps,
        fixedFrame
      };
    }
  }]);
  return AVC2;
}();

// node_modules/xgplayer-transmuxer/es/codec/hevc.js
var HEVC = function() {
  function HEVC2() {
    _classCallCheck2(this, HEVC2);
  }
  _createClass2(HEVC2, null, [{
    key: "parseHEVCDecoderConfigurationRecord",
    value: function parseHEVCDecoderConfigurationRecord(data) {
      var hvcC = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
      if (data.length < 23)
        return;
      hvcC = hvcC || {};
      var nalUnitSize = (data[21] & 3) + 1;
      var vpsParsed;
      var spsParsed;
      var spsArr = [];
      var ppsArr = [];
      var vpsArr = [];
      var offset = 23;
      var numOfArrays = data[22];
      var nalUnitType;
      var numNalus;
      var nalSize;
      for (var i = 0; i < numOfArrays; i++) {
        nalUnitType = data[offset] & 63;
        numNalus = data[offset + 1] << 8 | data[offset + 2];
        offset += 3;
        for (var j = 0; j < numNalus; j++) {
          nalSize = data[offset] << 8 | data[offset + 1];
          offset += 2;
          if (!nalSize)
            continue;
          switch (nalUnitType) {
            case 32:
              {
                var vps = data.subarray(offset, offset + nalSize);
                if (!vpsParsed)
                  vpsParsed = HEVC2.parseVPS(NALu.removeEPB(vps), hvcC);
                vpsArr.push(vps);
              }
              break;
            case 33:
              {
                var sps = data.subarray(offset, offset + nalSize);
                if (!spsParsed)
                  spsParsed = HEVC2.parseSPS(NALu.removeEPB(sps), hvcC);
                spsArr.push(sps);
              }
              break;
            case 34:
              ppsArr.push(data.subarray(offset, offset + nalSize));
              break;
          }
          offset += nalSize;
        }
      }
      return {
        hvcC,
        sps: spsParsed,
        spsArr,
        ppsArr,
        vpsArr,
        nalUnitSize
      };
    }
  }, {
    key: "parseVPS",
    value: function parseVPS(unit, hvcC) {
      hvcC = hvcC || {};
      var eg = new ExpGolomb(unit);
      eg.readUByte();
      eg.readUByte();
      eg.readBits(12);
      var vpsMaxSubLayersMinus1 = eg.readBits(3);
      hvcC.numTemporalLayers = Math.max(hvcC.numTemporalLayers || 0, vpsMaxSubLayersMinus1 + 1);
      eg.readBits(17);
      HEVC2._parseProfileTierLevel(eg, vpsMaxSubLayersMinus1, hvcC);
      return hvcC;
    }
  }, {
    key: "parseSPS",
    value: function parseSPS(unit) {
      var hvcC = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
      hvcC = hvcC || {};
      var eg = new ExpGolomb(unit);
      eg.readUByte();
      eg.readUByte();
      eg.readBits(4);
      var spsMaxSubLayersMinus1 = eg.readBits(3);
      hvcC.numTemporalLayers = Math.max(spsMaxSubLayersMinus1 + 1, hvcC.numTemporalLayers || 0);
      hvcC.temporalIdNested = eg.readBits(1);
      HEVC2._parseProfileTierLevel(eg, spsMaxSubLayersMinus1, hvcC);
      eg.readUEG();
      var chromaFormatIdc = hvcC.chromaFormatIdc = eg.readUEG();
      var chromaFormat = 420;
      if (chromaFormatIdc <= 3)
        chromaFormat = [0, 420, 422, 444][chromaFormatIdc];
      var separateColourPlaneFlag = 0;
      if (chromaFormatIdc === 3) {
        separateColourPlaneFlag = eg.readBits(1);
      }
      var width = eg.readUEG();
      var height = eg.readUEG();
      var conformanceWindowFlag = eg.readBits(1);
      var confWinLeftOffset;
      var confWinRightOffset;
      var confWinTopOffset;
      var confWinBottomOffset;
      if (conformanceWindowFlag === 1) {
        confWinLeftOffset = eg.readUEG();
        confWinRightOffset = eg.readUEG();
        confWinTopOffset = eg.readUEG();
        confWinBottomOffset = eg.readUEG();
      }
      hvcC.bitDepthLumaMinus8 = eg.readUEG();
      hvcC.bitDepthChromaMinus8 = eg.readUEG();
      if (conformanceWindowFlag === 1) {
        var subWidthC = (chromaFormatIdc === 1 || chromaFormatIdc === 2) && separateColourPlaneFlag === 0 ? 2 : 1;
        var subHeightC = chromaFormatIdc === 1 && separateColourPlaneFlag === 0 ? 2 : 1;
        width -= subWidthC * (confWinRightOffset + confWinLeftOffset);
        height -= subHeightC * (confWinBottomOffset + confWinTopOffset);
      }
      return {
        codec: "hev1.1.6.L93.B0",
        width,
        height,
        chromaFormat,
        hvcC
      };
    }
  }, {
    key: "_parseProfileTierLevel",
    value: function _parseProfileTierLevel(eg, maxSubLayersMinus1, hvcC) {
      var generalTierFlag = hvcC.generalTierFlag || 0;
      hvcC.generalProfileSpace = eg.readBits(2);
      hvcC.generalTierFlag = Math.max(eg.readBits(1), generalTierFlag);
      hvcC.generalProfileIdc = Math.max(eg.readBits(5), hvcC.generalProfileIdc || 0);
      hvcC.generalProfileCompatibilityFlags = eg.readBits(32);
      hvcC.generalConstraintIndicatorFlags = [eg.readBits(8), eg.readBits(8), eg.readBits(8), eg.readBits(8), eg.readBits(8), eg.readBits(8)];
      var generalLevelIdc = eg.readBits(8);
      if (generalTierFlag < hvcC.generalTierFlag) {
        hvcC.generalLevelIdc = generalLevelIdc;
      } else {
        hvcC.generalLevelIdc = Math.max(generalLevelIdc, hvcC.generalLevelIdc || 0);
      }
      var subLayerProfilePresentFlag = [];
      var subLayerLevelPresentFlag = [];
      if (maxSubLayersMinus1 > eg.bitsAvailable) {
        throw new Error("maxSubLayersMinus inavlid size ".concat(maxSubLayersMinus1));
      }
      for (var j = 0; j < maxSubLayersMinus1; j++) {
        subLayerProfilePresentFlag[j] = eg.readBits(1);
        subLayerLevelPresentFlag[j] = eg.readBits(1);
      }
      if (maxSubLayersMinus1 > 0) {
        eg.readBits((8 - maxSubLayersMinus1) * 2);
      }
      for (var i = 0; i < maxSubLayersMinus1; i++) {
        if (subLayerProfilePresentFlag[i] !== 0) {
          eg.readBits(2);
          eg.readBits(1);
          eg.readBits(5);
          eg.readBits(16);
          eg.readBits(16);
          eg.readBits(4);
          eg.readBits(16);
          eg.readBits(16);
          eg.readBits(12);
        }
        if (subLayerLevelPresentFlag[i] !== 0) {
          eg.readBits(8);
        }
      }
    }
  }]);
  return HEVC2;
}();

// node_modules/xgplayer-transmuxer/es/utils/utf8.js
var UTF8 = function() {
  function UTF82() {
    _classCallCheck2(this, UTF82);
  }
  _createClass2(UTF82, null, [{
    key: "decode",
    value: function decode(uint8array) {
      var out = [];
      var input = uint8array;
      var i = 0;
      var length = uint8array.length;
      while (i < length) {
        if (input[i] < 128) {
          out.push(String.fromCharCode(input[i]));
          ++i;
          continue;
        } else if (input[i] < 192)
          ;
        else if (input[i] < 224) {
          if (UTF82._checkContinuation(input, i, 1)) {
            var ucs4 = (input[i] & 31) << 6 | input[i + 1] & 63;
            if (ucs4 >= 128) {
              out.push(String.fromCharCode(ucs4 & 65535));
              i += 2;
              continue;
            }
          }
        } else if (input[i] < 240) {
          if (UTF82._checkContinuation(input, i, 2)) {
            var _ucs = (input[i] & 15) << 12 | (input[i + 1] & 63) << 6 | input[i + 2] & 63;
            if (_ucs >= 2048 && (_ucs & 63488) !== 55296) {
              out.push(String.fromCharCode(_ucs & 65535));
              i += 3;
              continue;
            }
          }
        } else if (input[i] < 248) {
          if (UTF82._checkContinuation(input, i, 3)) {
            var _ucs2 = (input[i] & 7) << 18 | (input[i + 1] & 63) << 12 | (input[i + 2] & 63) << 6 | input[i + 3] & 63;
            if (_ucs2 > 65536 && _ucs2 < 1114112) {
              _ucs2 -= 65536;
              out.push(String.fromCharCode(_ucs2 >>> 10 | 55296));
              out.push(String.fromCharCode(_ucs2 & 1023 | 56320));
              i += 4;
              continue;
            }
          }
        }
        out.push(String.fromCharCode(65533));
        ++i;
      }
      return out.join("");
    }
  }, {
    key: "_checkContinuation",
    value: function _checkContinuation(uint8array, start, checkLength) {
      var array = uint8array;
      if (start + checkLength < array.length) {
        while (checkLength--) {
          if ((array[++start] & 192) !== 128) {
            return false;
          }
        }
        return true;
      } else {
        return false;
      }
    }
  }]);
  return UTF82;
}();

// node_modules/xgplayer-transmuxer/es/flv/amf.js
var AMF = function() {
  function AMF2() {
    _classCallCheck2(this, AMF2);
  }
  _createClass2(AMF2, null, [{
    key: "parse",
    value: function parse3(data) {
      if (data.length < 3)
        return;
      var ret = {};
      var name = AMF2._parseValue(new DataView(data.buffer, data.byteOffset, data.byteLength));
      var value = AMF2._parseValue(new DataView(data.buffer, data.byteOffset + name.size, data.byteLength - name.size));
      ret[name.data] = value.data;
      return ret;
    }
  }, {
    key: "_parseValue",
    value: function _parseValue(view) {
      var dataLen = view.byteLength;
      var type = view.getUint8(0);
      var offset = 1;
      var isEnd = false;
      var value;
      switch (type) {
        case 0:
          value = view.getFloat64(1);
          offset += 8;
          break;
        case 1: {
          value = !!view.getUint8(1);
          offset += 1;
          break;
        }
        case 2:
          {
            var _AMF$_parseString = AMF2._parseString(new DataView(view.buffer, view.byteOffset + offset, view.byteLength - offset)), data = _AMF$_parseString.data, size = _AMF$_parseString.size;
            value = data;
            offset += size;
          }
          break;
        case 3:
          {
            value = {};
            var terminal = 0;
            if ((view.getUint32(dataLen - 4) & 16777215) === 9) {
              terminal = 3;
            }
            while (offset < dataLen - 4) {
              var _AMF$_parseObject = AMF2._parseObject(new DataView(view.buffer, view.byteOffset + offset, view.byteLength - offset - terminal)), _size = _AMF$_parseObject.size, _data = _AMF$_parseObject.data, _isEnd = _AMF$_parseObject.isEnd;
              if (_isEnd)
                break;
              value[_data.name] = _data.value;
              offset += _size;
            }
            if (offset <= dataLen - 3) {
              var marker = view.getUint32(offset - 1) & 16777215;
              if (marker === 9)
                offset += 3;
            }
          }
          break;
        case 8:
          {
            value = {};
            offset += 4;
            var _terminal = 0;
            if ((view.getUint32(dataLen - 4) & 16777215) === 9) {
              _terminal = 3;
            }
            while (offset < dataLen - 8) {
              var _AMF$_parseObject2 = AMF2._parseObject(new DataView(view.buffer, view.byteOffset + offset, view.byteLength - offset - _terminal)), _size2 = _AMF$_parseObject2.size, _data2 = _AMF$_parseObject2.data, _isEnd2 = _AMF$_parseObject2.isEnd;
              if (_isEnd2)
                break;
              value[_data2.name] = _data2.value;
              offset += _size2;
            }
            if (offset <= dataLen - 3) {
              var _marker = view.getUint32(offset - 1) & 16777215;
              if (_marker === 9) {
                offset += 3;
              }
            }
          }
          break;
        case 9:
          value = void 0;
          offset = 1;
          isEnd = true;
          break;
        case 10:
          {
            value = [];
            var strictArrayLength = view.getUint32(1);
            offset += 4;
            for (var i = 0; i < strictArrayLength; i++) {
              var _AMF$_parseValue = AMF2._parseValue(new DataView(view.buffer, view.byteOffset + offset, view.byteLength - offset)), _data3 = _AMF$_parseValue.data, _size3 = _AMF$_parseValue.size;
              value.push(_data3);
              offset += _size3;
            }
          }
          break;
        case 11:
          {
            var timestamp = view.getFloat64(offset) + view.getInt16(offset + 8) * 6e4;
            value = new Date(timestamp);
            offset += 10;
          }
          break;
        case 12:
          {
            var length = view.getUint32(1);
            offset += 4;
            value = "";
            if (length > 0) {
              value = UTF8.decode(new Uint8Array(view.buffer, view.byteOffset + offset, length));
            }
            offset += length;
          }
          break;
        default:
          offset = dataLen;
          break;
      }
      return {
        data: value,
        size: offset,
        isEnd
      };
    }
  }, {
    key: "_parseString",
    value: function _parseString(view) {
      var length = view.getUint16(0);
      var data = "";
      if (length > 0) {
        data = UTF8.decode(new Uint8Array(view.buffer, view.byteOffset + 2, length));
      }
      return {
        data,
        size: 2 + length
      };
    }
  }, {
    key: "_parseObject",
    value: function _parseObject(view) {
      if (view.byteLength < 3)
        return;
      var name = AMF2._parseString(view);
      var value = AMF2._parseValue(new DataView(view.buffer, view.byteOffset + name.size, view.byteLength - name.size));
      return {
        data: {
          name: name.data,
          value: value.data
        },
        size: name.size + value.size,
        isEnd: value.isEnd
      };
    }
  }]);
  return AMF2;
}();

// node_modules/xgplayer-transmuxer/es/flv/index.js
var logger = new Logger("FlvDemuxer");
var FlvDemuxer = function() {
  function FlvDemuxer2(videoTrack, audioTrack, metadataTrack) {
    _classCallCheck2(this, FlvDemuxer2);
    _defineProperty2(this, "_headerParsed", false);
    _defineProperty2(this, "_remainingData", null);
    _defineProperty2(this, "_gopId", 0);
    _defineProperty2(this, "_needAddMetaBeforeKeyFrameNal", true);
    this.videoTrack = videoTrack || new VideoTrack();
    this.audioTrack = audioTrack || new AudioTrack();
    this.metadataTrack = metadataTrack || new MetadataTrack();
    this._fixer = new FlvFixer(this.videoTrack, this.audioTrack, this.metadataTrack);
  }
  _createClass2(FlvDemuxer2, [{
    key: "demux",
    value: function demux(data) {
      var discontinuity = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : false;
      var contiguous = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : true;
      var audioTrack = this.audioTrack, videoTrack = this.videoTrack, metadataTrack = this.metadataTrack;
      if (discontinuity || !contiguous) {
        this._remainingData = null;
      }
      if (discontinuity) {
        this._headerParsed = false;
      }
      if (discontinuity) {
        videoTrack.reset();
        audioTrack.reset();
        metadataTrack.reset();
      } else {
        videoTrack.samples = [];
        audioTrack.samples = [];
        metadataTrack.seiSamples = [];
        metadataTrack.flvScriptSamples = [];
        videoTrack.warnings = [];
        audioTrack.warnings = [];
        if (this._remainingData) {
          data = concatUint8Array(this._remainingData, data);
          this._remainingData = null;
        }
      }
      if (!data.length) {
        return {
          videoTrack,
          audioTrack,
          metadataTrack
        };
      }
      var offset = 0;
      if (!this._headerParsed) {
        if (!FlvDemuxer2.probe(data)) {
          throw new Error("Invalid flv file");
        }
        audioTrack.present = (data[4] & 4) >>> 2 !== 0;
        videoTrack.present = (data[4] & 1) !== 0;
        this._headerParsed = true;
        offset = readBig32(data, 5) + 4;
      }
      var dataLen = data.length;
      var tagType;
      var dataSize;
      var timestamp;
      var bodyData;
      var prevTagSize;
      while (offset + 15 < dataLen) {
        tagType = data[offset];
        dataSize = data[offset + 1] << 16 | data[offset + 2] << 8 | data[offset + 3];
        if (offset + 15 + dataSize > dataLen)
          break;
        timestamp = (data[offset + 7] << 24 >>> 0) + (data[offset + 4] << 16) + (data[offset + 5] << 8) + data[offset + 6];
        offset += 11;
        bodyData = data.subarray(offset, offset + dataSize);
        if (tagType === 8) {
          this._parseAudio(bodyData, timestamp);
        } else if (tagType === 9) {
          this._parseVideo(bodyData, timestamp);
        } else if (tagType === 18) {
          this._parseScript(bodyData, timestamp);
        } else {
          logger.warn("Invalid tag type: ".concat(tagType));
        }
        offset += dataSize;
        prevTagSize = readBig32(data, offset);
        if (prevTagSize !== 11 + dataSize) {
          logger.warn("Invalid PrevTagSize ".concat(prevTagSize, " (").concat(11 + dataSize, ")"));
        }
        offset += 4;
      }
      if (offset < dataLen) {
        this._remainingData = data.subarray(offset);
      }
      audioTrack.formatTimescale = videoTrack.formatTimescale = videoTrack.timescale = metadataTrack.timescale = 1e3;
      audioTrack.timescale = audioTrack.sampleRate || 0;
      if (!audioTrack.exist() && audioTrack.hasSample()) {
        audioTrack.reset();
      }
      if (!videoTrack.exist() && videoTrack.hasSample()) {
        videoTrack.reset();
      }
      return {
        videoTrack,
        audioTrack,
        metadataTrack
      };
    }
  }, {
    key: "fix",
    value: function fix(startTime, discontinuity, contiguous) {
      this._fixer.fix(startTime, discontinuity, contiguous);
      return {
        videoTrack: this.videoTrack,
        audioTrack: this.audioTrack,
        metadataTrack: this.metadataTrack
      };
    }
  }, {
    key: "demuxAndFix",
    value: function demuxAndFix(data, discontinuity, contiguous, startTime) {
      this.demux(data, discontinuity, contiguous);
      return this.fix(startTime, discontinuity, contiguous);
    }
  }, {
    key: "_parseAudio",
    value: function _parseAudio(data, pts) {
      if (!data.length)
        return;
      var format = (data[0] & 240) >>> 4;
      var track = this.audioTrack;
      if (format !== 10 && format !== 7 && format !== 8) {
        logger.warn("Unsupported sound format: ".concat(format));
        track.reset();
        return;
      }
      if (format !== 10) {
        var soundRate = (data[0] & 12) >> 2;
        var soundSize = (data[0] & 2) >> 1;
        var soundType = data[0] & 1;
        track.sampleRate = FlvDemuxer2.AUDIO_RATE[soundRate];
        track.sampleSize = soundSize ? 16 : 8;
        track.channelCount = soundType + 1;
      }
      if (format === 10) {
        this._parseAac(data, pts);
      } else {
        this._parseG711(data, pts, format);
      }
    }
  }, {
    key: "_parseG711",
    value: function _parseG711(data, pts, format) {
      var track = this.audioTrack;
      track.codecType = format === 7 ? AudioCodecType.G711PCMA : AudioCodecType.G711PCMU;
      track.sampleRate = 8e3;
      track.codec = track.codecType;
      track.samples.push(new AudioSample(pts, data.subarray(1)));
    }
  }, {
    key: "_parseAac",
    value: function _parseAac(data, pts) {
      var track = this.audioTrack;
      track.codecType = AudioCodecType.AAC;
      if (data[1] === 0) {
        var ret = AAC.parseAudioSpecificConfig(data.subarray(2));
        if (ret) {
          track.codec = ret.codec;
          track.channelCount = ret.channelCount;
          track.sampleRate = ret.sampleRate;
          track.config = ret.config;
          track.objectType = ret.objectType;
          track.sampleRateIndex = ret.samplingFrequencyIndex;
        } else {
          track.reset();
          logger.warn("Cannot parse AudioSpecificConfig", data);
        }
      } else if (data[1] === 1) {
        if (pts === void 0 || pts === null)
          return;
        track.samples.push(new AudioSample(pts, data.subarray(2)));
      } else {
        logger.warn("Unknown AACPacketType: ".concat(data[1]));
      }
    }
  }, {
    key: "_parseVideo",
    value: function _parseVideo(data, dts) {
      var _this = this;
      if (data.length < 6)
        return;
      var frameType = (data[0] & 240) >>> 4;
      var codecId = data[0] & 15;
      var track = this.videoTrack;
      if (codecId !== 7 && codecId !== 12) {
        track.reset();
        logger.warn("Unsupported codecId: ".concat(codecId));
        return;
      }
      var isHevc = codecId === 12;
      track.codecType = isHevc ? VideoCodecType.HEVC : VideoCodecType.AVC;
      var packetType = data[1];
      var cts = (data[2] << 16 | data[3] << 8 | data[4]) << 8 >> 8;
      if (packetType === 0) {
        var configData = data.subarray(5);
        var ret = isHevc ? HEVC.parseHEVCDecoderConfigurationRecord(configData) : AVC.parseAVCDecoderConfigurationRecord(configData);
        if (ret) {
          var hvcC = ret.hvcC, sps = ret.sps, ppsArr = ret.ppsArr, spsArr = ret.spsArr, vpsArr = ret.vpsArr, nalUnitSize = ret.nalUnitSize;
          if (hvcC) {
            track.hvcC = track.hvcC || hvcC;
          }
          if (sps) {
            track.codec = sps.codec;
            track.width = sps.width;
            track.height = sps.height;
            track.sarRatio = sps.sarRatio;
            track.fpsNum = sps.fpsNum;
            track.fpsDen = sps.fpsDen;
          }
          if (spsArr.length)
            track.sps = spsArr;
          if (ppsArr.length)
            track.pps = ppsArr;
          if (vpsArr && vpsArr.length)
            track.vps = vpsArr;
          if (nalUnitSize)
            track.nalUnitSize = nalUnitSize;
        } else {
          logger.warn("Cannot parse ".concat(isHevc ? "HEVC" : "AVC", "DecoderConfigurationRecord"), data);
        }
      } else if (packetType === 1) {
        var units = NALu.parseAvcC(data.subarray(5), track.nalUnitSize);
        units = this._checkAddMetaNalToUnits(isHevc, units, track);
        if (units && units.length) {
          var sample = new VideoSample(dts + cts, dts, units);
          if (frameType === 1) {
            sample.setToKeyframe();
          }
          track.samples.push(sample);
          units.forEach(function(unit) {
            var type = isHevc ? unit[0] >>> 1 & 63 : unit[0] & 31;
            switch (type) {
              case 5:
              case 16:
              case 17:
              case 18:
              case 19:
              case 20:
              case 21:
              case 22:
              case 23:
                if (!isHevc && type !== 5 || isHevc && type === 5)
                  break;
                sample.setToKeyframe();
                break;
              case 6:
              case 39:
              case 40:
                if (!isHevc && type !== 6 || isHevc && type === 6)
                  break;
                _this.metadataTrack.seiSamples.push(new SeiSample(NALu.parseSEI(NALu.removeEPB(unit), isHevc), dts + cts));
                break;
            }
          });
          if (sample.keyframe) {
            this._gopId++;
          }
          sample.gopId = this._gopId;
        } else {
          logger.warn("Cannot parse NALUs", data);
        }
      } else if (packetType === 2)
        ;
      else {
        logger.warn("Unknown AVCPacketType: ".concat(packetType));
      }
    }
  }, {
    key: "_checkAddMetaNalToUnits",
    value: function _checkAddMetaNalToUnits(hevc, units, track) {
      if (!hevc || !this._needAddMetaBeforeKeyFrameNal) {
        this._needAddMetaBeforeKeyFrameNal = false;
        return units;
      }
      var nalTypes = units.map(function(x2) {
        return x2[0] >>> 1 & 63;
      });
      if (nalTypes.includes(32)) {
        this._needAddMetaBeforeKeyFrameNal = false;
        return units;
      }
      units.unshift(track.pps[0]);
      units.unshift(track.sps[0]);
      units.unshift(track.vps[0]);
      return units.filter(Boolean);
    }
  }, {
    key: "_parseScript",
    value: function _parseScript(data, pts) {
      this.metadataTrack.flvScriptSamples.push(new FlvScriptSample(AMF.parse(data), pts));
    }
  }], [{
    key: "probe",
    value: function probe(data) {
      if (data[0] !== 70 || data[1] !== 76 || data[2] !== 86 || data[3] !== 1) {
        return false;
      }
      return readBig32(data, 5) >= 9;
    }
  }]);
  return FlvDemuxer2;
}();
_defineProperty2(FlvDemuxer, "AUDIO_RATE", [5500, 11e3, 22e3, 44e3]);

// node_modules/xgplayer-transmuxer/es/mpeg-ts/fixer.js
var LARGE_AV_FIRST_FRAME_GAP2 = 9e4 / 2;
var AUDIO_GAP_OVERLAP_THRESHOLD_COUNT2 = 3;
var MAX_SILENT_FRAME_DURATION2 = 9e4;
var AUDIO_EXCETION_LOG_EMIT_DURATION2 = 5 * 9e4;
var MAX_VIDEO_FRAME_DURATION2 = 9e4;
var MAX_DTS_DELTA_WITH_NEXT_CHUNK2 = 9e4 / 2;
var TsFixer = function() {
  function TsFixer2(videoTrack, audioTrack, metadataTrack) {
    _classCallCheck2(this, TsFixer2);
    this.videoTrack = videoTrack;
    this.audioTrack = audioTrack;
    this.metadataTrack = metadataTrack;
    this._baseDts = -1;
    this._baseDtsInited = false;
    this._audioNextPts = void 0;
    this._videoNextDts = void 0;
    this._audioTimestampBreak = false;
    this._videoTimestampBreak = false;
    this._lastAudioExceptionGapDot = 0;
    this._lastAudioExceptionOverlapDot = 0;
    this._lastAudioExceptionLargeGapDot = 0;
  }
  _createClass2(TsFixer2, [{
    key: "fix",
    value: function fix() {
      var _this = this;
      var startTime = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : 0;
      var discontinuity = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : false;
      var contiguous = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : true;
      startTime = Math.round(startTime * 9e4);
      var videoTrack = this.videoTrack;
      var audioTrack = this.audioTrack;
      var vSamples = videoTrack.samples;
      var aSamples = audioTrack.samples;
      if (!vSamples.length && !aSamples.length)
        return;
      var firstVideoSample = vSamples[0];
      var firstAudioSample = aSamples[0];
      var vaDelta = 0;
      if (vSamples.length && aSamples.length) {
        vaDelta = firstVideoSample.dts - firstAudioSample.pts;
      }
      if (!this._baseDtsInited) {
        this._calculateBaseDts(this.audioTrack, this.videoTrack);
      }
      if (discontinuity) {
        this._calculateBaseDts(this.audioTrack, this.videoTrack);
        this._baseDts -= startTime;
      }
      if (!contiguous) {
        this._videoNextDts = vaDelta > 0 ? startTime + vaDelta : startTime;
        this._audioNextPts = vaDelta > 0 ? startTime : startTime - vaDelta;
        var vDeltaToNextDts = firstVideoSample ? firstVideoSample.dts - this._baseDts - this._videoNextDts : 0;
        var aDeltaToNextDts = firstAudioSample ? firstAudioSample.pts - this._baseDts - this._audioNextPts : 0;
        if (Math.abs(vDeltaToNextDts || aDeltaToNextDts) > MAX_VIDEO_FRAME_DURATION2) {
          this._calculateBaseDts(this.audioTrack, this.videoTrack);
          this._baseDts -= startTime;
        }
      }
      this._resetBaseDtsWhenStreamBreaked();
      this._fixAudio(audioTrack);
      this._fixVideo(videoTrack);
      if (this.metadataTrack.exist()) {
        var timescale = this.metadataTrack.timescale;
        this.metadataTrack.seiSamples.forEach(function(s) {
          s.pts = s.originPts - _this._baseDts;
          s.time = Math.max(0, s.pts) / timescale;
        });
      }
      if (videoTrack.samples.length) {
        videoTrack.baseMediaDecodeTime = videoTrack.samples[0].dts;
      }
      if (audioTrack.samples.length) {
        audioTrack.baseMediaDecodeTime = audioTrack.samples[0].pts * audioTrack.timescale / 9e4;
      }
    }
  }, {
    key: "_fixVideo",
    value: function _fixVideo(videoTrack) {
      var _this2 = this;
      var samples = videoTrack.samples;
      if (!samples.length)
        return;
      samples.forEach(function(x2) {
        x2.dts -= _this2._baseDts;
        x2.pts -= _this2._baseDts;
      });
      if (this._videoNextDts === void 0) {
        var samp0 = samples[0];
        this._videoNextDts = samp0.dts;
      }
      var len = samples.length;
      var sampleDuration = 0;
      var firstSample = samples[0];
      var nextSample = samples[1];
      var vDelta = this._videoNextDts - firstSample.dts;
      if (Math.abs(vDelta) > MAX_DTS_DELTA_WITH_NEXT_CHUNK2) {
        var _samples$;
        videoTrack.warnings.push({
          type: WarningType.LARGE_VIDEO_GAP_BETWEEN_CHUNK,
          nextDts: this._videoNextDts / 90,
          firstSampleDts: firstSample.dts / 90,
          nextSampleDts: (((_samples$ = samples[1]) === null || _samples$ === void 0 ? void 0 : _samples$.dts) || 0) / 90,
          sampleDuration: vDelta / 90
        });
        firstSample.dts += vDelta;
        firstSample.pts += vDelta;
        if (nextSample && Math.abs(nextSample.dts - firstSample.dts) > MAX_VIDEO_FRAME_DURATION2) {
          this._videoTimestampBreak = true;
          samples.forEach(function(x2, i2) {
            if (i2 === 0)
              return;
            x2.dts += vDelta;
            x2.pts += vDelta;
          });
        } else {
          for (var i = 1; i < len - 1; i++) {
            var _samples$i;
            var dts = (_samples$i = samples[i]) === null || _samples$i === void 0 ? void 0 : _samples$i.dts;
            var prevDts = samples[i - 1].dts;
            if (dts && dts - prevDts < 0) {
              samples[i].dts += vDelta;
              samples[i].pts += vDelta;
            }
          }
        }
      }
      var refSampleDurationInt;
      if (videoTrack.fpsNum && videoTrack.fpsDen) {
        refSampleDurationInt = videoTrack.timescale * (videoTrack.fpsDen / videoTrack.fpsNum);
      }
      if (refSampleDurationInt < 90 * 10) {
        refSampleDurationInt = 0;
      }
      if (!refSampleDurationInt) {
        var first = videoTrack.samples[0];
        var second = videoTrack.samples[1];
        refSampleDurationInt = len === 1 ? 9e3 : Math.floor(second.dts - first.dts);
      }
      for (var _i = 0; _i < len; _i++) {
        var _dts = samples[_i].dts;
        var _nextSample = samples[_i + 1];
        if (_i < len - 1) {
          sampleDuration = _nextSample.dts - _dts;
        } else if (samples[_i - 1]) {
          sampleDuration = Math.min(_dts - samples[_i - 1].dts, refSampleDurationInt);
        } else {
          sampleDuration = refSampleDurationInt;
        }
        if (sampleDuration > MAX_VIDEO_FRAME_DURATION2 || sampleDuration < 0) {
          this._videoTimestampBreak = true;
          sampleDuration = this._audioTimestampBreak ? refSampleDurationInt : Math.max(sampleDuration, 30 * 90);
          var expectFragEnd = this._audioNextPts || 0;
          if (_nextSample && _nextSample.dts > expectFragEnd) {
            sampleDuration = refSampleDurationInt;
          }
          videoTrack.warnings.push({
            type: WarningType.LARGE_VIDEO_GAP,
            time: _dts / videoTrack.timescale,
            dts: _dts,
            originDts: samples[_i].originDts,
            nextDts: this._videoNextDts,
            sampleDuration,
            refSampleDuration: refSampleDurationInt
          });
        }
        samples[_i].duration = sampleDuration;
        this._videoNextDts += sampleDuration;
      }
    }
  }, {
    key: "_fixAudio",
    value: function _fixAudio(audioTrack) {
      var _this3 = this;
      var samples = audioTrack.samples;
      if (!samples.length)
        return;
      samples.forEach(function(x2) {
        x2.pts -= _this3._baseDts;
        x2.dts = x2.pts;
      });
      this._doFixAudioInternal(audioTrack, samples, 9e4);
    }
  }, {
    key: "_calculateBaseDts",
    value: function _calculateBaseDts(audioTrack, videoTrack) {
      var audioSamps = audioTrack.samples;
      var videoSamps = videoTrack.samples;
      if (!audioSamps.length && !videoSamps.length) {
        return false;
      }
      var audioBasePts = Infinity;
      var videoBaseDts = Infinity;
      if (audioSamps.length) {
        audioTrack.baseDts = audioBasePts = audioSamps[0].pts;
      }
      if (videoSamps.length) {
        videoTrack.baseDts = videoBaseDts = videoSamps[0].dts;
      }
      this._baseDts = Math.min(audioBasePts, videoBaseDts);
      var delta = videoBaseDts - audioBasePts;
      if (Number.isFinite(delta) && Math.abs(delta) > LARGE_AV_FIRST_FRAME_GAP2) {
        videoTrack.warnings.push({
          type: WarningType.LARGE_AV_SHIFT,
          videoBaseDts,
          audioBasePts,
          baseDts: this._baseDts,
          delta
        });
      }
      this._baseDtsInited = true;
      return true;
    }
  }, {
    key: "_resetBaseDtsWhenStreamBreaked",
    value: function _resetBaseDtsWhenStreamBreaked() {
      if (this._baseDtsInited && this._videoTimestampBreak && this._audioTimestampBreak) {
        var calc = this._calculateBaseDts(this.audioTrack, this.videoTrack);
        if (!calc)
          return;
        this._baseDts -= Math.min(this._audioNextPts, this._videoNextDts);
        this._audioLastSample = null;
        this._videoLastSample = null;
        this._videoTimestampBreak = false;
        this._audioTimestampBreak = false;
      }
    }
  }, {
    key: "_doFixAudioInternal",
    value: function _doFixAudioInternal(audioTrack, samples, timescale) {
      if (!audioTrack.sampleDuration)
        audioTrack.sampleDuration = AAC.getFrameDuration(audioTrack.timescale, timescale);
      var refSampleDuration = audioTrack.sampleDuration;
      if (this._audioNextPts === void 0) {
        var samp0 = samples[0];
        this._audioNextPts = samp0.pts;
      }
      for (var i = 0; i < samples.length; i++) {
        var nextPts = this._audioNextPts;
        var sample = samples[i];
        var delta = sample.pts - nextPts;
        if (!this._audioTimestampBreak && delta >= AUDIO_GAP_OVERLAP_THRESHOLD_COUNT2 * refSampleDuration && delta <= MAX_SILENT_FRAME_DURATION2 && !isSafari) {
          var silentFrame = AAC.getSilentFrame(audioTrack.codec, audioTrack.channelCount) || samples[0].data.subarray();
          var count = Math.floor(delta / refSampleDuration);
          if (Math.abs(sample.pts - this._lastAudioExceptionGapDot) > AUDIO_EXCETION_LOG_EMIT_DURATION2) {
            this._lastAudioExceptionGapDot = sample.pts;
          }
          audioTrack.warnings.push({
            type: WarningType.AUDIO_FILLED,
            pts: sample.pts / 90,
            originPts: sample.originPts,
            count,
            nextPts: nextPts / 90,
            refSampleDuration
          });
          for (var j = 0; j < count; j++) {
            var silentSample = new AudioSample(Math.floor(nextPts), silentFrame);
            silentSample.originPts = Math.floor(this._baseDts + nextPts);
            samples.splice(i, 0, silentSample);
            this._audioNextPts += refSampleDuration;
            i++;
          }
          i--;
        } else if (delta <= -AUDIO_GAP_OVERLAP_THRESHOLD_COUNT2 * refSampleDuration && delta >= -1 * MAX_SILENT_FRAME_DURATION2) {
          if (Math.abs(sample.pts - this._lastAudioExceptionOverlapDot) > AUDIO_EXCETION_LOG_EMIT_DURATION2) {
            this._lastAudioExceptionOverlapDot = sample.pts;
            audioTrack.warnings.push({
              type: WarningType.AUDIO_DROPPED,
              pts: sample.pts / 90,
              originPts: sample.originPts,
              nextPts: nextPts / 90,
              refSampleDuration
            });
          }
          samples.splice(i, 1);
          i--;
        } else {
          if (Math.abs(delta) >= MAX_SILENT_FRAME_DURATION2) {
            this._audioTimestampBreak = true;
            if (Math.abs(sample.pts - this._lastAudioExceptionLargeGapDot) > AUDIO_EXCETION_LOG_EMIT_DURATION2) {
              this._lastAudioExceptionLargeGapDot = sample.pts;
              audioTrack.warnings.push({
                type: WarningType.LARGE_AUDIO_GAP,
                time: sample.pts / 1e3,
                pts: sample.pts / 90,
                originPts: sample.originPts,
                nextPts: nextPts / 90,
                sampleDuration: delta,
                refSampleDuration
              });
            }
          }
          sample.dts = sample.pts = nextPts;
          this._audioNextPts += refSampleDuration;
        }
      }
    }
  }]);
  return TsFixer2;
}();

// node_modules/xgplayer-transmuxer/es/mpeg-ts/index.js
var logger2 = new Logger("TsDemuxer");
var TsDemuxer = function() {
  function TsDemuxer2(videoTrack, audioTrack, metadataTrack) {
    _classCallCheck2(this, TsDemuxer2);
    _defineProperty2(this, "_pmtId", -1);
    _defineProperty2(this, "_remainingPacketData", null);
    _defineProperty2(this, "_videoPesData", []);
    _defineProperty2(this, "_audioPesData", []);
    _defineProperty2(this, "_gopId", 0);
    this.videoTrack = videoTrack || new VideoTrack();
    this.audioTrack = audioTrack || new AudioTrack();
    this.metadataTrack = metadataTrack || new MetadataTrack();
    this._fixer = new TsFixer(this.videoTrack, this.audioTrack, this.metadataTrack);
  }
  _createClass2(TsDemuxer2, [{
    key: "demux",
    value: function demux(data) {
      var discontinuity = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : false;
      var contiguous = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : true;
      var audioTrack = this.audioTrack, videoTrack = this.videoTrack, metadataTrack = this.metadataTrack;
      if (discontinuity) {
        this._pmtId = -1;
        videoTrack.reset();
        audioTrack.reset();
        metadataTrack.reset();
      }
      if (!contiguous || discontinuity) {
        this._remainingPacketData = null;
        this._videoPesData = [];
        this._audioPesData = [];
      } else {
        videoTrack.samples = [];
        audioTrack.samples = [];
        metadataTrack.seiSamples = [];
        videoTrack.warnings = [];
        audioTrack.warnings = [];
        if (this._remainingPacketData) {
          data = concatUint8Array(this._remainingPacketData, data);
          this._remainingPacketData = null;
        }
      }
      var dataLen = data.length;
      var remainingLength = dataLen % 188;
      if (remainingLength) {
        this._remainingPacketData = data.subarray(dataLen - remainingLength);
        dataLen -= remainingLength;
      }
      var videoPid = videoTrack.pid;
      var audioPid = audioTrack.pid;
      for (var start = 0; start < dataLen; start += 188) {
        if (data[start] !== 71)
          throw new Error("TS packet did not start with 0x47");
        var payloadUnitStartIndicator = !!(data[start + 1] & 64);
        var pid = ((data[start + 1] & 31) << 8) + data[start + 2];
        var adaptationFiledControl = (data[start + 3] & 48) >> 4;
        var offset = void 0;
        if (adaptationFiledControl > 1) {
          offset = start + 5 + data[start + 4];
          if (offset === start + 188)
            continue;
        } else {
          offset = start + 4;
        }
        switch (pid) {
          case 0:
            if (payloadUnitStartIndicator)
              offset += data[offset] + 1;
            this._pmtId = (data[offset + 10] & 31) << 8 | data[offset + 11];
            break;
          case this._pmtId:
            {
              if (payloadUnitStartIndicator)
                offset += data[offset] + 1;
              var tableEnd = offset + 3 + ((data[offset + 1] & 15) << 8 | data[offset + 2]) - 4;
              var programInfoLength = (data[offset + 10] & 15) << 8 | data[offset + 11];
              offset += 12 + programInfoLength;
              while (offset < tableEnd) {
                var esPid = (data[offset + 1] & 31) << 8 | data[offset + 2];
                switch (data[offset]) {
                  case 15:
                    audioTrack.pid = audioPid = esPid;
                    break;
                  case 27:
                    if (videoPid !== -1)
                      break;
                    videoTrack.codecType = VideoCodecType.AVC;
                    videoTrack.pid = videoPid = esPid;
                    break;
                  case 36:
                    if (videoPid !== -1)
                      break;
                    videoTrack.codecType = VideoCodecType.HEVC;
                    videoTrack.pid = videoPid = esPid;
                    break;
                  default:
                    logger2.warn("Unsupported stream. type: ".concat(data[offset], ", pid: ").concat(esPid));
                }
                offset += ((data[offset + 3] & 15) << 8 | data[offset + 4]) + 5;
              }
            }
            break;
          case videoPid:
            if (payloadUnitStartIndicator && this._videoPesData.length) {
              this._parseVideoData();
            }
            this._videoPesData.push(data.subarray(offset, start + 188));
            break;
          case audioPid:
            if (payloadUnitStartIndicator && this._audioPesData.length) {
              this._parseAudioData();
            }
            this._audioPesData.push(data.subarray(offset, start + 188));
            break;
          case 17:
          case 8191:
            break;
          default:
            logger2.warn("Unknown pid: ".concat(pid));
        }
      }
      this._parseVideoData();
      this._parseAudioData();
      audioTrack.formatTimescale = videoTrack.formatTimescale = videoTrack.timescale = metadataTrack.timescale = 9e4;
      audioTrack.timescale = audioTrack.sampleRate || 0;
      return {
        videoTrack,
        audioTrack,
        metadataTrack
      };
    }
  }, {
    key: "fix",
    value: function fix(startTime, discontinuity, contiguous) {
      this._fixer.fix(startTime, discontinuity, contiguous);
      return {
        videoTrack: this.videoTrack,
        audioTrack: this.audioTrack,
        metadataTrack: this.metadataTrack
      };
    }
  }, {
    key: "demuxAndFix",
    value: function demuxAndFix(data, discontinuity, contiguous, startTime) {
      this.demux(data, discontinuity, contiguous);
      return this.fix(startTime, discontinuity, contiguous);
    }
  }, {
    key: "_parseVideoData",
    value: function _parseVideoData() {
      if (!this._videoPesData.length)
        return;
      var pes = TsDemuxer2._parsePES(concatUint8Array.apply(void 0, _toConsumableArray(this._videoPesData)));
      if (!pes) {
        logger2.warn("Cannot parse video pes", this._videoPesData);
        return;
      }
      var units = NALu.parseAnnexB(pes.data);
      if (units) {
        this._createVideoSample(units, pes.pts, pes.dts);
      } else {
        logger2.warn("Cannot parse avc units", pes);
      }
      this._videoPesData = [];
    }
  }, {
    key: "_createVideoSample",
    value: function _createVideoSample(units, pts, dts) {
      var _this = this;
      if (!units.length)
        return;
      var track = this.videoTrack;
      var isHevc = track.codecType === VideoCodecType.HEVC;
      var sample = new VideoSample(pts, dts);
      units.forEach(function(unit) {
        var type = isHevc ? unit[0] >>> 1 & 63 : unit[0] & 31;
        switch (type) {
          case 5:
          case 16:
          case 17:
          case 18:
          case 19:
          case 20:
          case 21:
          case 22:
          case 23:
            if (!isHevc && type !== 5 || isHevc && type === 5)
              break;
            sample.setToKeyframe();
            _this._gopId++;
            break;
          case 6:
          case 39:
          case 40:
            if (!isHevc && type !== 6 || isHevc && type === 6)
              break;
            _this.metadataTrack.seiSamples.push(new SeiSample(NALu.parseSEI(NALu.removeEPB(unit), isHevc), pts));
            return;
          case 32:
            if (!isHevc)
              break;
            if (!track.vps.length) {
              var hvcC = HEVC.parseVPS(NALu.removeEPB(unit), track.hvcC);
              track.hvcC = track.hvcC || hvcC;
              track.vps = [unit];
            }
            break;
          case 7:
          case 33:
            if (!isHevc && type !== 7 || isHevc && type === 7)
              break;
            if (!track.sps.length) {
              var data = NALu.removeEPB(unit);
              var spsInfo = isHevc ? HEVC.parseSPS(data, track.hvcC) : AVC.parseSPS(data);
              track.sps = [unit];
              track.hvcC = track.hvcC || spsInfo.hvcC;
              track.codec = spsInfo.codec;
              track.width = spsInfo.width;
              track.height = spsInfo.height;
              track.sarRatio = spsInfo.sarRatio;
              track.fpsNum = spsInfo.fpsNum;
              track.fpsDen = spsInfo.fpsDen;
            }
            break;
          case 8:
          case 34:
            if (!isHevc && type !== 8 || isHevc && type === 8)
              break;
            if (!track.pps.length)
              track.pps = [unit];
            break;
          case 9:
          case 35:
            break;
          case 38:
            if (isHevc) {
              var ffByteFound = false;
              for (var i = 2; i < unit.byteLength; i++) {
                if (unit[i] === 255) {
                  ffByteFound = true;
                  break;
                }
              }
              if (!ffByteFound) {
                return;
              }
            }
            break;
        }
        sample.units.push(unit);
      });
      sample.gopId = this._gopId;
      this._pushVideoSample(track, sample);
    }
  }, {
    key: "_pushVideoSample",
    value: function _pushVideoSample(track, sample) {
      if (sample.units.length) {
        if (sample.pts === null || sample.pts === void 0) {
          logger2.warn("Video sample no pts", sample);
          var lastSample = track.samples[track.samples.length - 1];
          if (lastSample) {
            sample.pts = lastSample.pts;
            sample.dts = lastSample.dts;
          } else {
            logger2.warn("Drop video sample", sample);
          }
        } else {
          track.samples.push(sample);
        }
      }
    }
  }, {
    key: "_parseAudioData",
    value: function _parseAudioData() {
      if (!this._audioPesData.length)
        return;
      var pes = TsDemuxer2._parsePES(concatUint8Array.apply(void 0, _toConsumableArray(this._audioPesData)));
      if (!pes) {
        logger2.warn("Cannot parse audio pes", this._audioPesData);
        return;
      }
      this._parseAacData(pes);
      this._audioPesData = [];
    }
  }, {
    key: "_parseAacData",
    value: function _parseAacData(pes) {
      var track = this.audioTrack;
      var pts = pes.pts;
      if (pts === null || pts === void 0) {
        logger2.warn("AAC pes not pts", track);
        if (!track.samples.length || !track.sampleRate) {
          return;
        }
        pts = track.samples[track.samples.length - 1].pts + AAC.getFrameDuration(track.sampleRate);
      }
      var ret = AAC.parseADTS(pes.data, pts);
      if (ret) {
        var _track$samples;
        track.codec = ret.codec;
        track.channelCount = ret.channelCount;
        track.sampleRate = ret.sampleRate;
        track.objectType = ret.objectType;
        track.sampleRateIndex = ret.samplingFrequencyIndex;
        track.config = ret.config;
        (_track$samples = track.samples).push.apply(_track$samples, _toConsumableArray(ret.frames.map(function(s) {
          return new AudioSample(s.pts, s.data);
        })));
        if (ret.skip) {
          logger2.warn("Skip aac adts ".concat(ret.skip, " bits"));
        }
        if (ret.remaining) {
          logger2.warn("Remaining aac adts ".concat(ret.remaining, " bits"));
        }
      } else {
        logger2.warn("Cannot parse aac adts", pes);
      }
    }
  }], [{
    key: "probe",
    value: function probe(data) {
      if (!data.length)
        return false;
      return data[0] === 71 && data[188] === 71 && data[376] === 71;
    }
  }, {
    key: "_parsePES",
    value: function _parsePES(data) {
      var headerDataLen = data[8];
      if (headerDataLen === null || headerDataLen === void 0 || data.length < headerDataLen + 9)
        return;
      var startPrefix = data[0] << 16 | data[1] << 8 | data[2];
      if (startPrefix !== 1)
        return;
      var pesLen = (data[4] << 8) + data[5];
      if (pesLen && pesLen > data.length - 6)
        return;
      var pts;
      var dts;
      var ptsDtsFlags = data[7];
      if (ptsDtsFlags & 192) {
        pts = (data[9] & 14) * 536870912 + (data[10] & 255) * 4194304 + (data[11] & 254) * 16384 + (data[12] & 255) * 128 + (data[13] & 254) / 2;
        if (ptsDtsFlags & 64) {
          dts = (data[14] & 14) * 536870912 + (data[15] & 255) * 4194304 + (data[16] & 254) * 16384 + (data[17] & 255) * 128 + (data[18] & 254) / 2;
          if (pts - dts > 60 * 9e4)
            pts = dts;
        } else {
          dts = pts;
        }
      }
      return {
        data: data.subarray(9 + headerDataLen),
        pts,
        dts
      };
    }
  }]);
  return TsDemuxer2;
}();

// node_modules/xgplayer-transmuxer/es/mp4/mp4-parser.js
var MP4Parser = function() {
  function MP4Parser2() {
    _classCallCheck2(this, MP4Parser2);
  }
  _createClass2(MP4Parser2, null, [{
    key: "findBox",
    value: function findBox(data, names) {
      var start = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 0;
      var ret = [];
      if (!data)
        return ret;
      var size = 0;
      var type = "";
      var headerSize = 0;
      while (data.length > 7) {
        size = readBig32(data);
        type = String.fromCharCode.apply(null, data.subarray(4, 8));
        headerSize = 8;
        if (size === 1) {
          size = readBig64(data, 8);
          headerSize += 8;
        } else if (!size) {
          size = data.length;
        }
        if (!names[0] || type === names[0]) {
          var subData = data.subarray(0, size);
          if (names.length < 2) {
            ret.push({
              start,
              size,
              headerSize,
              type,
              data: subData
            });
          } else {
            return MP4Parser2.findBox(subData.subarray(headerSize), names.slice(1), start + headerSize);
          }
        }
        start += size;
        data = data.subarray(size);
      }
      return ret;
    }
  }, {
    key: "tfhd",
    value: function tfhd(box) {
      return parseBox(box, true, function(ret, data) {
        ret.trackId = readBig32(data);
        var start = 4;
        var baseDataOffsetPresent = ret.flags & 255 & 1;
        var sampleDescriptionIndexPresent = ret.flags & 255 & 2;
        var defaultSampleDurationPresent = ret.flags & 255 & 8;
        var defaultSampleSizePresent = ret.flags & 255 & 16;
        var defaultSampleFlagsPresent = ret.flags & 255 & 32;
        if (baseDataOffsetPresent) {
          start += 4;
          ret.baseDataOffset = readBig32(data, start);
          start += 4;
        }
        if (sampleDescriptionIndexPresent) {
          ret.sampleDescriptionIndex = readBig32(data, start);
          start += 4;
        }
        if (defaultSampleDurationPresent) {
          ret.defaultSampleDuration = readBig32(data, start);
          start += 4;
        }
        if (defaultSampleSizePresent) {
          ret.defaultSampleSize = readBig32(data, start);
          start += 4;
        }
        if (defaultSampleFlagsPresent) {
          ret.defaultSampleFlags = readBig32(data, start);
        }
      });
    }
  }, {
    key: "sidx",
    value: function sidx(box) {
      return parseBox(box, true, function(ret, data) {
        var start = 0;
        ret.reference_ID = readBig32(data, start);
        start += 4;
        ret.timescale = readBig32(data, start);
        start += 4;
        if (ret.version === 0) {
          ret.earliest_presentation_time = readBig32(data, start);
          start += 4;
          ret.first_offset = readBig32(data, start);
          start += 4;
        } else {
          ret.earliest_presentation_time = readBig64(data, start);
          start += 8;
          ret.first_offset = readBig64(data, start);
          start += 8;
        }
        start += 2;
        ret.references = [];
        var count = readBig16(data, start);
        start += 2;
        for (var i = 0; i < count; i++) {
          var ref = {};
          ret.references.push(ref);
          var tmp32 = readBig32(data, start);
          start += 4;
          ref.reference_type = tmp32 >> 31 & 1;
          ref.referenced_size = tmp32 & 2147483647;
          ref.subsegment_duration = readBig32(data, start);
          start += 4;
          tmp32 = readBig32(data, start);
          start += 4;
          ref.starts_with_SAP = tmp32 >> 31 & 1;
          ref.SAP_type = tmp32 >> 28 & 7;
          ref.SAP_delta_time = tmp32 & 268435455;
        }
      });
    }
  }, {
    key: "moov",
    value: function moov(box) {
      return parseBox(box, false, function(ret, data, start) {
        ret.mvhd = MP4Parser2.mvhd(MP4Parser2.findBox(data, ["mvhd"], start)[0]);
        ret.trak = MP4Parser2.findBox(data, ["trak"], start).map(function(trak) {
          return MP4Parser2.trak(trak);
        });
        ret.pssh = MP4Parser2.pssh(MP4Parser2.findBox(data, ["pssh"], start)[0]);
      });
    }
  }, {
    key: "mvhd",
    value: function mvhd(box) {
      return parseBox(box, true, function(ret, data) {
        var start = 0;
        if (ret.version === 1) {
          ret.timescale = readBig32(data, 16);
          ret.duration = readBig64(data, 20);
          start += 28;
        } else {
          ret.timescale = readBig32(data, 8);
          ret.duration = readBig32(data, 12);
          start += 16;
        }
        ret.nextTrackId = readBig32(data, start + 76);
      });
    }
  }, {
    key: "trak",
    value: function trak(box) {
      return parseBox(box, false, function(ret, data, start) {
        ret.tkhd = MP4Parser2.tkhd(MP4Parser2.findBox(data, ["tkhd"], start)[0]);
        ret.mdia = MP4Parser2.mdia(MP4Parser2.findBox(data, ["mdia"], start)[0]);
      });
    }
  }, {
    key: "tkhd",
    value: function tkhd(box) {
      return parseBox(box, true, function(ret, data) {
        var start = 0;
        if (ret.version === 1) {
          ret.trackId = readBig32(data, 16);
          ret.duration = readBig64(data, 24);
          start += 32;
        } else {
          ret.trackId = readBig32(data, 8);
          ret.duration = readBig32(data, 16);
          start += 20;
        }
        ret.width = readBig32(data, start + 52);
        ret.height = readBig32(data, start + 56);
      });
    }
  }, {
    key: "mdia",
    value: function mdia(box) {
      return parseBox(box, false, function(ret, data, start) {
        ret.mdhd = MP4Parser2.mdhd(MP4Parser2.findBox(data, ["mdhd"], start)[0]);
        ret.hdlr = MP4Parser2.hdlr(MP4Parser2.findBox(data, ["hdlr"], start)[0]);
        ret.minf = MP4Parser2.minf(MP4Parser2.findBox(data, ["minf"], start)[0]);
      });
    }
  }, {
    key: "mdhd",
    value: function mdhd(box) {
      return parseBox(box, true, function(ret, data) {
        var start = 0;
        if (ret.version === 1) {
          ret.timescale = readBig32(data, 16);
          ret.duration = readBig64(data, 20);
          start += 28;
        } else {
          ret.timescale = readBig32(data, 8);
          ret.duration = readBig32(data, 12);
          start += 16;
        }
        var lang = readBig16(data, start);
        ret.language = String.fromCharCode((lang >> 10 & 31) + 96, (lang >> 5 & 31) + 96, (lang & 31) + 96);
      });
    }
  }, {
    key: "hdlr",
    value: function hdlr(box) {
      return parseBox(box, true, function(ret, data) {
        if (ret.version === 0) {
          ret.handlerType = String.fromCharCode.apply(null, data.subarray(4, 8));
        }
      });
    }
  }, {
    key: "minf",
    value: function minf(box) {
      return parseBox(box, false, function(ret, data, start) {
        ret.vmhd = MP4Parser2.vmhd(MP4Parser2.findBox(data, ["vmhd"], start)[0]);
        ret.smhd = MP4Parser2.smhd(MP4Parser2.findBox(data, ["smhd"], start)[0]);
        ret.stbl = MP4Parser2.stbl(MP4Parser2.findBox(data, ["stbl"], start)[0]);
      });
    }
  }, {
    key: "vmhd",
    value: function vmhd(box) {
      return parseBox(box, true, function(ret, data) {
        ret.graphicsmode = readBig16(data);
        ret.opcolor = [readBig16(data, 2), readBig16(data, 4), readBig16(data, 6)];
      });
    }
  }, {
    key: "smhd",
    value: function smhd(box) {
      return parseBox(box, true, function(ret, data) {
        ret.balance = readBig16(data);
      });
    }
  }, {
    key: "stbl",
    value: function stbl(box) {
      return parseBox(box, false, function(ret, data, start) {
        var _ret$stsd$entries$, _ret$stsd$entries$$si, _ret$stsd$entries$$si2;
        ret.stsd = MP4Parser2.stsd(MP4Parser2.findBox(data, ["stsd"], start)[0]);
        ret.stts = MP4Parser2.stts(MP4Parser2.findBox(data, ["stts"], start)[0]);
        ret.ctts = MP4Parser2.ctts(MP4Parser2.findBox(data, ["ctts"], start)[0]);
        ret.stsc = MP4Parser2.stsc(MP4Parser2.findBox(data, ["stsc"], start)[0]);
        ret.stsz = MP4Parser2.stsz(MP4Parser2.findBox(data, ["stsz"], start)[0]);
        ret.stco = MP4Parser2.stco(MP4Parser2.findBox(data, ["stco"], start)[0]);
        if (!ret.stco) {
          ret.co64 = MP4Parser2.co64(MP4Parser2.findBox(data, ["co64"], start)[0]);
          ret.stco = ret.co64;
        }
        var default_IV_size = (_ret$stsd$entries$ = ret.stsd.entries[0]) === null || _ret$stsd$entries$ === void 0 ? void 0 : (_ret$stsd$entries$$si = _ret$stsd$entries$.sinf) === null || _ret$stsd$entries$$si === void 0 ? void 0 : (_ret$stsd$entries$$si2 = _ret$stsd$entries$$si.schi) === null || _ret$stsd$entries$$si2 === void 0 ? void 0 : _ret$stsd$entries$$si2.tenc.default_IV_size;
        ret.stss = MP4Parser2.stss(MP4Parser2.findBox(data, ["stss"], start)[0]);
        ret.senc = MP4Parser2.senc(MP4Parser2.findBox(data, ["senc"], start)[0], default_IV_size);
      });
    }
  }, {
    key: "senc",
    value: function senc(box) {
      var iv = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 8;
      return parseBox(box, true, function(ret, data) {
        var start = 0;
        var sampleCount = readBig32(data, start);
        start += 4;
        ret.samples = [];
        for (var i = 0; i < sampleCount; i++) {
          var sample = {};
          sample.InitializationVector = [];
          for (var j = 0; j < iv; j++) {
            sample.InitializationVector[j] = data[start + j];
          }
          start += iv;
          if (ret.flags & 2) {
            sample.subsamples = [];
            var subsampleCount = readBig16(data, start);
            start += 2;
            for (var _j = 0; _j < subsampleCount; _j++) {
              var subsample = {};
              subsample.BytesOfClearData = readBig16(data, start);
              start += 2;
              subsample.BytesOfProtectedData = readBig32(data, start);
              start += 4;
              sample.subsamples.push(subsample);
            }
          }
          ret.samples.push(sample);
        }
      });
    }
  }, {
    key: "pssh",
    value: function pssh(box) {
      return parseBox(box, true, function(ret, data) {
        var keyIds = [];
        var systemId = [];
        var start = 0;
        for (var i = 0; i < 16; i++) {
          systemId.push(toHex(data[start + i]));
        }
        start += 16;
        if (ret.version > 0) {
          var numKeyIds = readBig32(data, start);
          start += 4;
          for (var _i = 0; _i < ("" + numKeyIds).length; _i++) {
            for (var j = 0; j < 16; j++) {
              var keyId = data[start];
              start += 1;
              keyIds.push(toHex(keyId));
            }
          }
        }
        var dataSize = readBig32(data, start);
        ret.data_size = dataSize;
        start += 4;
        ret.kid = keyIds;
        ret.system_id = systemId;
        ret.buffer = data;
      });
    }
  }, {
    key: "stsd",
    value: function stsd(box) {
      return parseBox(box, true, function(ret, data, start) {
        ret.entryCount = readBig32(data);
        ret.entries = MP4Parser2.findBox(data.subarray(4), [], start + 4).map(function(b) {
          switch (b.type) {
            case "avc1":
            case "avc2":
            case "avc3":
            case "avc4":
              return MP4Parser2.avc1(b);
            case "hvc1":
            case "hev1":
              return MP4Parser2.hvc1(b);
            case "mp4a":
              return MP4Parser2.mp4a(b);
            case "alaw":
            case "ulaw":
              return MP4Parser2.alaw(b);
            case "enca":
              return parseBox(b, false, function(ret2, data2, start2) {
                ret2.channelCount = readBig16(data2, 16);
                ret2.samplesize = readBig16(data2, 18);
                ret2.sampleRate = readBig32(data2, 24) / (1 << 16);
                data2 = data2.subarray(28);
                ret2.sinf = MP4Parser2.sinf(MP4Parser2.findBox(data2, ["sinf"], start2)[0]);
                ret2.esds = MP4Parser2.esds(MP4Parser2.findBox(data2, ["esds"], start2)[0]);
              });
            case "encv":
              return parseBox(b, false, function(ret2, data2, start2) {
                ret2.width = readBig16(data2, 24);
                ret2.height = readBig16(data2, 26);
                ret2.horizresolution = readBig32(data2, 28);
                ret2.vertresolution = readBig32(data2, 32);
                data2 = data2.subarray(78);
                ret2.sinf = MP4Parser2.sinf(MP4Parser2.findBox(data2, ["sinf"], start2)[0]);
                ret2.avcC = MP4Parser2.avcC(MP4Parser2.findBox(data2, ["avcC"], start2)[0]);
                ret2.hvcC = MP4Parser2.hvcC(MP4Parser2.findBox(data2, ["hvcC"], start2)[0]);
                ret2.pasp = MP4Parser2.pasp(MP4Parser2.findBox(data2, ["pasp"], start2)[0]);
              });
          }
        }).filter(Boolean);
      });
    }
  }, {
    key: "tenc",
    value: function tenc(box) {
      return parseBox(box, false, function(ret, data) {
        var start = 6;
        ret.default_IsEncrypted = data[start];
        start += 1;
        ret.default_IV_size = data[start];
        start += 1;
        ret.default_KID = [];
        for (var i = 0; i < 16; i++) {
          ret.default_KID.push(toHex(data[start]));
          start += 1;
        }
      });
    }
  }, {
    key: "schi",
    value: function schi(box) {
      return parseBox(box, false, function(ret, data, start) {
        ret.tenc = MP4Parser2.tenc(MP4Parser2.findBox(data, ["tenc"], start)[0]);
      });
    }
  }, {
    key: "sinf",
    value: function sinf(box) {
      return parseBox(box, false, function(ret, data, start) {
        ret.schi = MP4Parser2.schi(MP4Parser2.findBox(data, ["schi"], start)[0]);
        ret.frma = MP4Parser2.frma(MP4Parser2.findBox(data, ["frma"], start)[0]);
      });
    }
  }, {
    key: "frma",
    value: function frma(box) {
      return parseBox(box, false, function(ret, data) {
        ret.data_format = "";
        for (var i = 0; i < 4; i++) {
          ret.data_format += String.fromCharCode(data[i]);
        }
      });
    }
  }, {
    key: "avc1",
    value: function avc1(box) {
      return parseBox(box, false, function(ret, data, start) {
        var bodyStart = parseVisualSampleEntry(ret, data);
        var bodyData = data.subarray(bodyStart);
        start += bodyStart;
        ret.avcC = MP4Parser2.avcC(MP4Parser2.findBox(bodyData, ["avcC"], start)[0]);
        ret.pasp = MP4Parser2.pasp(MP4Parser2.findBox(bodyData, ["pasp"], start)[0]);
      });
    }
  }, {
    key: "avcC",
    value: function avcC(box) {
      return parseBox(box, false, function(ret, data) {
        ret.data = box.data;
        ret.configurationVersion = data[0];
        ret.AVCProfileIndication = data[1];
        ret.profileCompatibility = data[2];
        ret.AVCLevelIndication = data[3];
        ret.codec = getAvcCodec([data[1], data[2], data[3]]);
        ret.lengthSizeMinusOne = data[4] & 3;
        ret.spsLength = data[5] & 31;
        ret.sps = [];
        var start = 6;
        for (var i = 0; i < ret.spsLength; i++) {
          var size = readBig16(data, start);
          start += 2;
          ret.sps.push(data.subarray(start, start + size));
          start += size;
        }
        ret.ppsLength = data[start];
        start += 1;
        ret.pps = [];
        for (var _i2 = 0; _i2 < ret.ppsLength; _i2++) {
          var _size = readBig16(data, start);
          start += 2;
          ret.pps.push(data.subarray(start, start += _size));
          start += _size;
        }
      });
    }
  }, {
    key: "hvc1",
    value: function hvc1(box) {
      return parseBox(box, false, function(ret, data, start) {
        var bodyStart = parseVisualSampleEntry(ret, data);
        var bodyData = data.subarray(bodyStart);
        start += bodyStart;
        ret.hvcC = MP4Parser2.hvcC(MP4Parser2.findBox(bodyData, ["hvcC"], start)[0]);
        ret.pasp = MP4Parser2.pasp(MP4Parser2.findBox(bodyData, ["pasp"], start)[0]);
      });
    }
  }, {
    key: "hvcC",
    value: function hvcC(box) {
      return parseBox(box, false, function(ret, data) {
        ret.data = box.data;
        ret.codec = "hev1.1.6.L93.B0";
        ret.configurationVersion = data[0];
        var tmp = data[1];
        ret.generalProfileSpace = tmp >> 6;
        ret.generalTierFlag = (tmp & 32) >> 5;
        ret.generalProfileIdc = tmp & 31;
        ret.generalProfileCompatibility = readBig32(data, 2);
        ret.generalConstraintIndicatorFlags = data.subarray(6, 12);
        ret.generalLevelIdc = data[12];
        ret.avgFrameRate = readBig16(data, 19);
        ret.numOfArrays = data[22];
        ret.vps = [];
        ret.sps = [];
        ret.pps = [];
        var start = 23;
        var type = 0;
        var numNalus = 0;
        var size = 0;
        for (var i = 0; i < ret.numOfArrays; i++) {
          type = data[start] & 63;
          numNalus = readBig16(data, start + 1);
          start += 3;
          var nalus = [];
          for (var j = 0; j < numNalus; j++) {
            size = readBig16(data, start);
            start += 2;
            nalus.push(data.subarray(start, start + size));
            start += size;
          }
          if (type === 32) {
            var _ret$vps;
            (_ret$vps = ret.vps).push.apply(_ret$vps, nalus);
          } else if (type === 33) {
            var _ret$sps;
            (_ret$sps = ret.sps).push.apply(_ret$sps, nalus);
          } else if (type === 34) {
            var _ret$pps;
            (_ret$pps = ret.pps).push.apply(_ret$pps, nalus);
          }
        }
      });
    }
  }, {
    key: "pasp",
    value: function pasp(box) {
      return parseBox(box, false, function(ret, data) {
        ret.hSpacing = readBig32(data);
        ret.vSpacing = readBig32(data, 4);
      });
    }
  }, {
    key: "mp4a",
    value: function mp4a(box) {
      return parseBox(box, false, function(ret, data, start) {
        var bodyStart = parseAudioSampleEntry(ret, data);
        ret.esds = MP4Parser2.esds(MP4Parser2.findBox(data.subarray(bodyStart), ["esds"], start + bodyStart)[0]);
      });
    }
  }, {
    key: "esds",
    value: function esds(box) {
      return parseBox(box, true, function(ret, data) {
        ret.codec = "mp4a.";
        var start = 0;
        var byteRead = 0;
        var size = 0;
        var tag = 0;
        while (data.length) {
          start = 0;
          tag = data[start];
          byteRead = data[start + 1];
          start += 2;
          while (byteRead & 128) {
            size = (byteRead & 127) << 7;
            byteRead = data[start];
            start += 1;
          }
          size += byteRead & 127;
          if (tag === 3) {
            data = data.subarray(start + 3);
          } else if (tag === 4) {
            ret.codec += (data[start].toString(16) + ".").padStart(3, "0");
            data = data.subarray(start + 13);
          } else if (tag === 5) {
            var config = ret.config = data.subarray(start, start + size);
            var objectType = (config[0] & 248) >> 3;
            if (objectType === 31 && config.length >= 2) {
              objectType = 32 + ((config[0] & 7) << 3) + ((config[1] & 224) >> 5);
            }
            ret.objectType = objectType;
            ret.codec += objectType.toString(16);
            if (ret.codec[ret.codec.length - 1] === ".") {
              ret.codec = ret.codec.substring(0, ret.codec.length - 1);
            }
            return;
          } else {
            if (ret.codec[ret.codec.length - 1] === ".") {
              ret.codec = ret.codec.substring(0, ret.codec.length - 1);
            }
            return;
          }
        }
      });
    }
  }, {
    key: "alaw",
    value: function alaw(box) {
      return parseBox(box, false, function(ret, data) {
        parseAudioSampleEntry(ret, data);
      });
    }
  }, {
    key: "stts",
    value: function stts(box) {
      return parseBox(box, true, function(ret, data) {
        var entryCount = readBig32(data);
        var entries = [];
        var start = 4;
        for (var i = 0; i < entryCount; i++) {
          entries.push({
            count: readBig32(data, start),
            delta: readBig32(data, start + 4)
          });
          start += 8;
        }
        ret.entryCount = entryCount;
        ret.entries = entries;
      });
    }
  }, {
    key: "ctts",
    value: function ctts(box) {
      return parseBox(box, true, function(ret, data) {
        var entryCount = readBig32(data);
        var entries = [];
        var start = 4;
        if (ret.version === 1) {
          for (var i = 0; i < entryCount; i++) {
            entries.push({
              count: readBig32(data, start),
              offset: readBig32(data, start + 4)
            });
            start += 8;
          }
        } else {
          for (var _i3 = 0; _i3 < entryCount; _i3++) {
            entries.push({
              count: readBig32(data, start),
              offset: -(~readBig32(data, start + 4) + 1)
            });
            start += 8;
          }
        }
        ret.entryCount = entryCount;
        ret.entries = entries;
      });
    }
  }, {
    key: "stsc",
    value: function stsc(box) {
      return parseBox(box, true, function(ret, data) {
        var entryCount = readBig32(data);
        var entries = [];
        var start = 4;
        for (var i = 0; i < entryCount; i++) {
          entries.push({
            firstChunk: readBig32(data, start),
            samplesPerChunk: readBig32(data, start + 4),
            sampleDescriptionIndex: readBig32(data, start + 8)
          });
          start += 12;
        }
        ret.entryCount = entryCount;
        ret.entries = entries;
      });
    }
  }, {
    key: "stsz",
    value: function stsz(box) {
      return parseBox(box, true, function(ret, data) {
        var sampleSize = readBig32(data);
        var sampleCount = readBig32(data, 4);
        var entrySizes = [];
        if (!sampleSize) {
          var start = 8;
          for (var i = 0; i < sampleCount; i++) {
            entrySizes.push(readBig32(data, start));
            start += 4;
          }
        }
        ret.sampleSize = sampleSize;
        ret.sampleCount = sampleCount;
        ret.entrySizes = entrySizes;
      });
    }
  }, {
    key: "stco",
    value: function stco(box) {
      return parseBox(box, true, function(ret, data) {
        var entryCount = readBig32(data);
        var entries = [];
        var start = 4;
        for (var i = 0; i < entryCount; i++) {
          entries.push(readBig32(data, start));
          start += 4;
        }
        ret.entryCount = entryCount;
        ret.entries = entries;
      });
    }
  }, {
    key: "co64",
    value: function co64(box) {
      return parseBox(box, true, function(ret, data) {
        var entryCount = readBig32(data);
        var entries = [];
        var start = 4;
        for (var i = 0; i < entryCount; i++) {
          entries.push(readBig64(data, start));
          start += 8;
        }
        ret.entryCount = entryCount;
        ret.entries = entries;
      });
    }
  }, {
    key: "stss",
    value: function stss(box) {
      return parseBox(box, true, function(ret, data) {
        var entryCount = readBig32(data);
        var entries = [];
        var start = 4;
        for (var i = 0; i < entryCount; i++) {
          entries.push(readBig32(data, start));
          start += 4;
        }
        ret.entryCount = entryCount;
        ret.entries = entries;
      });
    }
  }, {
    key: "moof",
    value: function moof(box) {
      return parseBox(box, false, function(ret, data, start) {
        ret.mfhd = MP4Parser2.mfhd(MP4Parser2.findBox(data, ["mfhd"], start)[0]);
        ret.traf = MP4Parser2.findBox(data, ["traf"], start).map(function(t) {
          return MP4Parser2.traf(t);
        });
      });
    }
  }, {
    key: "mfhd",
    value: function mfhd(box) {
      return parseBox(box, true, function(ret, data) {
        ret.sequenceNumber = readBig32(data);
      });
    }
  }, {
    key: "traf",
    value: function traf(box) {
      return parseBox(box, false, function(ret, data, start) {
        ret.tfhd = MP4Parser2.tfhd(MP4Parser2.findBox(data, ["tfhd"], start)[0]);
        ret.tfdt = MP4Parser2.tfdt(MP4Parser2.findBox(data, ["tfdt"], start)[0]);
        ret.trun = MP4Parser2.trun(MP4Parser2.findBox(data, ["trun"], start)[0]);
      });
    }
  }, {
    key: "trun",
    value: function trun(box) {
      return parseBox(box, true, function(ret, data) {
        var version2 = ret.version, flags = ret.flags;
        var dataLen = data.length;
        var sampleCount = ret.sampleCount = readBig32(data);
        var offset = 4;
        if (dataLen > offset && flags & 1) {
          ret.dataOffset = -(~readBig32(data, offset) + 1);
          offset += 4;
        }
        if (dataLen > offset && flags & 4) {
          ret.firstSampleFlags = readBig32(data, offset);
          offset += 4;
        }
        ret.samples = [];
        if (dataLen > offset) {
          var sample;
          for (var i = 0; i < sampleCount; i++) {
            sample = {};
            if (flags & 256) {
              sample.duration = readBig32(data, offset);
              offset += 4;
            }
            if (flags & 512) {
              sample.size = readBig32(data, offset);
              offset += 4;
            }
            if (flags & 1024) {
              sample.flags = readBig32(data, offset);
              offset += 4;
            }
            if (flags & 2048) {
              if (version2) {
                sample.cts = -(~readBig32(data, offset + 4) + 1);
              } else {
                sample.cts = readBig32(data, offset);
              }
              offset += 4;
            }
            ret.samples.push(sample);
          }
        }
      });
    }
  }, {
    key: "tfdt",
    value: function tfdt(box) {
      return parseBox(box, true, function(ret, data) {
        if (ret.version === 1) {
          ret.baseMediaDecodeTime = readBig64(data);
        } else {
          ret.baseMediaDecodeTime = readBig32(data);
        }
      });
    }
  }, {
    key: "probe",
    value: function probe(data) {
      return !!MP4Parser2.findBox(data, ["ftyp"]);
    }
  }, {
    key: "parseSampleFlags",
    value: function parseSampleFlags(flags) {
      return {
        isLeading: (flags[0] & 12) >>> 2,
        dependsOn: flags[0] & 3,
        isDependedOn: (flags[1] & 192) >>> 6,
        hasRedundancy: (flags[1] & 48) >>> 4,
        paddingValue: (flags[1] & 14) >>> 1,
        isNonSyncSample: flags[1] & 1,
        degradationPriority: flags[2] << 8 | flags[3]
      };
    }
  }, {
    key: "moovToTrack",
    value: function moovToTrack(moov, videoTrack, audioTrack) {
      var _e$esds, _e$esds2;
      var tracks = moov.trak;
      if (!tracks || !tracks.length)
        return;
      var vTrack = tracks.find(function(t) {
        var _t$mdia, _t$mdia$hdlr;
        return ((_t$mdia = t.mdia) === null || _t$mdia === void 0 ? void 0 : (_t$mdia$hdlr = _t$mdia.hdlr) === null || _t$mdia$hdlr === void 0 ? void 0 : _t$mdia$hdlr.handlerType) === "vide";
      });
      var aTrack = tracks.find(function(t) {
        var _t$mdia2, _t$mdia2$hdlr;
        return ((_t$mdia2 = t.mdia) === null || _t$mdia2 === void 0 ? void 0 : (_t$mdia2$hdlr = _t$mdia2.hdlr) === null || _t$mdia2$hdlr === void 0 ? void 0 : _t$mdia2$hdlr.handlerType) === "soun";
      });
      if (vTrack && videoTrack) {
        var _vTrack$tkhd, _vTrack$mdia, _vTrack$mdia$minf, _vTrack$mdia$minf$stb, _vTrack$mdia2, _vTrack$mdia2$minf, _vTrack$mdia2$minf$st;
        var v = videoTrack;
        var _vTrackId = (_vTrack$tkhd = vTrack.tkhd) === null || _vTrack$tkhd === void 0 ? void 0 : _vTrack$tkhd.trackId;
        if (_vTrackId !== null && _vTrackId !== void 0)
          v.id = vTrack.tkhd.trackId;
        v.tkhdDuration = vTrack.tkhd.duration;
        v.mvhdDurtion = moov.mvhd.duration;
        v.mvhdTimecale = moov.mvhd.timescale;
        v.timescale = v.formatTimescale = vTrack.mdia.mdhd.timescale;
        v.duration = vTrack.mdia.mdhd.duration || v.mvhdDurtion / v.mvhdTimecale * v.timescale;
        var e1 = vTrack.mdia.minf.stbl.stsd.entries[0];
        v.width = e1.width;
        v.height = e1.height;
        if (e1.pasp) {
          v.sarRatio = [e1.pasp.hSpacing, e1.pasp.vSpacing];
        }
        if (e1.hvcC) {
          v.codecType = VideoCodecType.HEVC;
          v.codec = e1.hvcC.codec;
          v.vps = e1.hvcC.vps;
          v.sps = e1.hvcC.sps;
          v.pps = e1.hvcC.pps;
          v.hvcC = e1.hvcC.data;
        } else if (e1.avcC) {
          v.codec = e1.avcC.codec;
          v.sps = e1.avcC.sps;
          v.pps = e1.avcC.pps;
        } else {
          throw new Error("unknown video stsd entry");
        }
        v.present = true;
        v.ext = {};
        v.ext.stss = (_vTrack$mdia = vTrack.mdia) === null || _vTrack$mdia === void 0 ? void 0 : (_vTrack$mdia$minf = _vTrack$mdia.minf) === null || _vTrack$mdia$minf === void 0 ? void 0 : (_vTrack$mdia$minf$stb = _vTrack$mdia$minf.stbl) === null || _vTrack$mdia$minf$stb === void 0 ? void 0 : _vTrack$mdia$minf$stb.stss;
        v.ext.ctts = (_vTrack$mdia2 = vTrack.mdia) === null || _vTrack$mdia2 === void 0 ? void 0 : (_vTrack$mdia2$minf = _vTrack$mdia2.minf) === null || _vTrack$mdia2$minf === void 0 ? void 0 : (_vTrack$mdia2$minf$st = _vTrack$mdia2$minf.stbl) === null || _vTrack$mdia2$minf$st === void 0 ? void 0 : _vTrack$mdia2$minf$st.ctts;
        if (e1 && e1.type === "encv") {
          var _e1$sinf, _e1$sinf$schi, _e1$sinf2, _e1$sinf2$schi, _e1$sinf3, _e1$sinf3$schi, _e1$sinf4, _e1$sinf4$frma;
          v.isVideoEncryption = true;
          e1.default_KID = (_e1$sinf = e1.sinf) === null || _e1$sinf === void 0 ? void 0 : (_e1$sinf$schi = _e1$sinf.schi) === null || _e1$sinf$schi === void 0 ? void 0 : _e1$sinf$schi.tenc.default_KID;
          e1.default_IsEncrypted = (_e1$sinf2 = e1.sinf) === null || _e1$sinf2 === void 0 ? void 0 : (_e1$sinf2$schi = _e1$sinf2.schi) === null || _e1$sinf2$schi === void 0 ? void 0 : _e1$sinf2$schi.tenc.default_IsEncrypted;
          e1.default_IV_size = (_e1$sinf3 = e1.sinf) === null || _e1$sinf3 === void 0 ? void 0 : (_e1$sinf3$schi = _e1$sinf3.schi) === null || _e1$sinf3$schi === void 0 ? void 0 : _e1$sinf3$schi.tenc.default_IV_size;
          v.videoSenc = vTrack.mdia.minf.stbl.senc && vTrack.mdia.minf.stbl.senc.samples;
          e1.data_format = (_e1$sinf4 = e1.sinf) === null || _e1$sinf4 === void 0 ? void 0 : (_e1$sinf4$frma = _e1$sinf4.frma) === null || _e1$sinf4$frma === void 0 ? void 0 : _e1$sinf4$frma.data_format;
          v.useEME = moov.useEME;
          v.kidValue = moov.kidValue;
          v.pssh = moov.pssh;
          v.encv = e1;
        }
      }
      if (aTrack && audioTrack) {
        var _aTrack$tkhd, _e$esds3, _e$esds4, _aTrack$mdia, _aTrack$mdia$minf, _aTrack$mdia$minf$stb, _aTrack$mdia2, _aTrack$mdia2$minf, _aTrack$mdia2$minf$st;
        var a = audioTrack;
        var _aTrackId = (_aTrack$tkhd = aTrack.tkhd) === null || _aTrack$tkhd === void 0 ? void 0 : _aTrack$tkhd.trackId;
        if (_aTrackId !== null && _aTrackId !== void 0)
          a.id = aTrack.tkhd.trackId;
        a.tkhdDuration = aTrack.tkhd.duration;
        a.mvhdDurtion = moov.mvhd.duration;
        a.mvhdTimecale = moov.mvhd.timescale;
        a.timescale = a.formatTimescale = aTrack.mdia.mdhd.timescale;
        a.duration = aTrack.mdia.mdhd.duration || a.mvhdDurtion / a.mvhdTimecale * a.timescale;
        var _e = aTrack.mdia.minf.stbl.stsd.entries[0];
        a.sampleSize = _e.sampleSize;
        a.sampleRate = _e.sampleRate;
        a.channelCount = _e.channelCount;
        a.present = true;
        switch (_e.type) {
          case "alaw":
            a.codecType = a.codec = AudioCodecType.G711PCMA;
            a.sampleRate = 8e3;
            break;
          case "ulaw":
            a.codecType = a.codec = AudioCodecType.G711PCMU;
            a.sampleRate = 8e3;
            break;
          default:
            a.sampleDuration = AAC.getFrameDuration(a.sampleRate, a.timescale);
            a.sampleRateIndex = AAC.getRateIndexByRate(a.sampleRate);
            a.objectType = ((_e$esds = _e.esds) === null || _e$esds === void 0 ? void 0 : _e$esds.objectType) || 2;
            if (_e.esds)
              a.config = Array.from(_e.esds.config);
            a.codec = ((_e$esds2 = _e.esds) === null || _e$esds2 === void 0 ? void 0 : _e$esds2.codec) || "mp4a.40.2";
            break;
        }
        a.sampleDuration = AAC.getFrameDuration(a.sampleRate, a.timescale);
        a.objectType = ((_e$esds3 = _e.esds) === null || _e$esds3 === void 0 ? void 0 : _e$esds3.objectType) || 2;
        if (_e.esds) {
          if (_e.esds.config) {
            a.config = Array.from(_e.esds.config);
          } else {
            console.warn("esds config is null");
          }
        }
        a.codec = ((_e$esds4 = _e.esds) === null || _e$esds4 === void 0 ? void 0 : _e$esds4.codec) || "mp4a.40.2";
        a.sampleRateIndex = AAC.getRateIndexByRate(a.sampleRate);
        a.ext = {};
        a.ext.stss = (_aTrack$mdia = aTrack.mdia) === null || _aTrack$mdia === void 0 ? void 0 : (_aTrack$mdia$minf = _aTrack$mdia.minf) === null || _aTrack$mdia$minf === void 0 ? void 0 : (_aTrack$mdia$minf$stb = _aTrack$mdia$minf.stbl) === null || _aTrack$mdia$minf$stb === void 0 ? void 0 : _aTrack$mdia$minf$stb.stss;
        a.ext.ctts = (_aTrack$mdia2 = aTrack.mdia) === null || _aTrack$mdia2 === void 0 ? void 0 : (_aTrack$mdia2$minf = _aTrack$mdia2.minf) === null || _aTrack$mdia2$minf === void 0 ? void 0 : (_aTrack$mdia2$minf$st = _aTrack$mdia2$minf.stbl) === null || _aTrack$mdia2$minf$st === void 0 ? void 0 : _aTrack$mdia2$minf$st.ctts;
        a.present = true;
        if (_e && _e.type === "enca") {
          var _e$sinf, _e$sinf$frma, _e$sinf2, _e$sinf2$schi, _e$sinf3, _e$sinf3$schi, _e$sinf4, _e$sinf4$schi;
          a.isAudioEncryption = true;
          _e.data_format = (_e$sinf = _e.sinf) === null || _e$sinf === void 0 ? void 0 : (_e$sinf$frma = _e$sinf.frma) === null || _e$sinf$frma === void 0 ? void 0 : _e$sinf$frma.data_format;
          _e.default_KID = (_e$sinf2 = _e.sinf) === null || _e$sinf2 === void 0 ? void 0 : (_e$sinf2$schi = _e$sinf2.schi) === null || _e$sinf2$schi === void 0 ? void 0 : _e$sinf2$schi.tenc.default_KID;
          _e.default_IsEncrypted = (_e$sinf3 = _e.sinf) === null || _e$sinf3 === void 0 ? void 0 : (_e$sinf3$schi = _e$sinf3.schi) === null || _e$sinf3$schi === void 0 ? void 0 : _e$sinf3$schi.tenc.default_IsEncrypted;
          _e.default_IV_size = (_e$sinf4 = _e.sinf) === null || _e$sinf4 === void 0 ? void 0 : (_e$sinf4$schi = _e$sinf4.schi) === null || _e$sinf4$schi === void 0 ? void 0 : _e$sinf4$schi.tenc.default_IV_size;
          a.audioSenc = aTrack.mdia.minf.stbl.senc && aTrack.mdia.minf.stbl.senc.samples;
          a.useEME = moov.useEME;
          a.kidValue = moov.kidValue;
          a.enca = _e;
        }
      }
      audioTrack && (audioTrack.isVideoEncryption = videoTrack ? videoTrack.isVideoEncryption : false);
      videoTrack && (videoTrack.isAudioEncryption = audioTrack ? audioTrack.isAudioEncryption : false);
      if (videoTrack !== null && videoTrack !== void 0 && videoTrack.encv || audioTrack !== null && audioTrack !== void 0 && audioTrack.enca) {
        var _videoTrack$encv, _audioTrack$enca;
        var vkid = videoTrack === null || videoTrack === void 0 ? void 0 : (_videoTrack$encv = videoTrack.encv) === null || _videoTrack$encv === void 0 ? void 0 : _videoTrack$encv.default_KID;
        var akid = audioTrack === null || audioTrack === void 0 ? void 0 : (_audioTrack$enca = audioTrack.enca) === null || _audioTrack$enca === void 0 ? void 0 : _audioTrack$enca.default_KID;
        var kid = vkid || akid ? (vkid || akid).join("") : null;
        videoTrack && (videoTrack.kid = kid);
        audioTrack && (audioTrack.kid = kid);
      }
      videoTrack && (videoTrack.flags = 3841);
      audioTrack && (audioTrack.flags = 1793);
      return {
        videoTrack,
        audioTrack
      };
    }
  }, {
    key: "evaluateDefaultDuration",
    value: function evaluateDefaultDuration(videoTrack, audioTrack, videoSampleCount) {
      var _audioTrack$samples;
      var audioSampleCount = audioTrack === null || audioTrack === void 0 ? void 0 : (_audioTrack$samples = audioTrack.samples) === null || _audioTrack$samples === void 0 ? void 0 : _audioTrack$samples.length;
      if (!audioSampleCount)
        return 1024;
      var segmentDuration = 1024 * audioSampleCount / audioTrack.timescale;
      return segmentDuration * videoTrack.timescale / videoSampleCount;
    }
  }, {
    key: "moofToSamples",
    value: function moofToSamples(moof, videoTrack, audioTrack) {
      var ret = {};
      if (moof.mfhd) {
        if (videoTrack)
          videoTrack.sequenceNumber = moof.mfhd.sequenceNumber;
        if (audioTrack)
          audioTrack.sequenceNumber = moof.mfhd.sequenceNumber;
      }
      moof.traf.forEach(function(_ref) {
        var tfhd = _ref.tfhd, tfdt = _ref.tfdt, trun = _ref.trun;
        if (!tfhd || !trun)
          return;
        if (tfdt) {
          if (videoTrack && videoTrack.id === tfhd.trackId)
            videoTrack.baseMediaDecodeTime = tfdt.baseMediaDecodeTime;
          if (audioTrack && audioTrack.id === tfhd.trackId)
            audioTrack.baseMediaDecodeTime = tfdt.baseMediaDecodeTime;
        }
        var defaultSize = tfhd.defaultSampleSize || 0;
        var defaultDuration = tfhd.defaultSampleDuration || MP4Parser2.evaluateDefaultDuration(videoTrack, audioTrack, trun.samples.length || trun.sampleCount);
        var offset = trun.dataOffset || 0;
        var dts = 0;
        var gopId = -1;
        if (!trun.samples.length && trun.sampleCount) {
          ret[tfhd.trackId] = [];
          for (var i = 0; i < trun.sampleCount; i++) {
            ret[tfhd.trackId].push({
              offset,
              dts,
              duration: defaultDuration,
              size: defaultSize
            });
            dts += defaultDuration;
            offset += defaultSize;
          }
        } else {
          ret[tfhd.trackId] = trun.samples.map(function(s, index) {
            s = {
              offset,
              dts,
              pts: dts + (s.cts || 0),
              duration: s.duration || defaultDuration,
              size: s.size || defaultSize,
              gopId,
              keyframe: index === 0 || s.flags !== null && s.flags !== void 0 && (s.flags & 65536) >>> 0 !== 65536
            };
            if (s.keyframe) {
              gopId++;
              s.gopId = gopId;
            }
            dts += s.duration;
            offset += s.size;
            return s;
          });
        }
      });
      return ret;
    }
  }, {
    key: "moovToSamples",
    value: function moovToSamples(moov) {
      var tracks = moov.trak;
      if (!tracks || !tracks.length)
        return;
      var vTrack = tracks.find(function(t) {
        var _t$mdia3, _t$mdia3$hdlr;
        return ((_t$mdia3 = t.mdia) === null || _t$mdia3 === void 0 ? void 0 : (_t$mdia3$hdlr = _t$mdia3.hdlr) === null || _t$mdia3$hdlr === void 0 ? void 0 : _t$mdia3$hdlr.handlerType) === "vide";
      });
      var aTrack = tracks.find(function(t) {
        var _t$mdia4, _t$mdia4$hdlr;
        return ((_t$mdia4 = t.mdia) === null || _t$mdia4 === void 0 ? void 0 : (_t$mdia4$hdlr = _t$mdia4.hdlr) === null || _t$mdia4$hdlr === void 0 ? void 0 : _t$mdia4$hdlr.handlerType) === "soun";
      });
      if (!vTrack && !aTrack)
        return;
      var videoSamples;
      var audioSamples;
      if (vTrack) {
        var _vTrack$mdia3, _vTrack$mdia3$minf;
        var videoStbl = (_vTrack$mdia3 = vTrack.mdia) === null || _vTrack$mdia3 === void 0 ? void 0 : (_vTrack$mdia3$minf = _vTrack$mdia3.minf) === null || _vTrack$mdia3$minf === void 0 ? void 0 : _vTrack$mdia3$minf.stbl;
        if (!videoStbl)
          return;
        var stts = videoStbl.stts, stsc = videoStbl.stsc, stsz = videoStbl.stsz, stco = videoStbl.stco, stss = videoStbl.stss, ctts = videoStbl.ctts;
        if (!stts || !stsc || !stsz || !stco || !stss)
          return;
        videoSamples = getSamples(stts, stsc, stsz, stco, ctts, stss);
      }
      if (aTrack) {
        var _aTrack$mdia3, _aTrack$mdia3$minf, _aTrack$mdia$mdhd;
        var audioStbl = (_aTrack$mdia3 = aTrack.mdia) === null || _aTrack$mdia3 === void 0 ? void 0 : (_aTrack$mdia3$minf = _aTrack$mdia3.minf) === null || _aTrack$mdia3$minf === void 0 ? void 0 : _aTrack$mdia3$minf.stbl;
        if (!audioStbl)
          return;
        var timescale = (_aTrack$mdia$mdhd = aTrack.mdia.mdhd) === null || _aTrack$mdia$mdhd === void 0 ? void 0 : _aTrack$mdia$mdhd.timescale;
        var _stts = audioStbl.stts, _stsc = audioStbl.stsc, _stsz = audioStbl.stsz, _stco = audioStbl.stco;
        if (!timescale || !_stts || !_stsc || !_stsz || !_stco)
          return;
        audioSamples = getSamples(_stts, _stsc, _stsz, _stco);
      }
      return {
        videoSamples,
        audioSamples
      };
    }
  }]);
  return MP4Parser2;
}();
function getSamples(stts, stsc, stsz, stco, ctts, stss) {
  var samples = [];
  var cttsEntries = ctts === null || ctts === void 0 ? void 0 : ctts.entries;
  var stscEntries = stsc.entries;
  var stcoEntries = stco.entries;
  var stszEntrySizes = stsz.entrySizes;
  var stssEntries = stss === null || stss === void 0 ? void 0 : stss.entries;
  var keyframeMap;
  if (stssEntries) {
    keyframeMap = {};
    stssEntries.forEach(function(x2) {
      keyframeMap[x2 - 1] = true;
    });
  }
  var cttsArr;
  if (cttsEntries) {
    cttsArr = [];
    cttsEntries.forEach(function(_ref2) {
      var count = _ref2.count, offset = _ref2.offset;
      for (var i = 0; i < count; i++) {
        cttsArr.push(offset);
      }
    });
  }
  var sample;
  var gopId = -1;
  var dts = 0;
  var pos = 0;
  var chunkIndex = 0;
  var chunkRunIndex = 0;
  var offsetInChunk = 0;
  var lastSampleInChunk = stscEntries[0].samplesPerChunk;
  var lastChunkInRun = stscEntries[1] ? stscEntries[1].firstChunk - 1 : Infinity;
  stts.entries.forEach(function(_ref3) {
    var count = _ref3.count, delta = _ref3.delta;
    for (var i = 0; i < count; i++) {
      sample = {
        dts,
        duration: delta,
        size: stszEntrySizes[pos] || stsz.sampleSize,
        offset: stcoEntries[chunkIndex] + offsetInChunk,
        index: pos
      };
      if (stssEntries) {
        sample.keyframe = keyframeMap[pos];
        if (sample.keyframe) {
          gopId++;
        }
        sample.gopId = gopId;
      }
      if (cttsArr && pos < cttsArr.length) {
        sample.pts = sample.dts + cttsArr[pos];
      }
      samples.push(sample);
      dts += delta;
      pos++;
      if (pos < lastSampleInChunk) {
        offsetInChunk += sample.size;
      } else {
        chunkIndex++;
        offsetInChunk = 0;
        if (chunkIndex >= lastChunkInRun) {
          chunkRunIndex++;
          lastChunkInRun = stscEntries[chunkRunIndex + 1] ? stscEntries[chunkRunIndex + 1].firstChunk - 1 : Infinity;
        }
        lastSampleInChunk += stscEntries[chunkRunIndex].samplesPerChunk;
      }
    }
  });
  return samples;
}
function parseVisualSampleEntry(ret, data) {
  ret.dataReferenceIndex = readBig16(data, 6);
  ret.width = readBig16(data, 24);
  ret.height = readBig16(data, 26);
  ret.horizresolution = readBig32(data, 28);
  ret.vertresolution = readBig32(data, 32);
  ret.frameCount = readBig16(data, 40);
  ret.depth = readBig16(data, 74);
  return 78;
}
function parseAudioSampleEntry(ret, data) {
  ret.dataReferenceIndex = readBig16(data, 6);
  ret.channelCount = readBig16(data, 16);
  ret.sampleSize = readBig16(data, 18);
  ret.sampleRate = readBig32(data, 24) / (1 << 16);
  return 28;
}
function parseBox(box, isFullBox, parse3) {
  if (!box)
    return;
  if (box.size !== box.data.length)
    throw new Error("box ".concat(box.type, " size !== data.length"));
  var ret = {
    start: box.start,
    size: box.size,
    headerSize: box.headerSize,
    type: box.type
  };
  if (isFullBox) {
    ret.version = box.data[box.headerSize];
    ret.flags = readBig24(box.data, box.headerSize + 1);
    ret.headerSize += 4;
  }
  parse3(ret, box.data.subarray(ret.headerSize), ret.start + ret.headerSize);
  return ret;
}
var padStart = function padStart2(str, length, pad) {
  var charstr = String(pad);
  var len = length >> 0;
  var maxlen = Math.ceil(len / charstr.length);
  var chars = [];
  var r = String(str);
  while (maxlen--) {
    chars.push(charstr);
  }
  return chars.join("").substring(0, len - r.length) + r;
};
var toHex = function toHex2() {
  var hex = [];
  for (var _len = arguments.length, value = new Array(_len), _key = 0; _key < _len; _key++) {
    value[_key] = arguments[_key];
  }
  value.forEach(function(item) {
    hex.push(padStart(Number(item).toString(16), 2, 0));
  });
  return hex[0];
};

// node_modules/xgplayer-transmuxer/es/mp4/fmp4-demuxer.js
var FMP4Demuxer = function() {
  function FMP4Demuxer2(videoTrack, audioTrack, metadataTrack) {
    _classCallCheck2(this, FMP4Demuxer2);
    this.videoTrack = videoTrack || new VideoTrack();
    this.audioTrack = audioTrack || new AudioTrack();
    this.metadataTrack = metadataTrack || new MetadataTrack();
  }
  _createClass2(FMP4Demuxer2, [{
    key: "demux",
    value: function demux(videoData, audioData) {
      var videoTrack = this.videoTrack, audioTrack = this.audioTrack;
      var videoExist = videoTrack.exist();
      var audioExist = audioTrack.exist();
      videoTrack.samples = [];
      audioTrack.samples = [];
      if (audioData) {
        if (!audioExist) {
          var moovBox = MP4Parser.findBox(audioData, ["moov"])[0];
          if (!moovBox)
            throw new Error("cannot found moov box");
          MP4Parser.moovToTrack(MP4Parser.moov(moovBox), null, audioTrack);
        }
        var moofBox = MP4Parser.findBox(audioData, ["moof"])[0];
        if (moofBox) {
          var samples = MP4Parser.moofToSamples(MP4Parser.moof(moofBox), null, audioTrack)[audioTrack.id];
          var baseMediaDecodeTime = audioTrack.baseMediaDecodeTime;
          if (samples) {
            var baseOffset = moofBox.start;
            samples.map(function(x2) {
              x2.offset += baseOffset;
              var sampleData = audioData.subarray(x2.offset, x2.offset + x2.size);
              audioTrack.samples.push(new AudioSample(x2.dts + baseMediaDecodeTime, sampleData, x2.duration));
            });
          }
        }
      }
      if (videoData) {
        if (!videoExist && !audioExist) {
          var _moovBox = MP4Parser.findBox(videoData, ["moov"])[0];
          if (!_moovBox)
            throw new Error("cannot found moov box");
          MP4Parser.moovToTrack(MP4Parser.moov(_moovBox), videoTrack, audioTrack);
        }
        var _moofBox = MP4Parser.findBox(videoData, ["moof"])[0];
        if (_moofBox) {
          var tracks = MP4Parser.moofToSamples(MP4Parser.moof(_moofBox), videoTrack, audioTrack);
          var videoBaseMediaDecodeTime = videoTrack.baseMediaDecodeTime;
          var audioBaseMediaDecodeTime = audioTrack.baseMediaDecodeTime;
          var _baseOffset = _moofBox.start;
          var nalSize;
          Object.keys(tracks).forEach(function(k) {
            if (videoTrack.id == k) {
              tracks[k].map(function(x2) {
                x2.offset += _baseOffset;
                var sample = new VideoSample((x2.pts || x2.dts) + videoBaseMediaDecodeTime, x2.dts + videoBaseMediaDecodeTime);
                sample.duration = x2.duration;
                sample.gopId = x2.gopId;
                if (x2.keyframe)
                  sample.setToKeyframe();
                var sampleData = videoData.subarray(x2.offset, x2.offset + x2.size);
                sample.data = sampleData;
                var start = 0;
                var len = sampleData.length - 1;
                while (start < len) {
                  nalSize = readBig32(sampleData, start);
                  start += 4;
                  sample.units.push(sampleData.subarray(start, start + nalSize));
                  start += nalSize;
                }
                videoTrack.samples.push(sample);
              });
            } else if (audioTrack.id == k) {
              tracks[k].map(function(x2) {
                x2.offset += _baseOffset;
                var sampleData = videoData.subarray(x2.offset, x2.offset + x2.size);
                audioTrack.samples.push(new AudioSample(x2.dts + audioBaseMediaDecodeTime, sampleData, x2.duration));
              });
            }
          });
        }
      }
      return {
        videoTrack,
        audioTrack,
        metadataTrack: this.metadataTrack
      };
    }
  }, {
    key: "reset",
    value: function reset() {
      this.videoTrack.reset();
      this.audioTrack.reset();
      this.metadataTrack.reset();
    }
  }], [{
    key: "probe",
    value: function probe(data) {
      return MP4Parser.probe(data);
    }
  }]);
  return FMP4Demuxer2;
}();

// node_modules/xgplayer-transmuxer/es/mp4/buffer.js
function Concat(ResultConstructor) {
  var totalLength = 0;
  for (var _len = arguments.length, arrays = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
    arrays[_key - 1] = arguments[_key];
  }
  arrays.forEach(function(arr) {
    totalLength += arr.length;
  });
  var result = new ResultConstructor(totalLength);
  var offset = 0;
  arrays.forEach(function(arr) {
    result.set(arr, offset);
    offset += arr.length;
  });
  return result;
}
var Buffer = function() {
  function Buffer22() {
    _classCallCheck2(this, Buffer22);
    this.buffer = new Uint8Array(0);
  }
  _createClass2(Buffer22, [{
    key: "write",
    value: function write() {
      var self = this;
      for (var _len2 = arguments.length, buffer = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
        buffer[_key2] = arguments[_key2];
      }
      buffer.forEach(function(item) {
        if (item) {
          self.buffer = Concat(Uint8Array, self.buffer, item);
        } else {
          window.console.warn(item);
        }
      });
    }
  }], [{
    key: "writeUint16",
    value: function writeUint16(value) {
      return new Uint8Array([value >> 8 & 255, value & 255]);
    }
  }, {
    key: "writeUint32",
    value: function writeUint32(value) {
      return new Uint8Array([value >> 24, value >> 16 & 255, value >> 8 & 255, value & 255]);
    }
  }]);
  return Buffer22;
}();

// node_modules/xgplayer-transmuxer/es/mp4/mp4.js
var UINT32_MAX = Math.pow(2, 32) - 1;
var MP4 = function() {
  function MP422() {
    _classCallCheck2(this, MP422);
  }
  _createClass2(MP422, null, [{
    key: "box",
    value: function box(type) {
      for (var _len = arguments.length, payload = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
        payload[_key - 1] = arguments[_key];
      }
      payload = payload.filter(Boolean);
      var size = 8 + payload.reduce(function(p, c) {
        return p + c.byteLength;
      }, 0);
      var ret = new Uint8Array(size);
      ret[0] = size >> 24 & 255;
      ret[1] = size >> 16 & 255;
      ret[2] = size >> 8 & 255;
      ret[3] = size & 255;
      ret.set(type, 4);
      var offset = 8;
      payload.forEach(function(data) {
        ret.set(data, offset);
        offset += data.byteLength;
      });
      return ret;
    }
  }, {
    key: "ftyp",
    value: function ftyp(tracks) {
      var isHevc = tracks.find(function(t) {
        return t.type === TrackType.VIDEO && t.codecType === VideoCodecType.HEVC;
      });
      return isHevc ? MP422.FTYPHEV1 : MP422.FTYPAVC1;
    }
  }, {
    key: "initSegment",
    value: function initSegment(tracks) {
      var ftyp = MP422.ftyp(tracks);
      var init = concatUint8Array(ftyp, MP422.moov(tracks));
      return init;
    }
  }, {
    key: "pssh",
    value: function pssh(data) {
      var content = new Uint8Array([
        1,
        0,
        0,
        0
      ].concat([16, 119, 239, 236, 192, 178, 77, 2, 172, 227, 60, 30, 82, 226, 251, 75], [0, 0, 0, 1], parse(data.kid), [0, 0, 0, 0]));
      return MP422.box(MP422.types.pssh, content);
    }
  }, {
    key: "moov",
    value: function moov(tracks) {
      if (tracks[0].useEME && (tracks[0].encv || tracks[0].enca)) {
        if (!tracks[0].pssh) {
          tracks[0].pssh = {
            kid: tracks[0].kid
          };
        }
        var pssh = this.pssh(tracks[0].pssh);
        return MP422.box.apply(MP422, [MP422.types.moov, MP422.mvhd(tracks[0].mvhdDurtion || tracks[0].duration, tracks[0].mvhdTimecale || tracks[0].timescale), MP422.mvex(tracks)].concat(_toConsumableArray(tracks.map(function(t) {
          return MP422.trak(t);
        })), [pssh]));
      } else {
        return MP422.box.apply(MP422, [MP422.types.moov, MP422.mvhd(tracks[0].mvhdDurtion || tracks[0].duration, tracks[0].mvhdTimecale || tracks[0].timescale)].concat(_toConsumableArray(tracks.map(function(t) {
          return MP422.trak(t);
        })), [MP422.mvex(tracks)]));
      }
    }
  }, {
    key: "mvhd",
    value: function mvhd(duration) {
      var timescale = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 9e4;
      var mvhd2 = MP422.box(MP422.types.mvhd, new Uint8Array([
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        timescale >> 24 & 255,
        timescale >> 16 & 255,
        timescale >> 8 & 255,
        timescale & 255,
        duration >> 24 & 255,
        duration >> 16 & 255,
        duration >> 8 & 255,
        duration & 255,
        0,
        1,
        0,
        0,
        1,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        1,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        1,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        64,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        255,
        255,
        255,
        255
      ]));
      return mvhd2;
    }
  }, {
    key: "trak",
    value: function trak(track) {
      var trak2 = MP422.box(MP422.types.trak, MP422.tkhd(track.id, track.tkhdDuration || 0, track.width, track.height), MP422.mdia(track));
      return trak2;
    }
  }, {
    key: "tkhd",
    value: function tkhd(id, duration) {
      var width = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 0;
      var height = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : 0;
      var tkhd2 = MP422.box(MP422.types.tkhd, new Uint8Array([
        0,
        0,
        0,
        7,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        id >> 24 & 255,
        id >> 16 & 255,
        id >> 8 & 255,
        id & 255,
        0,
        0,
        0,
        0,
        duration >> 24 & 255,
        duration >> 16 & 255,
        duration >> 8 & 255,
        duration & 255,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        1,
        0,
        0,
        0,
        0,
        1,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        1,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        64,
        0,
        0,
        0,
        width >> 8 & 255,
        width & 255,
        0,
        0,
        height >> 8 & 255,
        height & 255,
        0,
        0
      ]));
      return tkhd2;
    }
  }, {
    key: "mdia",
    value: function mdia(track) {
      var mdia2 = MP422.box(MP422.types.mdia, MP422.mdhd(track.duration, track.timescale), MP422.hdlr(track.type), MP422.minf(track));
      return mdia2;
    }
  }, {
    key: "mdhd",
    value: function mdhd(duration) {
      var timescale = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 9e4;
      var mdhd2 = MP422.box(MP422.types.mdhd, new Uint8Array([
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        timescale >> 24 & 255,
        timescale >> 16 & 255,
        timescale >> 8 & 255,
        timescale & 255,
        duration >> 24 & 255,
        duration >> 16 & 255,
        duration >> 8 & 255,
        duration & 255,
        85,
        196,
        0,
        0
      ]));
      return mdhd2;
    }
  }, {
    key: "hdlr",
    value: function hdlr(type) {
      var hdlr2 = MP422.box(MP422.types.hdlr, MP422.HDLR_TYPES[type]);
      return hdlr2;
    }
  }, {
    key: "minf",
    value: function minf(track) {
      var minf2 = MP422.box(MP422.types.minf, track.type === TrackType.VIDEO ? MP422.VMHD : MP422.SMHD, MP422.DINF, MP422.stbl(track));
      return minf2;
    }
  }, {
    key: "stbl",
    value: function stbl(track) {
      var extBox = [];
      if (track && track.ext) {
        track.ext.stss && extBox.push(MP422.stss(track.ext.stss.entries));
      }
      var stbl2 = MP422.box(MP422.types.stbl, MP422.stsd(track), MP422.STTS, extBox[0], MP422.STSC, MP422.STSZ, MP422.STCO);
      return stbl2;
    }
  }, {
    key: "stsd",
    value: function stsd(track) {
      var content;
      if (track.type === "audio") {
        if (track.useEME && track.enca) {
          content = MP422.enca(track);
        } else {
          content = MP422.mp4a(track);
        }
      } else if (track.useEME && track.encv) {
        content = MP422.encv(track);
      } else {
        content = MP422.avc1hev1(track);
      }
      var stsd2 = MP422.box(MP422.types.stsd, new Uint8Array([
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        1
      ]), content);
      return stsd2;
    }
  }, {
    key: "enca",
    value: function enca(data) {
      var channelCount = data.enca.channelCount;
      var sampleRate = data.enca.sampleRate;
      var content = new Uint8Array([
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        1,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        channelCount,
        0,
        16,
        0,
        0,
        0,
        0,
        sampleRate >> 8 & 255,
        sampleRate & 255,
        0,
        0
      ]);
      var esds = MP422.esds(data.config);
      var sinf = MP422.sinf(data.enca);
      return MP422.box(MP422.types.enca, content, esds, sinf);
    }
  }, {
    key: "encv",
    value: function encv(track) {
      var _concat$concat, _ref;
      var sps = track.sps.length > 0 ? track.sps[0] : [];
      var pps = track.pps.length > 0 ? track.pps[0] : [];
      var width = track.width;
      var height = track.height;
      var hSpacing = track.sarRatio[0];
      var vSpacing = track.sarRatio[1];
      var content = new Uint8Array([
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        1,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        width >> 8 & 255,
        width & 255,
        height >> 8 & 255,
        height & 255,
        0,
        72,
        0,
        0,
        0,
        72,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        1,
        18,
        100,
        97,
        105,
        108,
        121,
        109,
        111,
        116,
        105,
        111,
        110,
        47,
        104,
        108,
        115,
        46,
        106,
        115,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        24,
        17,
        17
      ]);
      var avcc = new Uint8Array((_concat$concat = (_ref = [
        1,
        sps[1],
        sps[2],
        sps[3],
        252 | 3,
        224 | 1,
        sps.length >>> 8 & 255,
        sps.length & 255
      ]).concat.apply(_ref, _toConsumableArray(sps)).concat([1, pps.length >>> 8 & 255, pps.length & 255])).concat.apply(_concat$concat, _toConsumableArray(pps)));
      var btrt = new Uint8Array([0, 0, 88, 57, 0, 15, 200, 192, 0, 4, 86, 72]);
      var sinf = MP422.sinf(track.encv);
      var pasp = new Uint8Array([
        hSpacing >> 24,
        hSpacing >> 16 & 255,
        hSpacing >> 8 & 255,
        hSpacing & 255,
        vSpacing >> 24,
        vSpacing >> 16 & 255,
        vSpacing >> 8 & 255,
        vSpacing & 255
      ]);
      return MP422.box(MP422.types.encv, content, MP422.box(MP422.types.avcC, avcc), MP422.box(MP422.types.btrt, btrt), sinf, MP422.box(MP422.types.pasp, pasp));
    }
  }, {
    key: "schi",
    value: function schi(data) {
      var content = new Uint8Array([]);
      var tenc = MP422.tenc(data);
      return MP422.box(MP422.types.schi, content, tenc);
    }
  }, {
    key: "tenc",
    value: function tenc(data) {
      var content = new Uint8Array([
        0,
        0,
        0,
        0,
        0,
        0,
        data.default_IsEncrypted & 255,
        data.default_IV_size & 255
      ].concat(parse(data.default_KID)));
      return MP422.box(MP422.types.tenc, content);
    }
  }, {
    key: "sinf",
    value: function sinf(data) {
      var content = new Uint8Array([]);
      var frma = new Uint8Array([data.data_format.charCodeAt(0), data.data_format.charCodeAt(1), data.data_format.charCodeAt(2), data.data_format.charCodeAt(3)]);
      var schm = new Uint8Array([
        0,
        0,
        0,
        0,
        99,
        101,
        110,
        99,
        0,
        1,
        0,
        0
      ]);
      var schi = MP422.schi(data);
      return MP422.box(MP422.types.sinf, content, MP422.box(MP422.types.frma, frma), MP422.box(MP422.types.schm, schm), schi);
    }
  }, {
    key: "avc1hev1",
    value: function avc1hev1(track) {
      var isHevc = track.codecType === VideoCodecType.HEVC;
      var typ = isHevc ? MP422.types.hvc1 : MP422.types.avc1;
      var config = isHevc ? MP422.hvcC(track) : MP422.avcC(track);
      var boxes = [new Uint8Array([
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        1,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        track.width >> 8 & 255,
        track.width & 255,
        track.height >> 8 & 255,
        track.height & 255,
        0,
        72,
        0,
        0,
        0,
        72,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        1,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        24,
        17,
        17
      ]), config];
      if (isHevc) {
        boxes.push(MP422.box(MP422.types.fiel, new Uint8Array([1, 0])));
      } else if (track.sarRatio && track.sarRatio.length > 1) {
        boxes.push(MP422.pasp(track.sarRatio));
      }
      return MP422.box.apply(MP422, [typ].concat(boxes));
    }
  }, {
    key: "avcC",
    value: function avcC(track) {
      var _concat$concat2, _ref2;
      var sps = [];
      var pps = [];
      var len;
      track.sps.forEach(function(s) {
        len = s.byteLength;
        sps.push(len >>> 8 & 255);
        sps.push(len & 255);
        sps.push.apply(sps, _toConsumableArray(s));
      });
      track.pps.forEach(function(p) {
        len = p.byteLength;
        pps.push(len >>> 8 & 255);
        pps.push(len & 255);
        pps.push.apply(pps, _toConsumableArray(p));
      });
      return MP422.box(MP422.types.avcC, new Uint8Array((_concat$concat2 = (_ref2 = [
        1,
        sps[3],
        sps[4],
        sps[5],
        252 | 3,
        224 | track.sps.length
      ]).concat.apply(_ref2, sps).concat([track.pps.length])).concat.apply(_concat$concat2, pps)));
    }
  }, {
    key: "hvcC",
    value: function hvcC(track) {
      var hvcC2 = track.hvcC;
      if (hvcC2 instanceof ArrayBuffer || hvcC2 instanceof Uint8Array)
        return hvcC2;
      var vps = track.vps, sps = track.sps, pps = track.pps;
      var data;
      if (hvcC2) {
        var pcf = hvcC2.generalProfileCompatibilityFlags;
        var cif = hvcC2.generalConstraintIndicatorFlags;
        var numOfArrays = (vps.length && 1) + (sps.length && 1) + (pps.length && 1);
        data = [
          1,
          hvcC2.generalProfileSpace << 6 | hvcC2.generalTierFlag << 5 | hvcC2.generalProfileIdc,
          pcf >>> 24,
          pcf >>> 16,
          pcf >>> 8,
          pcf,
          cif[0],
          cif[1],
          cif[2],
          cif[3],
          cif[4],
          cif[5],
          hvcC2.generalLevelIdc,
          240,
          0,
          252,
          hvcC2.chromaFormatIdc | 252,
          hvcC2.bitDepthLumaMinus8 | 248,
          hvcC2.bitDepthChromaMinus8 | 248,
          0,
          0,
          hvcC2.numTemporalLayers << 3 | hvcC2.temporalIdNested << 2 | 3,
          numOfArrays
        ];
        var write = function write2(x2) {
          var _data;
          data.push(x2.length >> 8, x2.length);
          (_data = data).push.apply(_data, _toConsumableArray(x2));
        };
        if (vps.length) {
          data.push(160, 0, vps.length);
          vps.forEach(write);
        }
        if (sps.length) {
          data.push(161, 0, sps.length);
          sps.forEach(write);
        }
        if (pps.length) {
          data.push(162, 0, pps.length);
          pps.forEach(write);
        }
      } else {
        data = [
          1,
          1,
          96,
          0,
          0,
          0,
          144,
          0,
          0,
          0,
          0,
          0,
          93,
          240,
          0,
          252,
          253,
          248,
          248,
          0,
          0,
          15,
          3,
          160,
          0,
          1,
          0,
          24,
          64,
          1,
          12,
          1,
          255,
          255,
          1,
          96,
          0,
          0,
          3,
          0,
          144,
          0,
          0,
          3,
          0,
          0,
          3,
          0,
          93,
          153,
          152,
          9,
          161,
          0,
          1,
          0,
          45,
          66,
          1,
          1,
          1,
          96,
          0,
          0,
          3,
          0,
          144,
          0,
          0,
          3,
          0,
          0,
          3,
          0,
          93,
          160,
          2,
          128,
          128,
          45,
          22,
          89,
          153,
          164,
          147,
          43,
          154,
          128,
          128,
          128,
          130,
          0,
          0,
          3,
          0,
          2,
          0,
          0,
          3,
          0,
          50,
          16,
          162,
          0,
          1,
          0,
          7,
          68,
          1,
          193,
          114,
          180,
          98,
          64
        ];
      }
      return MP422.box(MP422.types.hvcC, new Uint8Array(data));
    }
  }, {
    key: "pasp",
    value: function pasp(_ref3) {
      var _ref4 = _slicedToArray(_ref3, 2), hSpacing = _ref4[0], vSpacing = _ref4[1];
      return MP422.box(MP422.types.pasp, new Uint8Array([hSpacing >> 24, hSpacing >> 16 & 255, hSpacing >> 8 & 255, hSpacing & 255, vSpacing >> 24, vSpacing >> 16 & 255, vSpacing >> 8 & 255, vSpacing & 255]));
    }
  }, {
    key: "mp4a",
    value: function mp4a(track) {
      return MP422.box(MP422.types.mp4a, new Uint8Array([
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        1,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        track.channelCount,
        0,
        16,
        0,
        0,
        0,
        0,
        track.sampleRate >> 8 & 255,
        track.sampleRate & 255,
        0,
        0
      ]), track.config.length ? MP422.esds(track.config) : void 0);
    }
  }, {
    key: "esds",
    value: function esds(config) {
      var len = config.length;
      var esds2 = MP422.box(MP422.types.esds, new Uint8Array([
        0,
        0,
        0,
        0,
        3,
        23 + len,
        0,
        0,
        0,
        4,
        15 + len,
        64,
        21,
        0,
        6,
        0,
        0,
        0,
        218,
        192,
        0,
        0,
        218,
        192,
        5
      ].concat([len]).concat(config).concat(
        [6, 1, 2]
      )));
      return esds2;
    }
  }, {
    key: "mvex",
    value: function mvex(tracks) {
      var mvex2 = MP422.box.apply(MP422, [MP422.types.mvex].concat(_toConsumableArray(tracks.map(function(t) {
        return MP422.trex(t.id);
      }))));
      return mvex2;
    }
  }, {
    key: "trex",
    value: function trex(id) {
      var trex2 = MP422.box(MP422.types.trex, new Uint8Array([
        0,
        0,
        0,
        0,
        id >> 24,
        id >> 16 & 255,
        id >> 8 & 255,
        id & 255,
        0,
        0,
        0,
        1,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        1,
        0,
        1
      ]));
      return trex2;
    }
  }, {
    key: "trex1",
    value: function trex1(id) {
      var trex = MP422.box(MP422.types.trex, new Uint8Array([
        0,
        0,
        0,
        0,
        id >> 24,
        id >> 16 & 255,
        id >> 8 & 255,
        id & 255,
        0,
        0,
        0,
        1,
        0,
        0,
        2,
        0,
        0,
        0,
        0,
        0,
        0,
        1,
        0,
        0
      ]));
      return trex;
    }
  }, {
    key: "trex2",
    value: function trex2(id) {
      var trex = MP422.box(MP422.types.trex, new Uint8Array([
        0,
        0,
        0,
        0,
        id >> 24,
        id >> 16 & 255,
        id >> 8 & 255,
        id & 255,
        0,
        0,
        0,
        1,
        0,
        0,
        4,
        0,
        0,
        0,
        0,
        0,
        2,
        0,
        0,
        0
      ]));
      return trex;
    }
  }, {
    key: "moof",
    value: function moof(tracks) {
      var moof2 = MP422.box.apply(MP422, [MP422.types.moof, MP422.mfhd(tracks[0].samples ? tracks[0].samples[0].gopId : 0)].concat(_toConsumableArray(tracks.map(function(t) {
        return MP422.traf(t);
      }))));
      return moof2;
    }
  }, {
    key: "mfhd",
    value: function mfhd(sequenceNumber) {
      var mfhd2 = MP422.box(MP422.types.mfhd, new Uint8Array([
        0,
        0,
        0,
        0,
        sequenceNumber >> 24,
        sequenceNumber >> 16 & 255,
        sequenceNumber >> 8 & 255,
        sequenceNumber & 255
      ]));
      return mfhd2;
    }
  }, {
    key: "traf",
    value: function traf(track) {
      var tfhd = MP422.tfhd(track.id);
      var tfdt = MP422.tfdt(track, track.baseMediaDecodeTime);
      var sencLength = 0;
      var samples;
      if (track.isVideo && track.videoSenc) {
        samples = track.videoSenc;
        samples.forEach(function(item) {
          sencLength = sencLength + 8;
          if (item.subsamples && item.subsamples.length) {
            sencLength = sencLength + 2;
            sencLength = sencLength + item.subsamples.length * 6;
          }
        });
      }
      track.videoSencLength = sencLength;
      if (!track.useEME || !track.isVideoEncryption && !track.isAudioEncryption) {
        var sdtp = MP422.sdtp(track);
        var offset = 16 + 20 + 8 + 16 + 8 + 8;
        return MP422.box(MP422.types.traf, tfhd, tfdt, sdtp, MP422.trun(track.samples, sdtp.byteLength + offset));
      } else if (track.isVideoEncryption) {
        if (track.isVideo) {
          var saiz = MP422.saiz(track);
          var saio = MP422.saio(track);
          var trun = MP422.trun1(track);
          var senc = MP422.senc(track);
          var traf2 = MP422.box(MP422.types.traf, tfhd, tfdt, saiz, saio, trun, senc);
          return traf2;
        } else {
          if (!track.isAudioEncryption) {
            var sbgp = MP422.sbgp();
            var _trun = MP422.trun1(track);
            return MP422.box(MP422.types.traf, tfhd, tfdt, sbgp, _trun);
          } else {
            var _sbgp = MP422.sbgp();
            var _saiz = MP422.saiz(track);
            var _saio = MP422.saio(track);
            var _senc = MP422.senc(track);
            var _trun2 = MP422.trun1(track);
            var _traf = MP422.box(MP422.types.traf, tfhd, tfdt, _sbgp, _saiz, _saio, _senc, _trun2);
            return _traf;
          }
        }
      } else {
        if (track.isVideo) {
          var _trun3 = MP422.trun1(track);
          return MP422.box(MP422.types.traf, tfhd, tfdt, _trun3);
        } else {
          var _sbgp2 = MP422.sbgp();
          var _saiz2 = MP422.saiz(track);
          var _saio2 = MP422.saio(track);
          var _senc2 = MP422.senc(track);
          var _trun4 = MP422.trun1(track);
          var _traf2 = MP422.box(MP422.types.traf, tfhd, tfdt, _sbgp2, _saiz2, _saio2, _senc2, _trun4);
          return _traf2;
        }
      }
    }
  }, {
    key: "sdtp",
    value: function sdtp(data) {
      var buffer = new Buffer();
      data.samples.forEach(function(item) {
        buffer.write(new Uint8Array(data.isVideo ? [item.keyframe ? 32 : 16] : [16]));
      });
      return MP422.box(MP422.types.sdtp, this.extension(0, 0), buffer.buffer);
    }
  }, {
    key: "trun1",
    value: function trun1(data) {
      var buffer = new Buffer();
      var sampleCount = Buffer.writeUint32(data.samples.length);
      var offset = null;
      if (data.isVideo) {
        var sencLength = data.videoSencLength;
        offset = Buffer.writeUint32(data.samples.length * 16 + sencLength + 149);
        if (!data.isVideoEncryption && data.isAudioEncryption) {
          offset = Buffer.writeUint32(data.samples.length * 16 + 92);
        }
      } else {
        var len = data.samples.length * 12 + 124;
        if (data.isAudioEncryption) {
          len = data.samples.length * 12 + 8 * data.audioSenc.length + 177;
        }
        offset = Buffer.writeUint32(len);
      }
      data.samples.forEach(function(item) {
        buffer.write(Buffer.writeUint32(item.duration));
        buffer.write(Buffer.writeUint32(item.size));
        buffer.write(Buffer.writeUint32(item.keyframe ? 33554432 : 65536));
        if (data.isVideo) {
          buffer.write(Buffer.writeUint32(item.cts ? item.cts : 0));
        }
      });
      return MP422.box(MP422.types.trun, this.extension(0, data.flags), sampleCount, offset, buffer.buffer);
    }
  }, {
    key: "senc",
    value: function senc(data) {
      var buffer = new Buffer();
      var len = data.samples.length;
      var ceil = data.isVideo ? 16 : 8;
      var flag = data.isVideo ? 2 : 0;
      var samples = [];
      var samplesLength = 0;
      if (data.isVideo) {
        samples = data.videoSenc;
        samplesLength = data.videoSencLength;
      } else {
        samples = data.audioSenc;
      }
      samplesLength = samplesLength || ceil * len;
      buffer.write(Buffer.writeUint32(16 + samplesLength), MP422.types.senc, this.extension(0, flag));
      buffer.write(Buffer.writeUint32(len));
      samples.forEach(function(item) {
        for (var i = 0; i < item.InitializationVector.length; i++) {
          buffer.write(new Uint8Array([item.InitializationVector[i]]));
        }
        if (item.subsamples && item.subsamples.length) {
          buffer.write(Buffer.writeUint16(item.subsamples.length));
          item.subsamples.forEach(function(value) {
            buffer.write(Buffer.writeUint16(value.BytesOfClearData));
            buffer.write(Buffer.writeUint32(value.BytesOfProtectedData));
          });
        }
      });
      return buffer.buffer;
    }
  }, {
    key: "saio",
    value: function saio(data) {
      var length = data.samples.length * 12 + 141;
      if (!data.isVideo && data.isAudioEncryption) {
        length = 149;
      }
      var content = new Uint8Array([1, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, length >> 24 & 255, length >> 16 & 255, length >> 8 & 255, length & 255]);
      return MP422.box(MP422.types.saio, content);
    }
  }, {
    key: "saiz",
    value: function saiz(data) {
      var samplesLength = data.samples.length;
      var content = new Uint8Array([
        0,
        0,
        0,
        0,
        16,
        samplesLength >> 24 & 255,
        samplesLength >> 16 & 255,
        samplesLength >> 8 & 255,
        samplesLength & 255
      ]);
      return MP422.box(MP422.types.saiz, content);
    }
  }, {
    key: "sbgp",
    value: function sbgp() {
      var content = new Uint8Array([
        114,
        111,
        108,
        108,
        0,
        0,
        0,
        1,
        0,
        0,
        1,
        25,
        0,
        0,
        0,
        1
      ]);
      return MP422.box(MP422.types.sbgp, this.extension(0, 0), content);
    }
  }, {
    key: "extension",
    value: function extension(version2, flag) {
      return new Uint8Array([version2, flag >> 16 & 255, flag >> 8 & 255, flag & 255]);
    }
  }, {
    key: "tfhd",
    value: function tfhd(id) {
      return MP422.box(MP422.types.tfhd, new Uint8Array([
        0,
        0,
        0,
        0,
        id >> 24,
        id >> 16 & 255,
        id >> 8 & 255,
        id & 255
      ]));
    }
  }, {
    key: "tfdt",
    value: function tfdt(data, baseMediaDecodeTime) {
      var upperWordBaseMediaDecodeTime = Math.floor(baseMediaDecodeTime / (UINT32_MAX + 1));
      var lowerWordBaseMediaDecodeTime = Math.floor(baseMediaDecodeTime % (UINT32_MAX + 1));
      if (data.useEME && (data.isVideoEncryption || data.isAudioEncryption)) {
        return MP422.box(MP422.types.tfdt, new Uint8Array([
          0,
          0,
          0,
          0,
          lowerWordBaseMediaDecodeTime >> 24,
          lowerWordBaseMediaDecodeTime >> 16 & 255,
          lowerWordBaseMediaDecodeTime >> 8 & 255,
          lowerWordBaseMediaDecodeTime & 255
        ]));
      } else {
        return MP422.box(MP422.types.tfdt, new Uint8Array([
          1,
          0,
          0,
          0,
          upperWordBaseMediaDecodeTime >> 24,
          upperWordBaseMediaDecodeTime >> 16 & 255,
          upperWordBaseMediaDecodeTime >> 8 & 255,
          upperWordBaseMediaDecodeTime & 255,
          lowerWordBaseMediaDecodeTime >> 24,
          lowerWordBaseMediaDecodeTime >> 16 & 255,
          lowerWordBaseMediaDecodeTime >> 8 & 255,
          lowerWordBaseMediaDecodeTime & 255
        ]));
      }
    }
  }, {
    key: "trun",
    value: function trun(samples, offset) {
      var sampleLen = samples.length;
      var dataLen = 12 + 16 * sampleLen;
      offset += 8 + dataLen;
      var data = new Uint8Array(dataLen);
      data.set([
        0,
        0,
        15,
        1,
        sampleLen >>> 24 & 255,
        sampleLen >>> 16 & 255,
        sampleLen >>> 8 & 255,
        sampleLen & 255,
        offset >>> 24 & 255,
        offset >>> 16 & 255,
        offset >>> 8 & 255,
        offset & 255
      ], 0);
      for (var i = 0; i < sampleLen; i++) {
        var _samples$i = samples[i], duration = _samples$i.duration, size = _samples$i.size, _samples$i$flag = _samples$i.flag, flag = _samples$i$flag === void 0 ? {} : _samples$i$flag, _samples$i$cts = _samples$i.cts, cts = _samples$i$cts === void 0 ? 0 : _samples$i$cts;
        data.set([
          duration >>> 24 & 255,
          duration >>> 16 & 255,
          duration >>> 8 & 255,
          duration & 255,
          size >>> 24 & 255,
          size >>> 16 & 255,
          size >>> 8 & 255,
          size & 255,
          flag.isLeading << 2 | (flag.dependsOn === null || flag.dependsOn === void 0 ? 1 : flag.dependsOn),
          flag.isDependedOn << 6 | flag.hasRedundancy << 4 | flag.paddingValue << 1 | (flag.isNonSyncSample === null || flag.isNonSyncSample === void 0 ? 1 : flag.isNonSyncSample),
          flag.degradationPriority & 240 << 8,
          flag.degradationPriority & 15,
          cts >>> 24 & 255,
          cts >>> 16 & 255,
          cts >>> 8 & 255,
          cts & 255
        ], 12 + 16 * i);
      }
      return MP422.box(MP422.types.trun, data);
    }
  }, {
    key: "moovMP4",
    value: function moovMP4(tracks) {
      return MP422.box.apply(MP422, [MP422.types.moov, MP422.mvhd(tracks[0].duration, tracks[0].timescale)].concat(_toConsumableArray(tracks.map(function(t) {
        return MP422.trackMP4(t);
      }))));
    }
  }, {
    key: "trackMP4",
    value: function trackMP4(track) {
      return MP422.box(MP422.types.trak, MP422.tkhd(track.id, track.duration, track.width, track.height), MP422.mdiaMP4(track));
    }
  }, {
    key: "mdiaMP4",
    value: function mdiaMP4(track) {
      return MP422.box(MP422.types.mdia, MP422.mdhd(track.duration, track.timescale), MP422.hdlr(track.type), MP422.minfMP4(track));
    }
  }, {
    key: "minfMP4",
    value: function minfMP4(track) {
      return MP422.box(MP422.types.minf, track.type === TrackType.VIDEO ? MP422.VMHD : MP422.SMHD, MP422.DINF, MP422.stblMP4(track));
    }
  }, {
    key: "stblMP4",
    value: function stblMP4(track) {
      var ext = track.ext;
      var boxes = [MP422.stsd(track), MP422.stts(ext.stts), MP422.stsc(ext.stsc), MP422.stsz(ext.stsz), MP422.stco(ext.stco)];
      if (ext.stss.length) {
        boxes.push(MP422.stss(ext.stss));
      }
      if (ext.ctts.length) {
        boxes.push(MP422.ctts(ext.ctts));
      }
      return MP422.box.apply(MP422, [MP422.types.stbl].concat(boxes));
    }
  }, {
    key: "stts",
    value: function stts(samples) {
      var len = samples.length;
      var data = new Uint8Array(8 * len);
      var offset = 0;
      samples.forEach(function(_ref5) {
        var value = _ref5.value, count = _ref5.count;
        data.set([count >> 24, count >> 16 & 255, count >> 8 & 255, count & 255, value >> 24, value >> 16 & 255, value >> 8 & 255, value & 255], offset);
        offset += 8;
      });
      return MP422.box(MP422.types.stts, concatUint8Array(new Uint8Array([0, 0, 0, 0, len >> 24, len >> 16 & 255, len >> 8 & 255, len & 255]), data));
    }
  }, {
    key: "stsc",
    value: function stsc(entries) {
      var len = entries.length;
      var data = new Uint8Array(12 * len);
      var offset = 0;
      entries.forEach(function(_ref6) {
        var firstChunk = _ref6.firstChunk, samplesPerChunk = _ref6.samplesPerChunk, sampleDescIndex = _ref6.sampleDescIndex;
        data.set([firstChunk >> 24, firstChunk >> 16 & 255, firstChunk >> 8 & 255, firstChunk & 255, samplesPerChunk >> 24, samplesPerChunk >> 16 & 255, samplesPerChunk >> 8 & 255, samplesPerChunk & 255, sampleDescIndex >> 24, sampleDescIndex >> 16 & 255, sampleDescIndex >> 8 & 255, sampleDescIndex & 255], offset);
        offset += 12;
      });
      return MP422.box(MP422.types.stsc, concatUint8Array(new Uint8Array([0, 0, 0, 0, len >> 24, len >> 16 & 255, len >> 8 & 255, len & 255]), data));
    }
  }, {
    key: "stsz",
    value: function stsz(samplesSizes) {
      var len = samplesSizes.length;
      var data = new Uint8Array(4 * len);
      var offset = 0;
      samplesSizes.forEach(function(x2) {
        data.set([x2 >> 24, x2 >> 16 & 255, x2 >> 8 & 255, x2 & 255], offset);
        offset += 4;
      });
      return MP422.box(MP422.types.stsz, concatUint8Array(new Uint8Array([0, 0, 0, 0, 0, 0, 0, 0, len >> 24, len >> 16 & 255, len >> 8 & 255, len & 255]), data));
    }
  }, {
    key: "stco",
    value: function stco(offsets) {
      var len = offsets.length;
      var data = new Uint8Array(4 * len);
      var offset = 0;
      offsets.forEach(function(x2) {
        data.set([x2 >> 24, x2 >> 16 & 255, x2 >> 8 & 255, x2 & 255], offset);
        offset += 4;
      });
      return MP422.box(MP422.types.stco, concatUint8Array(new Uint8Array([0, 0, 0, 0, len >> 24, len >> 16 & 255, len >> 8 & 255, len & 255]), data));
    }
  }, {
    key: "stss",
    value: function stss(keyframeIndexes) {
      var len = keyframeIndexes.length;
      var data = new Uint8Array(4 * len);
      var offset = 0;
      keyframeIndexes.forEach(function(x2) {
        data.set([x2 >> 24, x2 >> 16 & 255, x2 >> 8 & 255, x2 & 255], offset);
        offset += 4;
      });
      return MP422.box(MP422.types.stss, concatUint8Array(new Uint8Array([0, 0, 0, 0, len >> 24, len >> 16 & 255, len >> 8 & 255, len & 255]), data));
    }
  }, {
    key: "ctts",
    value: function ctts(samples) {
      var len = samples.length;
      var data = new Uint8Array(8 * len);
      var offset = 0;
      samples.forEach(function(_ref7) {
        var value = _ref7.value, count = _ref7.count;
        data.set([count >> 24, count >> 16 & 255, count >> 8 & 255, count & 255, value >> 24, value >> 16 & 255, value >> 8 & 255, value & 255], offset);
        offset += 8;
      });
      return MP422.box(MP422.types.ctts, concatUint8Array(new Uint8Array([0, 0, 0, 0, len >> 24, len >> 16 & 255, len >> 8 & 255, len & 255]), data));
    }
  }, {
    key: "styp",
    value: function styp() {
      return MP422.box(MP422.types.styp, new Uint8Array([109, 115, 100, 104, 0, 0, 0, 0, 109, 115, 100, 104, 109, 115, 105, 120]));
    }
  }, {
    key: "sidx",
    value: function sidx(data) {
      var timescale = data.timescale;
      var duration = data.samples[0].duration;
      var durationCount = duration * data.samples.length;
      var earliestTime = data.samples[0].sampleOffset * duration;
      var mdatSize = 8;
      data.samples.forEach(function(item) {
        mdatSize += item.size;
      });
      var length = 0;
      if (data.isVideo) {
        var sencLength = 0;
        var samples;
        if (data.videoSenc) {
          samples = data.videoSenc;
        }
        if (data.isVideo) {
          samples.forEach(function(item) {
            sencLength = sencLength + 8;
            if (item.subsamples && item.subsamples.length) {
              sencLength = sencLength + 2;
              sencLength = sencLength + item.subsamples.length * 6;
            }
          });
        }
        data.videoSencLength = sencLength;
        length = mdatSize + 141 + data.samples.length * 16 + sencLength;
        if (data.useEME && data.isAudioEncryption && !data.isVideoEncryption) {
          length = mdatSize + data.samples.length * 16 + 84;
        }
      } else {
        length = mdatSize + 116 + data.samples.length * 12;
        if (data.useEME && data.isAudioEncryption) {
          length = mdatSize + 169 + data.samples.length * 12 + 8 * data.audioSenc.length;
        }
      }
      var content = new Uint8Array([
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        data.id & 255,
        timescale >> 24 & 255,
        timescale >> 16 & 255,
        timescale >> 8 & 255,
        timescale & 255,
        earliestTime >> 24 & 255,
        earliestTime >> 16 & 255,
        earliestTime >> 8 & 255,
        earliestTime & 255,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        1,
        0,
        length >> 16 & 255,
        length >> 8 & 255,
        length & 255,
        durationCount >> 24 & 255,
        durationCount >> 16 & 255,
        durationCount >> 8 & 255,
        durationCount & 255,
        144,
        0,
        0,
        0
      ]);
      return MP422.box(MP422.types.sidx, content);
    }
  }, {
    key: "mdat",
    value: function mdat(data) {
      var mdat2 = MP422.box(MP422.types.mdat, data);
      return mdat2;
    }
  }]);
  return MP422;
}();
_defineProperty2(MP4, "types", ["avc1", "avcC", "hvc1", "hvcC", "dinf", "dref", "esds", "ftyp", "hdlr", "mdat", "mdhd", "mdia", "mfhd", "minf", "moof", "moov", "mp4a", "mvex", "mvhd", "pasp", "stbl", "stco", "stsc", "stsd", "stsz", "stts", "tfdt", "tfhd", "traf", "trak", "trex", "tkhd", "vmhd", "smhd", "ctts", "stss", "styp", "pssh", "sidx", "sbgp", "saiz", "saio", "senc", "trun", "encv", "enca", "sinf", "btrt", "frma", "tenc", "schm", "schi", "mehd", "fiel", "sdtp"].reduce(function(p, c) {
  p[c] = [c.charCodeAt(0), c.charCodeAt(1), c.charCodeAt(2), c.charCodeAt(3)];
  return p;
}, /* @__PURE__ */ Object.create(null)));
_defineProperty2(MP4, "HDLR_TYPES", {
  video: new Uint8Array([
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    118,
    105,
    100,
    101,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    86,
    105,
    100,
    101,
    111,
    72,
    97,
    110,
    100,
    108,
    101,
    114,
    0
  ]),
  audio: new Uint8Array([
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    115,
    111,
    117,
    110,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    83,
    111,
    117,
    110,
    100,
    72,
    97,
    110,
    100,
    108,
    101,
    114,
    0
  ])
});
_defineProperty2(MP4, "FTYPAVC1", MP4.box(MP4.types.ftyp, new Uint8Array([
  105,
  115,
  111,
  109,
  0,
  0,
  0,
  1,
  105,
  115,
  111,
  109,
  97,
  118,
  99,
  49
])));
_defineProperty2(MP4, "FTYPHEV1", MP4.box(MP4.types.ftyp, new Uint8Array([
  105,
  115,
  111,
  109,
  0,
  0,
  0,
  1,
  105,
  115,
  111,
  109,
  104,
  101,
  118,
  49
])));
_defineProperty2(MP4, "DINF", MP4.box(MP4.types.dinf, MP4.box(MP4.types.dref, new Uint8Array([
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  1,
  0,
  0,
  0,
  12,
  117,
  114,
  108,
  32,
  0,
  0,
  0,
  1
]))));
_defineProperty2(MP4, "VMHD", MP4.box(MP4.types.vmhd, new Uint8Array([
  0,
  0,
  0,
  1,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0
])));
_defineProperty2(MP4, "SMHD", MP4.box(MP4.types.smhd, new Uint8Array([
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0
])));
_defineProperty2(MP4, "StblTable", new Uint8Array([
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0
]));
_defineProperty2(MP4, "STTS", MP4.box(MP4.types.stts, MP4.StblTable));
_defineProperty2(MP4, "STSC", MP4.box(MP4.types.stsc, MP4.StblTable));
_defineProperty2(MP4, "STSZ", MP4.box(MP4.types.stsz, new Uint8Array([
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0
])));
_defineProperty2(MP4, "STCO", MP4.box(MP4.types.stco, MP4.StblTable));

// node_modules/xgplayer-transmuxer/es/mp4/logger.js
var Logger2 = function() {
  function Logger22(name, enable) {
    _classCallCheck2(this, Logger22);
    this.name = name || "";
    this._prefix = "[".concat(this.name, "]");
    Logger22.disabled = enable;
  }
  _createClass2(Logger22, [{
    key: "debug",
    value: function debug() {
      var _console;
      if (Logger22.disabled)
        return;
      for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
        args[_key] = arguments[_key];
      }
      (_console = console).debug.apply(_console, [this._prefix].concat(args));
    }
  }, {
    key: "log",
    value: function log2() {
      var _console2;
      if (Logger22.disabled)
        return;
      for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
        args[_key2] = arguments[_key2];
      }
      (_console2 = console).log.apply(_console2, [this._prefix].concat(args));
    }
  }, {
    key: "warn",
    value: function warn() {
      var _console3;
      if (Logger22.disabled)
        return;
      for (var _len3 = arguments.length, args = new Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {
        args[_key3] = arguments[_key3];
      }
      (_console3 = console).warn.apply(_console3, [this._prefix].concat(args));
    }
  }, {
    key: "error",
    value: function error() {
      var _console4;
      if (Logger22.disabled)
        return;
      for (var _len4 = arguments.length, args = new Array(_len4), _key4 = 0; _key4 < _len4; _key4++) {
        args[_key4] = arguments[_key4];
      }
      (_console4 = console).error.apply(_console4, [this._prefix].concat(args));
    }
  }, {
    key: "table",
    value: function table() {
      var _console5;
      if (Logger22.disabled)
        return;
      console.group(this._prefix);
      (_console5 = console).table.apply(_console5, arguments);
      console.groupEnd();
    }
  }], [{
    key: "enable",
    value: function enable() {
      Logger22.disabled = false;
    }
  }, {
    key: "disable",
    value: function disable() {
      Logger22.disabled = true;
    }
  }]);
  return Logger22;
}();
_defineProperty2(Logger2, "disabled", true);

// node_modules/xgplayer-transmuxer/es/mp4/fmp4-remuxer.js
var FMP4Remuxer = function() {
  function FMP4Remuxer2(videoTrack, audioTrack, options) {
    _classCallCheck2(this, FMP4Remuxer2);
    this.videoTrack = videoTrack;
    this.audioTrack = audioTrack;
    var browserVersions = /Chrome\/([^.]+)/.exec(navigator.userAgent);
    this.forceFirstIDR = browserVersions && Number(browserVersions[1]) < 50;
    this.log = new Logger2("FMP4Remuxer", options && options.openLog ? !options.openLog : true);
  }
  _createClass2(FMP4Remuxer2, [{
    key: "remux",
    value: function remux() {
      var createInit = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : false;
      var options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
      var videoTrack = this.videoTrack;
      var audioTrack = this.audioTrack;
      var hasVideo = videoTrack.exist();
      var hasAudio = audioTrack.exist();
      var videoInitSegment;
      var audioInitSegment;
      var initSegment;
      var tracks = [];
      if (createInit) {
        if (options && options.initMerge) {
          if (hasVideo) {
            tracks.push(this.videoTrack);
          }
          if (hasAudio) {
            tracks.push(this.audioTrack);
          }
          initSegment = MP4.initSegment(tracks);
        } else {
          if (hasVideo)
            videoInitSegment = MP4.initSegment([this.videoTrack]);
          if (hasAudio)
            audioInitSegment = MP4.initSegment([this.audioTrack]);
        }
      }
      var videoSegment;
      var audioSegment;
      if (hasVideo && videoTrack.hasSample()) {
        videoSegment = this._remuxVideo();
      }
      if (hasAudio && audioTrack.hasSample()) {
        audioSegment = this._remuxAudio();
      }
      videoTrack.samples = [];
      audioTrack.samples = [];
      return {
        initSegment,
        videoInitSegment,
        audioInitSegment,
        videoSegment,
        audioSegment
      };
    }
  }, {
    key: "_remuxVideo",
    value: function _remuxVideo() {
      var track = this.videoTrack;
      if (this.forceFirstIDR) {
        track.samples[0].flag = {
          dependsOn: 2,
          isNonSyncSample: 0
        };
      }
      var samples = track.samples;
      var mdatSize = 0;
      samples.forEach(function(s) {
        mdatSize += s.units.reduce(function(t, c) {
          return t + c.byteLength;
        }, 0);
        mdatSize += s.units.length * 4;
      });
      var mdata = new Uint8Array(mdatSize);
      var mdatView = new DataView(mdata.buffer);
      var _loop = function _loop2(_offset, _sample) {
        _sample = samples[i];
        var sampleSize = 0;
        _sample.units.forEach(function(u) {
          mdatView.setUint32(_offset, u.byteLength);
          _offset += 4;
          mdata.set(u, _offset);
          _offset += u.byteLength;
          sampleSize += 4 + u.byteLength;
        });
        _sample.size = sampleSize;
        offset = _offset, sample = _sample;
      };
      for (var i = 0, l = samples.length, offset = 0, sample; i < l; i++) {
        _loop(offset, sample);
      }
      var mdat = MP4.mdat(mdata);
      var moof = MP4.moof([track]);
      return concatUint8Array(moof, mdat);
    }
  }, {
    key: "_remuxAudio",
    value: function _remuxAudio() {
      var track = this.audioTrack;
      var mdata = new Uint8Array(track.samples.reduce(function(t, c) {
        return t + c.size;
      }, 0));
      track.samples.reduce(function(offset, s) {
        mdata.set(s.data, offset);
        return offset + s.size;
      }, 0);
      var mdat = MP4.mdat(mdata);
      var moof = MP4.moof([track]);
      return concatUint8Array(moof, mdat);
    }
  }, {
    key: "reset",
    value: function reset() {
      this.videoTrack.reset();
      this.audioTrack.reset();
    }
  }]);
  return FMP4Remuxer2;
}();

// node_modules/crypto-es/lib/core.js
var Base = class {
  /**
   * Extends this object and runs the init method.
   * Arguments to create() will be passed to init().
   *
   * @return {Object} The new object.
   *
   * @static
   *
   * @example
   *
   *     var instance = MyType.create();
   */
  static create(...args) {
    return new this(...args);
  }
  /**
   * Copies properties into this object.
   *
   * @param {Object} properties The properties to mix in.
   *
   * @example
   *
   *     MyType.mixIn({
   *         field: 'value'
   *     });
   */
  mixIn(properties) {
    return Object.assign(this, properties);
  }
  /**
   * Creates a copy of this object.
   *
   * @return {Object} The clone.
   *
   * @example
   *
   *     var clone = instance.clone();
   */
  clone() {
    const clone = new this.constructor();
    Object.assign(clone, this);
    return clone;
  }
};
var WordArray = class _WordArray extends Base {
  /**
   * Initializes a newly created word array.
   *
   * @param {Array} words (Optional) An array of 32-bit words.
   * @param {number} sigBytes (Optional) The number of significant bytes in the words.
   *
   * @example
   *
   *     var wordArray = CryptoJS.lib.WordArray.create();
   *     var wordArray = CryptoJS.lib.WordArray.create([0x00010203, 0x04050607]);
   *     var wordArray = CryptoJS.lib.WordArray.create([0x00010203, 0x04050607], 6);
   */
  constructor(words = [], sigBytes = words.length * 4) {
    super();
    let typedArray = words;
    if (typedArray instanceof ArrayBuffer) {
      typedArray = new Uint8Array(typedArray);
    }
    if (typedArray instanceof Int8Array || typedArray instanceof Uint8ClampedArray || typedArray instanceof Int16Array || typedArray instanceof Uint16Array || typedArray instanceof Int32Array || typedArray instanceof Uint32Array || typedArray instanceof Float32Array || typedArray instanceof Float64Array) {
      typedArray = new Uint8Array(typedArray.buffer, typedArray.byteOffset, typedArray.byteLength);
    }
    if (typedArray instanceof Uint8Array) {
      const typedArrayByteLength = typedArray.byteLength;
      const _words = [];
      for (let i = 0; i < typedArrayByteLength; i += 1) {
        _words[i >>> 2] |= typedArray[i] << 24 - i % 4 * 8;
      }
      this.words = _words;
      this.sigBytes = typedArrayByteLength;
    } else {
      this.words = words;
      this.sigBytes = sigBytes;
    }
  }
  /**
   * Creates a word array filled with random bytes.
   *
   * @param {number} nBytes The number of random bytes to generate.
   *
   * @return {WordArray} The random word array.
   *
   * @static
   *
   * @example
   *
   *     var wordArray = CryptoJS.lib.WordArray.random(16);
   */
  static random(nBytes) {
    const words = [];
    const r = (m_w) => {
      let _m_w = m_w;
      let _m_z = 987654321;
      const mask = 4294967295;
      return () => {
        _m_z = 36969 * (_m_z & 65535) + (_m_z >> 16) & mask;
        _m_w = 18e3 * (_m_w & 65535) + (_m_w >> 16) & mask;
        let result = (_m_z << 16) + _m_w & mask;
        result /= 4294967296;
        result += 0.5;
        return result * (Math.random() > 0.5 ? 1 : -1);
      };
    };
    for (let i = 0, rcache; i < nBytes; i += 4) {
      const _r = r((rcache || Math.random()) * 4294967296);
      rcache = _r() * 987654071;
      words.push(_r() * 4294967296 | 0);
    }
    return new _WordArray(words, nBytes);
  }
  /**
   * Converts this word array to a string.
   *
   * @param {Encoder} encoder (Optional) The encoding strategy to use. Default: CryptoJS.enc.Hex
   *
   * @return {string} The stringified word array.
   *
   * @example
   *
   *     var string = wordArray + '';
   *     var string = wordArray.toString();
   *     var string = wordArray.toString(CryptoJS.enc.Utf8);
   */
  toString(encoder = Hex) {
    return encoder.stringify(this);
  }
  /**
   * Concatenates a word array to this word array.
   *
   * @param {WordArray} wordArray The word array to append.
   *
   * @return {WordArray} This word array.
   *
   * @example
   *
   *     wordArray1.concat(wordArray2);
   */
  concat(wordArray) {
    const thisWords = this.words;
    const thatWords = wordArray.words;
    const thisSigBytes = this.sigBytes;
    const thatSigBytes = wordArray.sigBytes;
    this.clamp();
    if (thisSigBytes % 4) {
      for (let i = 0; i < thatSigBytes; i += 1) {
        const thatByte = thatWords[i >>> 2] >>> 24 - i % 4 * 8 & 255;
        thisWords[thisSigBytes + i >>> 2] |= thatByte << 24 - (thisSigBytes + i) % 4 * 8;
      }
    } else {
      for (let i = 0; i < thatSigBytes; i += 4) {
        thisWords[thisSigBytes + i >>> 2] = thatWords[i >>> 2];
      }
    }
    this.sigBytes += thatSigBytes;
    return this;
  }
  /**
   * Removes insignificant bits.
   *
   * @example
   *
   *     wordArray.clamp();
   */
  clamp() {
    const { words, sigBytes } = this;
    words[sigBytes >>> 2] &= 4294967295 << 32 - sigBytes % 4 * 8;
    words.length = Math.ceil(sigBytes / 4);
  }
  /**
   * Creates a copy of this word array.
   *
   * @return {WordArray} The clone.
   *
   * @example
   *
   *     var clone = wordArray.clone();
   */
  clone() {
    const clone = super.clone.call(this);
    clone.words = this.words.slice(0);
    return clone;
  }
};
var Hex = {
  /**
   * Converts a word array to a hex string.
   *
   * @param {WordArray} wordArray The word array.
   *
   * @return {string} The hex string.
   *
   * @static
   *
   * @example
   *
   *     var hexString = CryptoJS.enc.Hex.stringify(wordArray);
   */
  stringify(wordArray) {
    const { words, sigBytes } = wordArray;
    const hexChars = [];
    for (let i = 0; i < sigBytes; i += 1) {
      const bite = words[i >>> 2] >>> 24 - i % 4 * 8 & 255;
      hexChars.push((bite >>> 4).toString(16));
      hexChars.push((bite & 15).toString(16));
    }
    return hexChars.join("");
  },
  /**
   * Converts a hex string to a word array.
   *
   * @param {string} hexStr The hex string.
   *
   * @return {WordArray} The word array.
   *
   * @static
   *
   * @example
   *
   *     var wordArray = CryptoJS.enc.Hex.parse(hexString);
   */
  parse(hexStr) {
    const hexStrLength = hexStr.length;
    const words = [];
    for (let i = 0; i < hexStrLength; i += 2) {
      words[i >>> 3] |= parseInt(hexStr.substr(i, 2), 16) << 24 - i % 8 * 4;
    }
    return new WordArray(words, hexStrLength / 2);
  }
};
var Latin1 = {
  /**
   * Converts a word array to a Latin1 string.
   *
   * @param {WordArray} wordArray The word array.
   *
   * @return {string} The Latin1 string.
   *
   * @static
   *
   * @example
   *
   *     var latin1String = CryptoJS.enc.Latin1.stringify(wordArray);
   */
  stringify(wordArray) {
    const { words, sigBytes } = wordArray;
    const latin1Chars = [];
    for (let i = 0; i < sigBytes; i += 1) {
      const bite = words[i >>> 2] >>> 24 - i % 4 * 8 & 255;
      latin1Chars.push(String.fromCharCode(bite));
    }
    return latin1Chars.join("");
  },
  /**
   * Converts a Latin1 string to a word array.
   *
   * @param {string} latin1Str The Latin1 string.
   *
   * @return {WordArray} The word array.
   *
   * @static
   *
   * @example
   *
   *     var wordArray = CryptoJS.enc.Latin1.parse(latin1String);
   */
  parse(latin1Str) {
    const latin1StrLength = latin1Str.length;
    const words = [];
    for (let i = 0; i < latin1StrLength; i += 1) {
      words[i >>> 2] |= (latin1Str.charCodeAt(i) & 255) << 24 - i % 4 * 8;
    }
    return new WordArray(words, latin1StrLength);
  }
};
var Utf8 = {
  /**
   * Converts a word array to a UTF-8 string.
   *
   * @param {WordArray} wordArray The word array.
   *
   * @return {string} The UTF-8 string.
   *
   * @static
   *
   * @example
   *
   *     var utf8String = CryptoJS.enc.Utf8.stringify(wordArray);
   */
  stringify(wordArray) {
    try {
      return decodeURIComponent(escape(Latin1.stringify(wordArray)));
    } catch (e) {
      throw new Error("Malformed UTF-8 data");
    }
  },
  /**
   * Converts a UTF-8 string to a word array.
   *
   * @param {string} utf8Str The UTF-8 string.
   *
   * @return {WordArray} The word array.
   *
   * @static
   *
   * @example
   *
   *     var wordArray = CryptoJS.enc.Utf8.parse(utf8String);
   */
  parse(utf8Str) {
    return Latin1.parse(unescape(encodeURIComponent(utf8Str)));
  }
};
var BufferedBlockAlgorithm = class extends Base {
  constructor() {
    super();
    this._minBufferSize = 0;
  }
  /**
   * Resets this block algorithm's data buffer to its initial state.
   *
   * @example
   *
   *     bufferedBlockAlgorithm.reset();
   */
  reset() {
    this._data = new WordArray();
    this._nDataBytes = 0;
  }
  /**
   * Adds new data to this block algorithm's buffer.
   *
   * @param {WordArray|string} data
   *
   *     The data to append. Strings are converted to a WordArray using UTF-8.
   *
   * @example
   *
   *     bufferedBlockAlgorithm._append('data');
   *     bufferedBlockAlgorithm._append(wordArray);
   */
  _append(data) {
    let m_data = data;
    if (typeof m_data === "string") {
      m_data = Utf8.parse(m_data);
    }
    this._data.concat(m_data);
    this._nDataBytes += m_data.sigBytes;
  }
  /**
   * Processes available data blocks.
   *
   * This method invokes _doProcessBlock(offset), which must be implemented by a concrete subtype.
   *
   * @param {boolean} doFlush Whether all blocks and partial blocks should be processed.
   *
   * @return {WordArray} The processed data.
   *
   * @example
   *
   *     var processedData = bufferedBlockAlgorithm._process();
   *     var processedData = bufferedBlockAlgorithm._process(!!'flush');
   */
  _process(doFlush) {
    let processedWords;
    const { _data: data, blockSize } = this;
    const dataWords = data.words;
    const dataSigBytes = data.sigBytes;
    const blockSizeBytes = blockSize * 4;
    let nBlocksReady = dataSigBytes / blockSizeBytes;
    if (doFlush) {
      nBlocksReady = Math.ceil(nBlocksReady);
    } else {
      nBlocksReady = Math.max((nBlocksReady | 0) - this._minBufferSize, 0);
    }
    const nWordsReady = nBlocksReady * blockSize;
    const nBytesReady = Math.min(nWordsReady * 4, dataSigBytes);
    if (nWordsReady) {
      for (let offset = 0; offset < nWordsReady; offset += blockSize) {
        this._doProcessBlock(dataWords, offset);
      }
      processedWords = dataWords.splice(0, nWordsReady);
      data.sigBytes -= nBytesReady;
    }
    return new WordArray(processedWords, nBytesReady);
  }
  /**
   * Creates a copy of this object.
   *
   * @return {Object} The clone.
   *
   * @example
   *
   *     var clone = bufferedBlockAlgorithm.clone();
   */
  clone() {
    const clone = super.clone.call(this);
    clone._data = this._data.clone();
    return clone;
  }
};
var Hasher = class extends BufferedBlockAlgorithm {
  constructor(cfg) {
    super();
    this.blockSize = 512 / 32;
    this.cfg = Object.assign(new Base(), cfg);
    this.reset();
  }
  /**
   * Creates a shortcut function to a hasher's object interface.
   *
   * @param {Hasher} SubHasher The hasher to create a helper for.
   *
   * @return {Function} The shortcut function.
   *
   * @static
   *
   * @example
   *
   *     var SHA256 = CryptoJS.lib.Hasher._createHelper(CryptoJS.algo.SHA256);
   */
  static _createHelper(SubHasher) {
    return (message, cfg) => new SubHasher(cfg).finalize(message);
  }
  /**
   * Creates a shortcut function to the HMAC's object interface.
   *
   * @param {Hasher} SubHasher The hasher to use in this HMAC helper.
   *
   * @return {Function} The shortcut function.
   *
   * @static
   *
   * @example
   *
   *     var HmacSHA256 = CryptoJS.lib.Hasher._createHmacHelper(CryptoJS.algo.SHA256);
   */
  static _createHmacHelper(SubHasher) {
    return (message, key) => new HMAC(SubHasher, key).finalize(message);
  }
  /**
   * Resets this hasher to its initial state.
   *
   * @example
   *
   *     hasher.reset();
   */
  reset() {
    super.reset.call(this);
    this._doReset();
  }
  /**
   * Updates this hasher with a message.
   *
   * @param {WordArray|string} messageUpdate The message to append.
   *
   * @return {Hasher} This hasher.
   *
   * @example
   *
   *     hasher.update('message');
   *     hasher.update(wordArray);
   */
  update(messageUpdate) {
    this._append(messageUpdate);
    this._process();
    return this;
  }
  /**
   * Finalizes the hash computation.
   * Note that the finalize operation is effectively a destructive, read-once operation.
   *
   * @param {WordArray|string} messageUpdate (Optional) A final message update.
   *
   * @return {WordArray} The hash.
   *
   * @example
   *
   *     var hash = hasher.finalize();
   *     var hash = hasher.finalize('message');
   *     var hash = hasher.finalize(wordArray);
   */
  finalize(messageUpdate) {
    if (messageUpdate) {
      this._append(messageUpdate);
    }
    const hash = this._doFinalize();
    return hash;
  }
};
var HMAC = class extends Base {
  /**
   * Initializes a newly created HMAC.
   *
   * @param {Hasher} SubHasher The hash algorithm to use.
   * @param {WordArray|string} key The secret key.
   *
   * @example
   *
   *     var hmacHasher = CryptoJS.algo.HMAC.create(CryptoJS.algo.SHA256, key);
   */
  constructor(SubHasher, key) {
    super();
    const hasher = new SubHasher();
    this._hasher = hasher;
    let _key = key;
    if (typeof _key === "string") {
      _key = Utf8.parse(_key);
    }
    const hasherBlockSize = hasher.blockSize;
    const hasherBlockSizeBytes = hasherBlockSize * 4;
    if (_key.sigBytes > hasherBlockSizeBytes) {
      _key = hasher.finalize(key);
    }
    _key.clamp();
    const oKey = _key.clone();
    this._oKey = oKey;
    const iKey = _key.clone();
    this._iKey = iKey;
    const oKeyWords = oKey.words;
    const iKeyWords = iKey.words;
    for (let i = 0; i < hasherBlockSize; i += 1) {
      oKeyWords[i] ^= 1549556828;
      iKeyWords[i] ^= 909522486;
    }
    oKey.sigBytes = hasherBlockSizeBytes;
    iKey.sigBytes = hasherBlockSizeBytes;
    this.reset();
  }
  /**
   * Resets this HMAC to its initial state.
   *
   * @example
   *
   *     hmacHasher.reset();
   */
  reset() {
    const hasher = this._hasher;
    hasher.reset();
    hasher.update(this._iKey);
  }
  /**
   * Updates this HMAC with a message.
   *
   * @param {WordArray|string} messageUpdate The message to append.
   *
   * @return {HMAC} This HMAC instance.
   *
   * @example
   *
   *     hmacHasher.update('message');
   *     hmacHasher.update(wordArray);
   */
  update(messageUpdate) {
    this._hasher.update(messageUpdate);
    return this;
  }
  /**
   * Finalizes the HMAC computation.
   * Note that the finalize operation is effectively a destructive, read-once operation.
   *
   * @param {WordArray|string} messageUpdate (Optional) A final message update.
   *
   * @return {WordArray} The HMAC.
   *
   * @example
   *
   *     var hmac = hmacHasher.finalize();
   *     var hmac = hmacHasher.finalize('message');
   *     var hmac = hmacHasher.finalize(wordArray);
   */
  finalize(messageUpdate) {
    const hasher = this._hasher;
    const innerHash = hasher.finalize(messageUpdate);
    hasher.reset();
    const hmac = hasher.finalize(this._oKey.clone().concat(innerHash));
    return hmac;
  }
};

// node_modules/crypto-es/lib/enc-base64.js
var parseLoop = (base64Str, base64StrLength, reverseMap) => {
  const words = [];
  let nBytes = 0;
  for (let i = 0; i < base64StrLength; i += 1) {
    if (i % 4) {
      const bits1 = reverseMap[base64Str.charCodeAt(i - 1)] << i % 4 * 2;
      const bits2 = reverseMap[base64Str.charCodeAt(i)] >>> 6 - i % 4 * 2;
      const bitsCombined = bits1 | bits2;
      words[nBytes >>> 2] |= bitsCombined << 24 - nBytes % 4 * 8;
      nBytes += 1;
    }
  }
  return WordArray.create(words, nBytes);
};
var Base64 = {
  /**
   * Converts a word array to a Base64 string.
   *
   * @param {WordArray} wordArray The word array.
   *
   * @return {string} The Base64 string.
   *
   * @static
   *
   * @example
   *
   *     const base64String = CryptoJS.enc.Base64.stringify(wordArray);
   */
  stringify(wordArray) {
    const { words, sigBytes } = wordArray;
    const map = this._map;
    wordArray.clamp();
    const base64Chars = [];
    for (let i = 0; i < sigBytes; i += 3) {
      const byte1 = words[i >>> 2] >>> 24 - i % 4 * 8 & 255;
      const byte2 = words[i + 1 >>> 2] >>> 24 - (i + 1) % 4 * 8 & 255;
      const byte3 = words[i + 2 >>> 2] >>> 24 - (i + 2) % 4 * 8 & 255;
      const triplet = byte1 << 16 | byte2 << 8 | byte3;
      for (let j = 0; j < 4 && i + j * 0.75 < sigBytes; j += 1) {
        base64Chars.push(map.charAt(triplet >>> 6 * (3 - j) & 63));
      }
    }
    const paddingChar = map.charAt(64);
    if (paddingChar) {
      while (base64Chars.length % 4) {
        base64Chars.push(paddingChar);
      }
    }
    return base64Chars.join("");
  },
  /**
   * Converts a Base64 string to a word array.
   *
   * @param {string} base64Str The Base64 string.
   *
   * @return {WordArray} The word array.
   *
   * @static
   *
   * @example
   *
   *     const wordArray = CryptoJS.enc.Base64.parse(base64String);
   */
  parse(base64Str) {
    let base64StrLength = base64Str.length;
    const map = this._map;
    let reverseMap = this._reverseMap;
    if (!reverseMap) {
      this._reverseMap = [];
      reverseMap = this._reverseMap;
      for (let j = 0; j < map.length; j += 1) {
        reverseMap[map.charCodeAt(j)] = j;
      }
    }
    const paddingChar = map.charAt(64);
    if (paddingChar) {
      const paddingIndex = base64Str.indexOf(paddingChar);
      if (paddingIndex !== -1) {
        base64StrLength = paddingIndex;
      }
    }
    return parseLoop(base64Str, base64StrLength, reverseMap);
  },
  _map: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/="
};

// node_modules/crypto-es/lib/md5.js
var T = [];
for (let i = 0; i < 64; i += 1) {
  T[i] = Math.abs(Math.sin(i + 1)) * 4294967296 | 0;
}
var FF = (a, b, c, d2, x2, s, t) => {
  const n = a + (b & c | ~b & d2) + x2 + t;
  return (n << s | n >>> 32 - s) + b;
};
var GG = (a, b, c, d2, x2, s, t) => {
  const n = a + (b & d2 | c & ~d2) + x2 + t;
  return (n << s | n >>> 32 - s) + b;
};
var HH = (a, b, c, d2, x2, s, t) => {
  const n = a + (b ^ c ^ d2) + x2 + t;
  return (n << s | n >>> 32 - s) + b;
};
var II = (a, b, c, d2, x2, s, t) => {
  const n = a + (c ^ (b | ~d2)) + x2 + t;
  return (n << s | n >>> 32 - s) + b;
};
var MD5Algo = class extends Hasher {
  _doReset() {
    this._hash = new WordArray([
      1732584193,
      4023233417,
      2562383102,
      271733878
    ]);
  }
  _doProcessBlock(M, offset) {
    const _M = M;
    for (let i = 0; i < 16; i += 1) {
      const offset_i = offset + i;
      const M_offset_i = M[offset_i];
      _M[offset_i] = (M_offset_i << 8 | M_offset_i >>> 24) & 16711935 | (M_offset_i << 24 | M_offset_i >>> 8) & 4278255360;
    }
    const H = this._hash.words;
    const M_offset_0 = _M[offset + 0];
    const M_offset_1 = _M[offset + 1];
    const M_offset_2 = _M[offset + 2];
    const M_offset_3 = _M[offset + 3];
    const M_offset_4 = _M[offset + 4];
    const M_offset_5 = _M[offset + 5];
    const M_offset_6 = _M[offset + 6];
    const M_offset_7 = _M[offset + 7];
    const M_offset_8 = _M[offset + 8];
    const M_offset_9 = _M[offset + 9];
    const M_offset_10 = _M[offset + 10];
    const M_offset_11 = _M[offset + 11];
    const M_offset_12 = _M[offset + 12];
    const M_offset_13 = _M[offset + 13];
    const M_offset_14 = _M[offset + 14];
    const M_offset_15 = _M[offset + 15];
    let a = H[0];
    let b = H[1];
    let c = H[2];
    let d2 = H[3];
    a = FF(a, b, c, d2, M_offset_0, 7, T[0]);
    d2 = FF(d2, a, b, c, M_offset_1, 12, T[1]);
    c = FF(c, d2, a, b, M_offset_2, 17, T[2]);
    b = FF(b, c, d2, a, M_offset_3, 22, T[3]);
    a = FF(a, b, c, d2, M_offset_4, 7, T[4]);
    d2 = FF(d2, a, b, c, M_offset_5, 12, T[5]);
    c = FF(c, d2, a, b, M_offset_6, 17, T[6]);
    b = FF(b, c, d2, a, M_offset_7, 22, T[7]);
    a = FF(a, b, c, d2, M_offset_8, 7, T[8]);
    d2 = FF(d2, a, b, c, M_offset_9, 12, T[9]);
    c = FF(c, d2, a, b, M_offset_10, 17, T[10]);
    b = FF(b, c, d2, a, M_offset_11, 22, T[11]);
    a = FF(a, b, c, d2, M_offset_12, 7, T[12]);
    d2 = FF(d2, a, b, c, M_offset_13, 12, T[13]);
    c = FF(c, d2, a, b, M_offset_14, 17, T[14]);
    b = FF(b, c, d2, a, M_offset_15, 22, T[15]);
    a = GG(a, b, c, d2, M_offset_1, 5, T[16]);
    d2 = GG(d2, a, b, c, M_offset_6, 9, T[17]);
    c = GG(c, d2, a, b, M_offset_11, 14, T[18]);
    b = GG(b, c, d2, a, M_offset_0, 20, T[19]);
    a = GG(a, b, c, d2, M_offset_5, 5, T[20]);
    d2 = GG(d2, a, b, c, M_offset_10, 9, T[21]);
    c = GG(c, d2, a, b, M_offset_15, 14, T[22]);
    b = GG(b, c, d2, a, M_offset_4, 20, T[23]);
    a = GG(a, b, c, d2, M_offset_9, 5, T[24]);
    d2 = GG(d2, a, b, c, M_offset_14, 9, T[25]);
    c = GG(c, d2, a, b, M_offset_3, 14, T[26]);
    b = GG(b, c, d2, a, M_offset_8, 20, T[27]);
    a = GG(a, b, c, d2, M_offset_13, 5, T[28]);
    d2 = GG(d2, a, b, c, M_offset_2, 9, T[29]);
    c = GG(c, d2, a, b, M_offset_7, 14, T[30]);
    b = GG(b, c, d2, a, M_offset_12, 20, T[31]);
    a = HH(a, b, c, d2, M_offset_5, 4, T[32]);
    d2 = HH(d2, a, b, c, M_offset_8, 11, T[33]);
    c = HH(c, d2, a, b, M_offset_11, 16, T[34]);
    b = HH(b, c, d2, a, M_offset_14, 23, T[35]);
    a = HH(a, b, c, d2, M_offset_1, 4, T[36]);
    d2 = HH(d2, a, b, c, M_offset_4, 11, T[37]);
    c = HH(c, d2, a, b, M_offset_7, 16, T[38]);
    b = HH(b, c, d2, a, M_offset_10, 23, T[39]);
    a = HH(a, b, c, d2, M_offset_13, 4, T[40]);
    d2 = HH(d2, a, b, c, M_offset_0, 11, T[41]);
    c = HH(c, d2, a, b, M_offset_3, 16, T[42]);
    b = HH(b, c, d2, a, M_offset_6, 23, T[43]);
    a = HH(a, b, c, d2, M_offset_9, 4, T[44]);
    d2 = HH(d2, a, b, c, M_offset_12, 11, T[45]);
    c = HH(c, d2, a, b, M_offset_15, 16, T[46]);
    b = HH(b, c, d2, a, M_offset_2, 23, T[47]);
    a = II(a, b, c, d2, M_offset_0, 6, T[48]);
    d2 = II(d2, a, b, c, M_offset_7, 10, T[49]);
    c = II(c, d2, a, b, M_offset_14, 15, T[50]);
    b = II(b, c, d2, a, M_offset_5, 21, T[51]);
    a = II(a, b, c, d2, M_offset_12, 6, T[52]);
    d2 = II(d2, a, b, c, M_offset_3, 10, T[53]);
    c = II(c, d2, a, b, M_offset_10, 15, T[54]);
    b = II(b, c, d2, a, M_offset_1, 21, T[55]);
    a = II(a, b, c, d2, M_offset_8, 6, T[56]);
    d2 = II(d2, a, b, c, M_offset_15, 10, T[57]);
    c = II(c, d2, a, b, M_offset_6, 15, T[58]);
    b = II(b, c, d2, a, M_offset_13, 21, T[59]);
    a = II(a, b, c, d2, M_offset_4, 6, T[60]);
    d2 = II(d2, a, b, c, M_offset_11, 10, T[61]);
    c = II(c, d2, a, b, M_offset_2, 15, T[62]);
    b = II(b, c, d2, a, M_offset_9, 21, T[63]);
    H[0] = H[0] + a | 0;
    H[1] = H[1] + b | 0;
    H[2] = H[2] + c | 0;
    H[3] = H[3] + d2 | 0;
  }
  /* eslint-ensable no-param-reassign */
  _doFinalize() {
    const data = this._data;
    const dataWords = data.words;
    const nBitsTotal = this._nDataBytes * 8;
    const nBitsLeft = data.sigBytes * 8;
    dataWords[nBitsLeft >>> 5] |= 128 << 24 - nBitsLeft % 32;
    const nBitsTotalH = Math.floor(nBitsTotal / 4294967296);
    const nBitsTotalL = nBitsTotal;
    dataWords[(nBitsLeft + 64 >>> 9 << 4) + 15] = (nBitsTotalH << 8 | nBitsTotalH >>> 24) & 16711935 | (nBitsTotalH << 24 | nBitsTotalH >>> 8) & 4278255360;
    dataWords[(nBitsLeft + 64 >>> 9 << 4) + 14] = (nBitsTotalL << 8 | nBitsTotalL >>> 24) & 16711935 | (nBitsTotalL << 24 | nBitsTotalL >>> 8) & 4278255360;
    data.sigBytes = (dataWords.length + 1) * 4;
    this._process();
    const hash = this._hash;
    const H = hash.words;
    for (let i = 0; i < 4; i += 1) {
      const H_i = H[i];
      H[i] = (H_i << 8 | H_i >>> 24) & 16711935 | (H_i << 24 | H_i >>> 8) & 4278255360;
    }
    return hash;
  }
  clone() {
    const clone = super.clone.call(this);
    clone._hash = this._hash.clone();
    return clone;
  }
};
var MD5 = Hasher._createHelper(MD5Algo);
var HmacMD5 = Hasher._createHmacHelper(MD5Algo);

// node_modules/crypto-es/lib/evpkdf.js
var EvpKDFAlgo = class extends Base {
  /**
   * Initializes a newly created key derivation function.
   *
   * @param {Object} cfg (Optional) The configuration options to use for the derivation.
   *
   * @example
   *
   *     const kdf = CryptoJS.algo.EvpKDF.create();
   *     const kdf = CryptoJS.algo.EvpKDF.create({ keySize: 8 });
   *     const kdf = CryptoJS.algo.EvpKDF.create({ keySize: 8, iterations: 1000 });
   */
  constructor(cfg) {
    super();
    this.cfg = Object.assign(
      new Base(),
      {
        keySize: 128 / 32,
        hasher: MD5Algo,
        iterations: 1
      },
      cfg
    );
  }
  /**
   * Derives a key from a password.
   *
   * @param {WordArray|string} password The password.
   * @param {WordArray|string} salt A salt.
   *
   * @return {WordArray} The derived key.
   *
   * @example
   *
   *     const key = kdf.compute(password, salt);
   */
  compute(password, salt) {
    let block;
    const { cfg } = this;
    const hasher = cfg.hasher.create();
    const derivedKey = WordArray.create();
    const derivedKeyWords = derivedKey.words;
    const { keySize, iterations } = cfg;
    while (derivedKeyWords.length < keySize) {
      if (block) {
        hasher.update(block);
      }
      block = hasher.update(password).finalize(salt);
      hasher.reset();
      for (let i = 1; i < iterations; i += 1) {
        block = hasher.finalize(block);
        hasher.reset();
      }
      derivedKey.concat(block);
    }
    derivedKey.sigBytes = keySize * 4;
    return derivedKey;
  }
};

// node_modules/crypto-es/lib/cipher-core.js
var Cipher = class extends BufferedBlockAlgorithm {
  /**
   * Initializes a newly created cipher.
   *
   * @param {number} xformMode Either the encryption or decryption transormation mode constant.
   * @param {WordArray} key The key.
   * @param {Object} cfg (Optional) The configuration options to use for this operation.
   *
   * @example
   *
   *     const cipher = CryptoJS.algo.AES.create(
   *       CryptoJS.algo.AES._ENC_XFORM_MODE, keyWordArray, { iv: ivWordArray }
   *     );
   */
  constructor(xformMode, key, cfg) {
    super();
    this.cfg = Object.assign(new Base(), cfg);
    this._xformMode = xformMode;
    this._key = key;
    this.reset();
  }
  /**
   * Creates this cipher in encryption mode.
   *
   * @param {WordArray} key The key.
   * @param {Object} cfg (Optional) The configuration options to use for this operation.
   *
   * @return {Cipher} A cipher instance.
   *
   * @static
   *
   * @example
   *
   *     const cipher = CryptoJS.algo.AES.createEncryptor(keyWordArray, { iv: ivWordArray });
   */
  static createEncryptor(key, cfg) {
    return this.create(this._ENC_XFORM_MODE, key, cfg);
  }
  /**
   * Creates this cipher in decryption mode.
   *
   * @param {WordArray} key The key.
   * @param {Object} cfg (Optional) The configuration options to use for this operation.
   *
   * @return {Cipher} A cipher instance.
   *
   * @static
   *
   * @example
   *
   *     const cipher = CryptoJS.algo.AES.createDecryptor(keyWordArray, { iv: ivWordArray });
   */
  static createDecryptor(key, cfg) {
    return this.create(this._DEC_XFORM_MODE, key, cfg);
  }
  /**
   * Creates shortcut functions to a cipher's object interface.
   *
   * @param {Cipher} cipher The cipher to create a helper for.
   *
   * @return {Object} An object with encrypt and decrypt shortcut functions.
   *
   * @static
   *
   * @example
   *
   *     const AES = CryptoJS.lib.Cipher._createHelper(CryptoJS.algo.AES);
   */
  static _createHelper(SubCipher) {
    const selectCipherStrategy = (key) => {
      if (typeof key === "string") {
        return PasswordBasedCipher;
      }
      return SerializableCipher;
    };
    return {
      encrypt(message, key, cfg) {
        return selectCipherStrategy(key).encrypt(SubCipher, message, key, cfg);
      },
      decrypt(ciphertext, key, cfg) {
        return selectCipherStrategy(key).decrypt(SubCipher, ciphertext, key, cfg);
      }
    };
  }
  /**
   * Resets this cipher to its initial state.
   *
   * @example
   *
   *     cipher.reset();
   */
  reset() {
    super.reset.call(this);
    this._doReset();
  }
  /**
   * Adds data to be encrypted or decrypted.
   *
   * @param {WordArray|string} dataUpdate The data to encrypt or decrypt.
   *
   * @return {WordArray} The data after processing.
   *
   * @example
   *
   *     const encrypted = cipher.process('data');
   *     const encrypted = cipher.process(wordArray);
   */
  process(dataUpdate) {
    this._append(dataUpdate);
    return this._process();
  }
  /**
   * Finalizes the encryption or decryption process.
   * Note that the finalize operation is effectively a destructive, read-once operation.
   *
   * @param {WordArray|string} dataUpdate The final data to encrypt or decrypt.
   *
   * @return {WordArray} The data after final processing.
   *
   * @example
   *
   *     const encrypted = cipher.finalize();
   *     const encrypted = cipher.finalize('data');
   *     const encrypted = cipher.finalize(wordArray);
   */
  finalize(dataUpdate) {
    if (dataUpdate) {
      this._append(dataUpdate);
    }
    const finalProcessedData = this._doFinalize();
    return finalProcessedData;
  }
};
Cipher._ENC_XFORM_MODE = 1;
Cipher._DEC_XFORM_MODE = 2;
Cipher.keySize = 128 / 32;
Cipher.ivSize = 128 / 32;
var BlockCipherMode = class extends Base {
  /**
   * Initializes a newly created mode.
   *
   * @param {Cipher} cipher A block cipher instance.
   * @param {Array} iv The IV words.
   *
   * @example
   *
   *     const mode = CryptoJS.mode.CBC.Encryptor.create(cipher, iv.words);
   */
  constructor(cipher, iv) {
    super();
    this._cipher = cipher;
    this._iv = iv;
  }
  /**
   * Creates this mode for encryption.
   *
   * @param {Cipher} cipher A block cipher instance.
   * @param {Array} iv The IV words.
   *
   * @static
   *
   * @example
   *
   *     const mode = CryptoJS.mode.CBC.createEncryptor(cipher, iv.words);
   */
  static createEncryptor(cipher, iv) {
    return this.Encryptor.create(cipher, iv);
  }
  /**
   * Creates this mode for decryption.
   *
   * @param {Cipher} cipher A block cipher instance.
   * @param {Array} iv The IV words.
   *
   * @static
   *
   * @example
   *
   *     const mode = CryptoJS.mode.CBC.createDecryptor(cipher, iv.words);
   */
  static createDecryptor(cipher, iv) {
    return this.Decryptor.create(cipher, iv);
  }
};
function xorBlock(words, offset, blockSize) {
  const _words = words;
  let block;
  const iv = this._iv;
  if (iv) {
    block = iv;
    this._iv = void 0;
  } else {
    block = this._prevBlock;
  }
  for (let i = 0; i < blockSize; i += 1) {
    _words[offset + i] ^= block[i];
  }
}
var CBC = class extends BlockCipherMode {
};
CBC.Encryptor = class extends CBC {
  /**
   * Processes the data block at offset.
   *
   * @param {Array} words The data words to operate on.
   * @param {number} offset The offset where the block starts.
   *
   * @example
   *
   *     mode.processBlock(data.words, offset);
   */
  processBlock(words, offset) {
    const cipher = this._cipher;
    const { blockSize } = cipher;
    xorBlock.call(this, words, offset, blockSize);
    cipher.encryptBlock(words, offset);
    this._prevBlock = words.slice(offset, offset + blockSize);
  }
};
CBC.Decryptor = class extends CBC {
  /**
   * Processes the data block at offset.
   *
   * @param {Array} words The data words to operate on.
   * @param {number} offset The offset where the block starts.
   *
   * @example
   *
   *     mode.processBlock(data.words, offset);
   */
  processBlock(words, offset) {
    const cipher = this._cipher;
    const { blockSize } = cipher;
    const thisBlock = words.slice(offset, offset + blockSize);
    cipher.decryptBlock(words, offset);
    xorBlock.call(this, words, offset, blockSize);
    this._prevBlock = thisBlock;
  }
};
var Pkcs7 = {
  /**
   * Pads data using the algorithm defined in PKCS #5/7.
   *
   * @param {WordArray} data The data to pad.
   * @param {number} blockSize The multiple that the data should be padded to.
   *
   * @static
   *
   * @example
   *
   *     CryptoJS.pad.Pkcs7.pad(wordArray, 4);
   */
  pad(data, blockSize) {
    const blockSizeBytes = blockSize * 4;
    const nPaddingBytes = blockSizeBytes - data.sigBytes % blockSizeBytes;
    const paddingWord = nPaddingBytes << 24 | nPaddingBytes << 16 | nPaddingBytes << 8 | nPaddingBytes;
    const paddingWords = [];
    for (let i = 0; i < nPaddingBytes; i += 4) {
      paddingWords.push(paddingWord);
    }
    const padding = WordArray.create(paddingWords, nPaddingBytes);
    data.concat(padding);
  },
  /**
   * Unpads data that had been padded using the algorithm defined in PKCS #5/7.
   *
   * @param {WordArray} data The data to unpad.
   *
   * @static
   *
   * @example
   *
   *     CryptoJS.pad.Pkcs7.unpad(wordArray);
   */
  unpad(data) {
    const _data = data;
    const nPaddingBytes = _data.words[_data.sigBytes - 1 >>> 2] & 255;
    _data.sigBytes -= nPaddingBytes;
  }
};
var BlockCipher = class extends Cipher {
  constructor(xformMode, key, cfg) {
    super(xformMode, key, Object.assign(
      {
        mode: CBC,
        padding: Pkcs7
      },
      cfg
    ));
    this.blockSize = 128 / 32;
  }
  reset() {
    let modeCreator;
    super.reset.call(this);
    const { cfg } = this;
    const { iv, mode } = cfg;
    if (this._xformMode === this.constructor._ENC_XFORM_MODE) {
      modeCreator = mode.createEncryptor;
    } else {
      modeCreator = mode.createDecryptor;
      this._minBufferSize = 1;
    }
    this._mode = modeCreator.call(mode, this, iv && iv.words);
    this._mode.__creator = modeCreator;
  }
  _doProcessBlock(words, offset) {
    this._mode.processBlock(words, offset);
  }
  _doFinalize() {
    let finalProcessedBlocks;
    const { padding } = this.cfg;
    if (this._xformMode === this.constructor._ENC_XFORM_MODE) {
      padding.pad(this._data, this.blockSize);
      finalProcessedBlocks = this._process(true);
    } else {
      finalProcessedBlocks = this._process(true);
      padding.unpad(finalProcessedBlocks);
    }
    return finalProcessedBlocks;
  }
};
var CipherParams = class extends Base {
  /**
   * Initializes a newly created cipher params object.
   *
   * @param {Object} cipherParams An object with any of the possible cipher parameters.
   *
   * @example
   *
   *     var cipherParams = CryptoJS.lib.CipherParams.create({
   *         ciphertext: ciphertextWordArray,
   *         key: keyWordArray,
   *         iv: ivWordArray,
   *         salt: saltWordArray,
   *         algorithm: CryptoJS.algo.AES,
   *         mode: CryptoJS.mode.CBC,
   *         padding: CryptoJS.pad.PKCS7,
   *         blockSize: 4,
   *         formatter: CryptoJS.format.OpenSSL
   *     });
   */
  constructor(cipherParams) {
    super();
    this.mixIn(cipherParams);
  }
  /**
   * Converts this cipher params object to a string.
   *
   * @param {Format} formatter (Optional) The formatting strategy to use.
   *
   * @return {string} The stringified cipher params.
   *
   * @throws Error If neither the formatter nor the default formatter is set.
   *
   * @example
   *
   *     var string = cipherParams + '';
   *     var string = cipherParams.toString();
   *     var string = cipherParams.toString(CryptoJS.format.OpenSSL);
   */
  toString(formatter) {
    return (formatter || this.formatter).stringify(this);
  }
};
var OpenSSLFormatter = {
  /**
   * Converts a cipher params object to an OpenSSL-compatible string.
   *
   * @param {CipherParams} cipherParams The cipher params object.
   *
   * @return {string} The OpenSSL-compatible string.
   *
   * @static
   *
   * @example
   *
   *     var openSSLString = CryptoJS.format.OpenSSL.stringify(cipherParams);
   */
  stringify(cipherParams) {
    let wordArray;
    const { ciphertext, salt } = cipherParams;
    if (salt) {
      wordArray = WordArray.create([1398893684, 1701076831]).concat(salt).concat(ciphertext);
    } else {
      wordArray = ciphertext;
    }
    return wordArray.toString(Base64);
  },
  /**
   * Converts an OpenSSL-compatible string to a cipher params object.
   *
   * @param {string} openSSLStr The OpenSSL-compatible string.
   *
   * @return {CipherParams} The cipher params object.
   *
   * @static
   *
   * @example
   *
   *     var cipherParams = CryptoJS.format.OpenSSL.parse(openSSLString);
   */
  parse(openSSLStr) {
    let salt;
    const ciphertext = Base64.parse(openSSLStr);
    const ciphertextWords = ciphertext.words;
    if (ciphertextWords[0] === 1398893684 && ciphertextWords[1] === 1701076831) {
      salt = WordArray.create(ciphertextWords.slice(2, 4));
      ciphertextWords.splice(0, 4);
      ciphertext.sigBytes -= 16;
    }
    return CipherParams.create({ ciphertext, salt });
  }
};
var SerializableCipher = class extends Base {
  /**
   * Encrypts a message.
   *
   * @param {Cipher} cipher The cipher algorithm to use.
   * @param {WordArray|string} message The message to encrypt.
   * @param {WordArray} key The key.
   * @param {Object} cfg (Optional) The configuration options to use for this operation.
   *
   * @return {CipherParams} A cipher params object.
   *
   * @static
   *
   * @example
   *
   *     var ciphertextParams = CryptoJS.lib.SerializableCipher
   *       .encrypt(CryptoJS.algo.AES, message, key);
   *     var ciphertextParams = CryptoJS.lib.SerializableCipher
   *       .encrypt(CryptoJS.algo.AES, message, key, { iv: iv });
   *     var ciphertextParams = CryptoJS.lib.SerializableCipher
   *       .encrypt(CryptoJS.algo.AES, message, key, { iv: iv, format: CryptoJS.format.OpenSSL });
   */
  static encrypt(cipher, message, key, cfg) {
    const _cfg = Object.assign(new Base(), this.cfg, cfg);
    const encryptor = cipher.createEncryptor(key, _cfg);
    const ciphertext = encryptor.finalize(message);
    const cipherCfg = encryptor.cfg;
    return CipherParams.create({
      ciphertext,
      key,
      iv: cipherCfg.iv,
      algorithm: cipher,
      mode: cipherCfg.mode,
      padding: cipherCfg.padding,
      blockSize: encryptor.blockSize,
      formatter: _cfg.format
    });
  }
  /**
   * Decrypts serialized ciphertext.
   *
   * @param {Cipher} cipher The cipher algorithm to use.
   * @param {CipherParams|string} ciphertext The ciphertext to decrypt.
   * @param {WordArray} key The key.
   * @param {Object} cfg (Optional) The configuration options to use for this operation.
   *
   * @return {WordArray} The plaintext.
   *
   * @static
   *
   * @example
   *
   *     var plaintext = CryptoJS.lib.SerializableCipher
   *       .decrypt(CryptoJS.algo.AES, formattedCiphertext, key,
   *         { iv: iv, format: CryptoJS.format.OpenSSL });
   *     var plaintext = CryptoJS.lib.SerializableCipher
   *       .decrypt(CryptoJS.algo.AES, ciphertextParams, key,
   *         { iv: iv, format: CryptoJS.format.OpenSSL });
   */
  static decrypt(cipher, ciphertext, key, cfg) {
    let _ciphertext = ciphertext;
    const _cfg = Object.assign(new Base(), this.cfg, cfg);
    _ciphertext = this._parse(_ciphertext, _cfg.format);
    const plaintext = cipher.createDecryptor(key, _cfg).finalize(_ciphertext.ciphertext);
    return plaintext;
  }
  /**
   * Converts serialized ciphertext to CipherParams,
   * else assumed CipherParams already and returns ciphertext unchanged.
   *
   * @param {CipherParams|string} ciphertext The ciphertext.
   * @param {Formatter} format The formatting strategy to use to parse serialized ciphertext.
   *
   * @return {CipherParams} The unserialized ciphertext.
   *
   * @static
   *
   * @example
   *
   *     var ciphertextParams = CryptoJS.lib.SerializableCipher
   *       ._parse(ciphertextStringOrParams, format);
   */
  static _parse(ciphertext, format) {
    if (typeof ciphertext === "string") {
      return format.parse(ciphertext, this);
    }
    return ciphertext;
  }
};
SerializableCipher.cfg = Object.assign(
  new Base(),
  { format: OpenSSLFormatter }
);
var OpenSSLKdf = {
  /**
   * Derives a key and IV from a password.
   *
   * @param {string} password The password to derive from.
   * @param {number} keySize The size in words of the key to generate.
   * @param {number} ivSize The size in words of the IV to generate.
   * @param {WordArray|string} salt
   *     (Optional) A 64-bit salt to use. If omitted, a salt will be generated randomly.
   *
   * @return {CipherParams} A cipher params object with the key, IV, and salt.
   *
   * @static
   *
   * @example
   *
   *     var derivedParams = CryptoJS.kdf.OpenSSL.execute('Password', 256/32, 128/32);
   *     var derivedParams = CryptoJS.kdf.OpenSSL.execute('Password', 256/32, 128/32, 'saltsalt');
   */
  execute(password, keySize, ivSize, salt) {
    let _salt = salt;
    if (!_salt) {
      _salt = WordArray.random(64 / 8);
    }
    const key = EvpKDFAlgo.create({ keySize: keySize + ivSize }).compute(password, _salt);
    const iv = WordArray.create(key.words.slice(keySize), ivSize * 4);
    key.sigBytes = keySize * 4;
    return CipherParams.create({ key, iv, salt: _salt });
  }
};
var PasswordBasedCipher = class extends SerializableCipher {
  /**
   * Encrypts a message using a password.
   *
   * @param {Cipher} cipher The cipher algorithm to use.
   * @param {WordArray|string} message The message to encrypt.
   * @param {string} password The password.
   * @param {Object} cfg (Optional) The configuration options to use for this operation.
   *
   * @return {CipherParams} A cipher params object.
   *
   * @static
   *
   * @example
   *
   *     var ciphertextParams = CryptoJS.lib.PasswordBasedCipher
   *       .encrypt(CryptoJS.algo.AES, message, 'password');
   *     var ciphertextParams = CryptoJS.lib.PasswordBasedCipher
   *       .encrypt(CryptoJS.algo.AES, message, 'password', { format: CryptoJS.format.OpenSSL });
   */
  static encrypt(cipher, message, password, cfg) {
    const _cfg = Object.assign(new Base(), this.cfg, cfg);
    const derivedParams = _cfg.kdf.execute(password, cipher.keySize, cipher.ivSize);
    _cfg.iv = derivedParams.iv;
    const ciphertext = SerializableCipher.encrypt.call(this, cipher, message, derivedParams.key, _cfg);
    ciphertext.mixIn(derivedParams);
    return ciphertext;
  }
  /**
   * Decrypts serialized ciphertext using a password.
   *
   * @param {Cipher} cipher The cipher algorithm to use.
   * @param {CipherParams|string} ciphertext The ciphertext to decrypt.
   * @param {string} password The password.
   * @param {Object} cfg (Optional) The configuration options to use for this operation.
   *
   * @return {WordArray} The plaintext.
   *
   * @static
   *
   * @example
   *
   *     var plaintext = CryptoJS.lib.PasswordBasedCipher
   *       .decrypt(CryptoJS.algo.AES, formattedCiphertext, 'password',
   *         { format: CryptoJS.format.OpenSSL });
   *     var plaintext = CryptoJS.lib.PasswordBasedCipher
   *       .decrypt(CryptoJS.algo.AES, ciphertextParams, 'password',
   *         { format: CryptoJS.format.OpenSSL });
   */
  static decrypt(cipher, ciphertext, password, cfg) {
    let _ciphertext = ciphertext;
    const _cfg = Object.assign(new Base(), this.cfg, cfg);
    _ciphertext = this._parse(_ciphertext, _cfg.format);
    const derivedParams = _cfg.kdf.execute(password, cipher.keySize, cipher.ivSize, _ciphertext.salt);
    _cfg.iv = derivedParams.iv;
    const plaintext = SerializableCipher.decrypt.call(this, cipher, _ciphertext, derivedParams.key, _cfg);
    return plaintext;
  }
};
PasswordBasedCipher.cfg = Object.assign(SerializableCipher.cfg, { kdf: OpenSSLKdf });

// node_modules/crypto-es/lib/aes.js
var _SBOX = [];
var INV_SBOX = [];
var _SUB_MIX_0 = [];
var _SUB_MIX_1 = [];
var _SUB_MIX_2 = [];
var _SUB_MIX_3 = [];
var INV_SUB_MIX_0 = [];
var INV_SUB_MIX_1 = [];
var INV_SUB_MIX_2 = [];
var INV_SUB_MIX_3 = [];
var d = [];
for (let i = 0; i < 256; i += 1) {
  if (i < 128) {
    d[i] = i << 1;
  } else {
    d[i] = i << 1 ^ 283;
  }
}
var x = 0;
var xi = 0;
for (let i = 0; i < 256; i += 1) {
  let sx = xi ^ xi << 1 ^ xi << 2 ^ xi << 3 ^ xi << 4;
  sx = sx >>> 8 ^ sx & 255 ^ 99;
  _SBOX[x] = sx;
  INV_SBOX[sx] = x;
  const x2 = d[x];
  const x4 = d[x2];
  const x8 = d[x4];
  let t = d[sx] * 257 ^ sx * 16843008;
  _SUB_MIX_0[x] = t << 24 | t >>> 8;
  _SUB_MIX_1[x] = t << 16 | t >>> 16;
  _SUB_MIX_2[x] = t << 8 | t >>> 24;
  _SUB_MIX_3[x] = t;
  t = x8 * 16843009 ^ x4 * 65537 ^ x2 * 257 ^ x * 16843008;
  INV_SUB_MIX_0[sx] = t << 24 | t >>> 8;
  INV_SUB_MIX_1[sx] = t << 16 | t >>> 16;
  INV_SUB_MIX_2[sx] = t << 8 | t >>> 24;
  INV_SUB_MIX_3[sx] = t;
  if (!x) {
    xi = 1;
    x = xi;
  } else {
    x = x2 ^ d[d[d[x8 ^ x2]]];
    xi ^= d[d[xi]];
  }
}
var RCON = [0, 1, 2, 4, 8, 16, 32, 64, 128, 27, 54];
var AESAlgo = class extends BlockCipher {
  _doReset() {
    let t;
    if (this._nRounds && this._keyPriorReset === this._key) {
      return;
    }
    this._keyPriorReset = this._key;
    const key = this._keyPriorReset;
    const keyWords = key.words;
    const keySize = key.sigBytes / 4;
    this._nRounds = keySize + 6;
    const nRounds = this._nRounds;
    const ksRows = (nRounds + 1) * 4;
    this._keySchedule = [];
    const keySchedule = this._keySchedule;
    for (let ksRow = 0; ksRow < ksRows; ksRow += 1) {
      if (ksRow < keySize) {
        keySchedule[ksRow] = keyWords[ksRow];
      } else {
        t = keySchedule[ksRow - 1];
        if (!(ksRow % keySize)) {
          t = t << 8 | t >>> 24;
          t = _SBOX[t >>> 24] << 24 | _SBOX[t >>> 16 & 255] << 16 | _SBOX[t >>> 8 & 255] << 8 | _SBOX[t & 255];
          t ^= RCON[ksRow / keySize | 0] << 24;
        } else if (keySize > 6 && ksRow % keySize === 4) {
          t = _SBOX[t >>> 24] << 24 | _SBOX[t >>> 16 & 255] << 16 | _SBOX[t >>> 8 & 255] << 8 | _SBOX[t & 255];
        }
        keySchedule[ksRow] = keySchedule[ksRow - keySize] ^ t;
      }
    }
    this._invKeySchedule = [];
    const invKeySchedule = this._invKeySchedule;
    for (let invKsRow = 0; invKsRow < ksRows; invKsRow += 1) {
      const ksRow = ksRows - invKsRow;
      if (invKsRow % 4) {
        t = keySchedule[ksRow];
      } else {
        t = keySchedule[ksRow - 4];
      }
      if (invKsRow < 4 || ksRow <= 4) {
        invKeySchedule[invKsRow] = t;
      } else {
        invKeySchedule[invKsRow] = INV_SUB_MIX_0[_SBOX[t >>> 24]] ^ INV_SUB_MIX_1[_SBOX[t >>> 16 & 255]] ^ INV_SUB_MIX_2[_SBOX[t >>> 8 & 255]] ^ INV_SUB_MIX_3[_SBOX[t & 255]];
      }
    }
  }
  encryptBlock(M, offset) {
    this._doCryptBlock(
      M,
      offset,
      this._keySchedule,
      _SUB_MIX_0,
      _SUB_MIX_1,
      _SUB_MIX_2,
      _SUB_MIX_3,
      _SBOX
    );
  }
  decryptBlock(M, offset) {
    const _M = M;
    let t = _M[offset + 1];
    _M[offset + 1] = _M[offset + 3];
    _M[offset + 3] = t;
    this._doCryptBlock(
      _M,
      offset,
      this._invKeySchedule,
      INV_SUB_MIX_0,
      INV_SUB_MIX_1,
      INV_SUB_MIX_2,
      INV_SUB_MIX_3,
      INV_SBOX
    );
    t = _M[offset + 1];
    _M[offset + 1] = _M[offset + 3];
    _M[offset + 3] = t;
  }
  _doCryptBlock(M, offset, keySchedule, SUB_MIX_0, SUB_MIX_1, SUB_MIX_2, SUB_MIX_3, SBOX) {
    const _M = M;
    const nRounds = this._nRounds;
    let s0 = _M[offset] ^ keySchedule[0];
    let s1 = _M[offset + 1] ^ keySchedule[1];
    let s2 = _M[offset + 2] ^ keySchedule[2];
    let s3 = _M[offset + 3] ^ keySchedule[3];
    let ksRow = 4;
    for (let round = 1; round < nRounds; round += 1) {
      const t02 = SUB_MIX_0[s0 >>> 24] ^ SUB_MIX_1[s1 >>> 16 & 255] ^ SUB_MIX_2[s2 >>> 8 & 255] ^ SUB_MIX_3[s3 & 255] ^ keySchedule[ksRow];
      ksRow += 1;
      const t12 = SUB_MIX_0[s1 >>> 24] ^ SUB_MIX_1[s2 >>> 16 & 255] ^ SUB_MIX_2[s3 >>> 8 & 255] ^ SUB_MIX_3[s0 & 255] ^ keySchedule[ksRow];
      ksRow += 1;
      const t22 = SUB_MIX_0[s2 >>> 24] ^ SUB_MIX_1[s3 >>> 16 & 255] ^ SUB_MIX_2[s0 >>> 8 & 255] ^ SUB_MIX_3[s1 & 255] ^ keySchedule[ksRow];
      ksRow += 1;
      const t32 = SUB_MIX_0[s3 >>> 24] ^ SUB_MIX_1[s0 >>> 16 & 255] ^ SUB_MIX_2[s1 >>> 8 & 255] ^ SUB_MIX_3[s2 & 255] ^ keySchedule[ksRow];
      ksRow += 1;
      s0 = t02;
      s1 = t12;
      s2 = t22;
      s3 = t32;
    }
    const t0 = (SBOX[s0 >>> 24] << 24 | SBOX[s1 >>> 16 & 255] << 16 | SBOX[s2 >>> 8 & 255] << 8 | SBOX[s3 & 255]) ^ keySchedule[ksRow];
    ksRow += 1;
    const t1 = (SBOX[s1 >>> 24] << 24 | SBOX[s2 >>> 16 & 255] << 16 | SBOX[s3 >>> 8 & 255] << 8 | SBOX[s0 & 255]) ^ keySchedule[ksRow];
    ksRow += 1;
    const t2 = (SBOX[s2 >>> 24] << 24 | SBOX[s3 >>> 16 & 255] << 16 | SBOX[s0 >>> 8 & 255] << 8 | SBOX[s1 & 255]) ^ keySchedule[ksRow];
    ksRow += 1;
    const t3 = (SBOX[s3 >>> 24] << 24 | SBOX[s0 >>> 16 & 255] << 16 | SBOX[s1 >>> 8 & 255] << 8 | SBOX[s2 & 255]) ^ keySchedule[ksRow];
    ksRow += 1;
    _M[offset] = t0;
    _M[offset + 1] = t1;
    _M[offset + 2] = t2;
    _M[offset + 3] = t3;
  }
};
AESAlgo.keySize = 256 / 32;
var AES = BlockCipher._createHelper(AESAlgo);

// node_modules/crypto-es/lib/mode-ctr.js
var CTR = class extends BlockCipherMode {
};
CTR.Encryptor = class extends CTR {
  processBlock(words, offset) {
    const _words = words;
    const cipher = this._cipher;
    const { blockSize } = cipher;
    const iv = this._iv;
    let counter = this._counter;
    if (iv) {
      this._counter = iv.slice(0);
      counter = this._counter;
      this._iv = void 0;
    }
    const keystream = counter.slice(0);
    cipher.encryptBlock(keystream, 0);
    counter[blockSize - 1] = counter[blockSize - 1] + 1 | 0;
    for (let i = 0; i < blockSize; i += 1) {
      _words[offset + i] ^= keystream[i];
    }
  }
};
CTR.Decryptor = CTR.Encryptor;

// node_modules/crypto-es/lib/pad-nopadding.js
var NoPadding = {
  pad() {
  },
  unpad() {
  }
};

// node_modules/xgplayer-transmuxer/es/mp4/crypto/crypto.js
var Crypto = {
  decryptWordArray: function decryptWordArray(raw, key, iv) {
    var realKey = Hex.parse(key);
    var realIV = Hex.parse(formatIV(iv));
    var message = WordArray.create(new Uint8Array(raw));
    var decryptWord = AES.decrypt(CipherParams.create({
      ciphertext: message
    }), realKey, {
      iv: realIV,
      mode: CTR,
      padding: NoPadding
    });
    return Crypto.wordArrayToUint8Array(decryptWord);
  },
  wordArrayToUint8Array: function wordArrayToUint8Array(wordArray) {
    var l = wordArray.sigBytes;
    var words = wordArray.words;
    var result = new Uint8Array(l);
    var i = 0;
    var j = 0;
    while (true) {
      if (i === l) {
        break;
      }
      var w = words[j++];
      result[i++] = (w & 4278190080) >>> 24;
      if (i === l) {
        break;
      }
      result[i++] = (w & 16711680) >>> 16;
      if (i === l) {
        break;
      }
      result[i++] = (w & 65280) >>> 8;
      if (i === l) {
        break;
      }
      result[i++] = w & 255;
    }
    return result;
  },
  decoderAESCTRData: function decoderAESCTRData(videoTrack, audioTrack, customDescryptHandler) {
    if (videoTrack.videoSenc) {
      var key = videoTrack.kidValue;
      var senc = videoTrack.videoSenc;
      videoTrack.samples.forEach(function(item, index) {
        var sencBox = senc[index];
        var encodeWord = item.data;
        var encodeBuffers = [];
        var decodeBuffers = [];
        var iv = sencBox.InitializationVector;
        if (sencBox.subsamples && sencBox.subsamples.length) {
          sencBox.subsamples.forEach(function(value) {
            var len2 = value.BytesOfClearData + value.BytesOfProtectedData;
            var sampleData = encodeWord.slice(0, len2);
            encodeBuffers.push(sampleData.slice(0, value.BytesOfClearData));
            decodeBuffers.push(sampleData.slice(value.BytesOfClearData));
            encodeWord = encodeWord.slice(len2);
          });
        } else {
          var len = item.size;
          encodeBuffers.push(encodeWord.slice(0, 0));
          decodeBuffers.push(encodeWord.slice(0, len));
          encodeWord = encodeWord.slice(len);
        }
        var tempBuffer = new Buffer();
        tempBuffer.write.apply(tempBuffer, decodeBuffers);
        var decrypted = customDescryptHandler ? customDescryptHandler(tempBuffer.buffer, key, iv) : Crypto.decryptWordArray(tempBuffer.buffer, key, iv);
        var buffer = new Buffer();
        encodeBuffers.forEach(function(clearDataBuf, i) {
          var protectedDataLen = decodeBuffers[i].length;
          var decodeProtectedData = decrypted.slice(0, protectedDataLen);
          buffer.write(clearDataBuf);
          buffer.write(decodeProtectedData);
          decrypted = decrypted.slice(protectedDataLen);
        });
        videoTrack.samples[index].data = buffer.buffer;
      });
    }
    if (audioTrack.audioSenc) {
      var _key = audioTrack.kidValue;
      var _senc = audioTrack.audioSenc;
      audioTrack.samples.forEach(function(item, index) {
        var sencBox = _senc[index];
        var dec = customDescryptHandler ? customDescryptHandler(item.data, _key, sencBox.InitializationVector) : Crypto.decryptWordArray(item.data, _key, sencBox.InitializationVector);
        audioTrack.samples[index].data = dec;
      });
    }
  }
};

// node_modules/xgplayer-transmuxer/es/mp4/mp4-demuxer.js
var NEW_ARRAY_MAX_CNT = 20;
var MP4Demuxer = function() {
  function MP4Demuxer2(videoSegmnents, audioSegmnents, metadataTrack, options) {
    var _this = this;
    _classCallCheck2(this, MP4Demuxer2);
    _defineProperty2(this, "_videoSamples", []);
    _defineProperty2(this, "_audioSamples", []);
    _defineProperty2(this, "_lastRemainBuffer", []);
    _defineProperty2(this, "_lastRemainBufferStartPos", 0);
    this.videoTrack = new VideoTrack();
    this.audioTrack = new AudioTrack();
    this.metadataTrack = metadataTrack || new MetadataTrack();
    this.log = new Logger2("MP4Demuxer", options && options.openLog ? !options.openLog : true);
    videoSegmnents && videoSegmnents.forEach(function(item) {
      var _this$_videoSamples;
      (_this$_videoSamples = _this._videoSamples).push.apply(_this$_videoSamples, _toConsumableArray(item.frames));
    });
    audioSegmnents && audioSegmnents.forEach(function(item) {
      var _this$_audioSamples;
      (_this$_audioSamples = _this._audioSamples).push.apply(_this$_audioSamples, _toConsumableArray(item.frames));
    });
  }
  _createClass2(MP4Demuxer2, [{
    key: "parseSamples",
    value: function parseSamples(moov) {
      if (!moov) {
        throw new Error("moov is required");
      }
      if (!this.videoTrack.codec && !this.audioTrack.codec) {
        MP4Parser.moovToTrack(moov, this.videoTrack, this.audioTrack);
        this.videoSenc = this.videoTrack.videoSenc;
        this.audioSenc = this.audioTrack.audioSenc;
      }
      if (!this._audioSamples.length && !this._videoSamples.length) {
        var ret = MP4Parser.moovToSamples(moov);
        if (!ret)
          throw new Error("cannot parse samples from moov box");
        this._videoSamples = ret.videoSamples || [];
        this._audioSamples = ret.audioSamples || [];
      }
    }
  }, {
    key: "demux",
    value: function demux(data, dataStart, videoIndexRange, audioIndexRange, moov) {
      this.parseSamples(moov);
      var videoTrack = this.videoTrack;
      var audioTrack = this.audioTrack;
      videoTrack.samples = [];
      audioTrack.samples = [];
      var sample;
      var sampleData;
      var startByte;
      if (videoIndexRange) {
        var frame;
        var nalSize = 0;
        for (var i = videoIndexRange[0], l = videoIndexRange[1]; i <= l; i++) {
          sample = this._videoSamples[i];
          if (!sample) {
            throw new Error("cannot found video frame #".concat(i));
          }
          startByte = sample.offset - dataStart;
          sampleData = data.subarray(startByte, startByte + sample.size);
          frame = new VideoSample(sample.pts || sample.dts, sample.dts);
          frame.duration = sample.duration;
          frame.gopId = sample.gopId;
          if (sample.keyframe)
            frame.setToKeyframe();
          var start = 0;
          var len = sampleData.length - 1;
          while (start < len) {
            nalSize = readBig32(sampleData, start);
            start += 4;
            frame.units.push(sampleData.subarray(start, start + nalSize));
            start += nalSize;
          }
          videoTrack.samples.push(frame);
        }
        videoTrack.baseMediaDecodeTime = videoTrack.samples[0].dts;
      }
      if (audioIndexRange) {
        for (var _i = audioIndexRange[0], _l = audioIndexRange[1]; _i <= _l; _i++) {
          sample = this._audioSamples[_i];
          if (!sample) {
            throw new Error("cannot found video frame #".concat(_i));
          }
          startByte = sample.offset - dataStart;
          sampleData = data.subarray(startByte, startByte + sample.size);
          audioTrack.samples.push(new AudioSample(sample.dts, sampleData, sample.duration));
        }
        audioTrack.baseMediaDecodeTime = audioTrack.samples[0].dts;
      }
      return {
        videoTrack,
        audioTrack,
        metadataTrack: this.metadataTrack
      };
    }
  }, {
    key: "demuxPart",
    value: function demuxPart(data, dataStart, videoIndexRange, audioIndexRange, moov, useEME, kidValue, customDescryptHandler) {
      this.parseSamples(moov);
      this.videoTrack.useEME = useEME;
      this.audioTrack.useEME = useEME;
      if (this._lastRemainBuffer && this._lastRemainBuffer.byteLength > 0 && dataStart > this._lastRemainBufferStartPos && dataStart <= this._lastRemainBufferStartPos + this._lastRemainBuffer.byteLength) {
        var tryCnt = 0;
        while (tryCnt < NEW_ARRAY_MAX_CNT) {
          try {
            var buffer = this._lastRemainBuffer.subarray(0, dataStart - this._lastRemainBufferStartPos);
            var temp = new Uint8Array(data.byteLength + buffer.byteLength);
            temp.set(buffer, 0);
            temp.set(new Uint8Array(data), buffer.byteLength);
            data = temp;
            dataStart -= buffer.byteLength;
            this._lastRemainBuffer = null;
            this._lastRemainBufferStartPos = 0;
            break;
          } catch (e) {
            if (tryCnt < NEW_ARRAY_MAX_CNT) {
              tryCnt++;
            } else {
              throw new Error("new Uint8Array error:," + e.errorMessage);
            }
          }
        }
      }
      var videoTrack = this.videoTrack;
      var audioTrack = this.audioTrack;
      videoTrack.samples = [];
      audioTrack.samples = [];
      videoTrack.videoSenc = null;
      audioTrack.audioSenc = null;
      var sample;
      var sampleData;
      var startByte;
      var videoEndByte = 0;
      var audioEndByte = 0;
      if (this._videoSamples.length > 0 && videoIndexRange.length > 0) {
        var frame;
        var end = data.byteLength + dataStart;
        for (var i = videoIndexRange[0]; i <= videoIndexRange[1]; i++) {
          sample = this._videoSamples[i];
          if (!sample) {
            throw new Error("cannot found video frame #".concat(i));
          }
          if (sample.offset >= dataStart && sample.offset + sample.size <= end) {
            startByte = sample.offset - dataStart;
            videoEndByte = startByte + sample.size;
            sampleData = data.subarray(startByte, videoEndByte);
            frame = new VideoSample(sample.pts || sample.dts, sample.dts);
            frame.duration = sample.duration;
            frame.gopId = sample.gopId;
            frame.sampleOffset = sample.index;
            if (sample.keyframe)
              frame.setToKeyframe();
            frame.data = sampleData;
            frame.size = sample.size;
            videoTrack.samples.push(frame);
          }
        }
        if (videoTrack.samples.length > 0) {
          videoTrack.gopId = videoTrack.samples[0].gopId;
          videoTrack.baseMediaDecodeTime = videoTrack.samples[0].dts;
          videoTrack.startPts = videoTrack.samples[0].pts / videoTrack.timescale;
          videoTrack.endPts = videoTrack.samples[videoTrack.samples.length - 1].pts / videoTrack.timescale;
          if (this.videoSenc) {
            videoTrack.videoSenc = this.videoSenc.slice(videoTrack.samples[0].sampleOffset, videoTrack.samples[0].sampleOffset + videoTrack.samples.length);
            videoTrack.kidValue = kidValue;
          }
        }
      }
      if (this._audioSamples.length > 0 && audioIndexRange.length > 0) {
        for (var _i2 = audioIndexRange[0]; _i2 <= audioIndexRange[1]; _i2++) {
          sample = this._audioSamples[_i2];
          if (!sample) {
            throw new Error("cannot found video frame #".concat(_i2));
          }
          if (sample.offset >= dataStart && sample.offset + sample.size <= data.byteLength + dataStart) {
            startByte = sample.offset - dataStart;
            audioEndByte = startByte + sample.size;
            sampleData = data.subarray(startByte, audioEndByte);
            audioTrack.samples.push(new AudioSample(sample.dts, sampleData, sample.duration, sample.index));
          }
        }
        if (audioTrack.samples.length > 0) {
          audioTrack.gopId = audioTrack.samples[0].gopId || videoTrack.gopId;
          audioTrack.baseMediaDecodeTime = audioTrack.samples[0].dts;
          audioTrack.startPts = audioTrack.samples[0].pts / audioTrack.timescale;
          audioTrack.endPts = audioTrack.samples[audioTrack.samples.length - 1].pts / audioTrack.timescale;
          if (this.audioSenc) {
            audioTrack.audioSenc = this.audioSenc.slice(audioTrack.samples[0].sampleOffset, audioTrack.samples[0].sampleOffset + audioTrack.samples.length);
            audioTrack.kidValue = kidValue;
          }
        }
      }
      this.decoderData(videoTrack, audioTrack, customDescryptHandler);
      var nalSize = 0;
      for (var _i3 = 0; _i3 < videoTrack.samples.length; _i3++) {
        var start = 0;
        var _sampleData = videoTrack.samples[_i3].data;
        var len = _sampleData.length - 1;
        while (start < len) {
          nalSize = readBig32(_sampleData, start);
          start += 4;
          videoTrack.samples[_i3].units.push(_sampleData.subarray(start, start + nalSize));
          start += nalSize;
        }
      }
      this._lastRemainBuffer = data.subarray(Math.max(videoEndByte, audioEndByte));
      if (this._lastRemainBuffer.byteLength > 0) {
        this._lastRemainBufferStartPos = dataStart + data.byteLength - this._lastRemainBuffer.byteLength;
      } else {
        this._lastRemainBufferStartPos = 0;
      }
      return {
        videoTrack,
        audioTrack,
        metadataTrack: this.metadataTrack
      };
    }
  }, {
    key: "reset",
    value: function reset() {
      this._videoSamples = [];
      this._audioSamples = [];
      this._lastRemainBuffer = null;
      this._lastRemainBufferStartPos = 0;
      this.videoTrack.reset();
      this.audioTrack.reset();
      this.metadataTrack.reset();
    }
  }, {
    key: "decoderData",
    value: function decoderData(videoTrack, audioTrack, customDescryptHandler) {
      if (videoTrack.useEME || audioTrack.useEME)
        return;
      Crypto.decoderAESCTRData(videoTrack, audioTrack, customDescryptHandler);
    }
  }], [{
    key: "probe",
    value: function probe(data) {
      return MP4Parser.probe(data);
    }
  }]);
  return MP4Demuxer2;
}();

// node_modules/xgplayer-transmuxer/es/mp4/mp4-remuxer.js
var MP4Remuxer = function() {
  function MP4Remuxer2(videoTrack, audioTrack) {
    _classCallCheck2(this, MP4Remuxer2);
    this.videoTrack = videoTrack;
    this.audioTrack = audioTrack;
  }
  _createClass2(MP4Remuxer2, [{
    key: "remux",
    value: function remux(videoTrack, audioTrack) {
      this.videoTrack = videoTrack || this.videoTrack;
      this.audioTrack = audioTrack || this.audioTrack;
      var hasVideo = (videoTrack === null || videoTrack === void 0 ? void 0 : videoTrack.exist()) && (videoTrack === null || videoTrack === void 0 ? void 0 : videoTrack.hasSample());
      var hasAudio = (audioTrack === null || audioTrack === void 0 ? void 0 : audioTrack.exist()) && (audioTrack === null || audioTrack === void 0 ? void 0 : audioTrack.hasSample());
      var videoSegment;
      var audioSegment;
      if (hasVideo && hasAudio) {
        videoSegment = this._remuxMix(videoTrack, audioTrack);
      } else if (hasVideo) {
        videoSegment = this._remuxTrack(videoTrack);
      } else if (hasAudio) {
        audioSegment = this._remuxTrack(audioTrack);
      }
      if (videoTrack) {
        videoTrack.samples = [];
      }
      if (audioTrack) {
        audioTrack.samples = [];
      }
      return {
        videoSegment,
        audioSegment
      };
    }
  }, {
    key: "_remuxMix",
    value: function _remuxMix(videoTrack, audioTrack) {
      var ftyp = MP4.ftyp([videoTrack, audioTrack]);
      var _this$_remuxData = this._remuxData(videoTrack, ftyp.byteLength + 8), video = _this$_remuxData.mdatData, chunkOffset = _this$_remuxData.chunkOffset;
      var _this$_remuxData2 = this._remuxData(audioTrack, chunkOffset), audio = _this$_remuxData2.mdatData;
      var mdat = MP4.mdat(concatUint8Array(video, audio));
      var moov = MP4.moovMP4([videoTrack, audioTrack]);
      videoTrack.ext = void 0;
      audioTrack.ext = void 0;
      videoTrack.samples = [];
      audioTrack.samples = [];
      return concatUint8Array(ftyp, mdat, moov);
    }
  }, {
    key: "_remuxTrack",
    value: function _remuxTrack(track) {
      var ftyp = MP4.ftyp([track]);
      var _this$_remuxData3 = this._remuxData(track, ftyp.byteLength + 8), mdatData = _this$_remuxData3.mdatData;
      var mdat = MP4.mdat(mdatData);
      var moov = MP4.moovMP4([track]);
      track.ext = void 0;
      track.samples = [];
      return concatUint8Array(ftyp, mdat, moov);
    }
  }, {
    key: "_remuxData",
    value: function _remuxData(track, chunkOffset) {
      var _this = this;
      var isVideo = track.type === TrackType.VIDEO;
      var samples = track.samples;
      var mdatSize = 0;
      if (isVideo) {
        samples.forEach(function(s) {
          mdatSize += s.units.reduce(function(t, c) {
            return t + c.byteLength;
          }, 0);
          mdatSize += s.units.length * 4;
        });
      } else {
        mdatSize = samples.reduce(function(t, c) {
          return t + c.size;
        }, 0);
      }
      var mdatData = new Uint8Array(mdatSize);
      var mdatView = new DataView(mdatData.buffer);
      var ext = track.ext = {
        stts: [],
        stsc: [],
        stsz: [],
        stco: [],
        stss: [],
        ctts: []
      };
      var samplesPerChunk = 1;
      var dataOffset = 0;
      var totalDuration = 0;
      var sample;
      var sampleLen = samples.length;
      var _loop = function _loop2() {
        sample = samples[i];
        totalDuration += sample.duration;
        var sampleSize = isVideo ? 0 : sample.size;
        if (isVideo) {
          sample.units.forEach(function(u) {
            mdatView.setUint32(dataOffset, u.byteLength);
            dataOffset += 4;
            mdatData.set(u, dataOffset);
            dataOffset += u.byteLength;
            sampleSize += 4 + u.byteLength;
          });
        } else {
          mdatData.set(sample.data, dataOffset);
          dataOffset += sampleSize;
        }
        sample.size = sampleSize;
        ext.stsz.push(sampleSize);
        if (isVideo)
          _this._fillCttsSamples(ext.ctts, sample.cts);
        _this._fillSttsSamples(ext.stts, sample, samples[i + 1]);
        _this._fillStcoSamples(ext.stco, i, samplesPerChunk, chunkOffset);
        chunkOffset += sampleSize;
        if (isVideo && sample.keyframe) {
          ext.stss.push(i + 1);
        }
      };
      for (var i = 0; i < sampleLen; i++) {
        _loop();
      }
      track.duration = totalDuration;
      this._fillStscSamples(ext.stsc, sampleLen, samplesPerChunk);
      return {
        mdatData,
        chunkOffset
      };
    }
  }, {
    key: "_fillSttsSamples",
    value: function _fillSttsSamples(sttsSamples, cur, next) {
      var lastSample = sttsSamples[sttsSamples.length - 1];
      if (next) {
        if (!lastSample || lastSample.value !== cur.duration) {
          sttsSamples.push({
            value: cur.duration,
            count: 1
          });
        } else {
          lastSample.count++;
        }
        return;
      }
      if (lastSample) {
        lastSample.count++;
      } else {
        sttsSamples.push({
          value: 40,
          count: 1
        });
      }
    }
  }, {
    key: "_fillCttsSamples",
    value: function _fillCttsSamples(cttsSamples, cts) {
      var lastSample = cttsSamples[cttsSamples.length - 1];
      if (!lastSample || lastSample.value !== cts) {
        cttsSamples.push({
          value: cts,
          count: 1
        });
      } else {
        lastSample.count++;
      }
    }
  }, {
    key: "_fillStcoSamples",
    value: function _fillStcoSamples(stcoSamples, index, samplePerChunk, chunkOffset) {
      if (!(index % samplePerChunk)) {
        stcoSamples.push(chunkOffset);
      }
    }
  }, {
    key: "_fillStscSamples",
    value: function _fillStscSamples(samples, sampleCount, samplesPerChunk) {
      if (sampleCount <= samplesPerChunk) {
        samples.push({
          firstChunk: 1,
          samplesPerChunk: sampleCount,
          sampleDescIndex: 1
        });
      } else {
        var len = Math.floor(sampleCount / samplesPerChunk);
        var remaining = sampleCount % samplesPerChunk;
        samples.push({
          firstChunk: 1,
          samplesPerChunk,
          sampleDescIndex: 1
        });
        if (remaining) {
          samples.push({
            firstChunk: len + 1,
            samplesPerChunk: remaining,
            sampleDescIndex: 1
          });
        }
      }
    }
  }]);
  return MP4Remuxer2;
}();

// node_modules/xgplayer-mp4/es/version.js
var version = "3.0.17";

// node_modules/xgplayer-streaming-shared/es/_virtual/_rollupPluginBabelHelpers.js
function ownKeys2(object, enumerableOnly) {
  var keys = Object.keys(object);
  if (Object.getOwnPropertySymbols) {
    var symbols = Object.getOwnPropertySymbols(object);
    enumerableOnly && (symbols = symbols.filter(function(sym) {
      return Object.getOwnPropertyDescriptor(object, sym).enumerable;
    })), keys.push.apply(keys, symbols);
  }
  return keys;
}
function _objectSpread22(target) {
  for (var i = 1; i < arguments.length; i++) {
    var source = null != arguments[i] ? arguments[i] : {};
    i % 2 ? ownKeys2(Object(source), true).forEach(function(key) {
      _defineProperty3(target, key, source[key]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys2(Object(source)).forEach(function(key) {
      Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
    });
  }
  return target;
}
function _regeneratorRuntime2() {
  _regeneratorRuntime2 = function() {
    return exports;
  };
  var exports = {}, Op = Object.prototype, hasOwn = Op.hasOwnProperty, defineProperty = Object.defineProperty || function(obj, key, desc) {
    obj[key] = desc.value;
  }, $Symbol = "function" == typeof Symbol ? Symbol : {}, iteratorSymbol = $Symbol.iterator || "@@iterator", asyncIteratorSymbol = $Symbol.asyncIterator || "@@asyncIterator", toStringTagSymbol = $Symbol.toStringTag || "@@toStringTag";
  function define(obj, key, value) {
    return Object.defineProperty(obj, key, {
      value,
      enumerable: true,
      configurable: true,
      writable: true
    }), obj[key];
  }
  try {
    define({}, "");
  } catch (err) {
    define = function(obj, key, value) {
      return obj[key] = value;
    };
  }
  function wrap(innerFn, outerFn, self, tryLocsList) {
    var protoGenerator = outerFn && outerFn.prototype instanceof Generator ? outerFn : Generator, generator = Object.create(protoGenerator.prototype), context = new Context(tryLocsList || []);
    return defineProperty(generator, "_invoke", {
      value: makeInvokeMethod(innerFn, self, context)
    }), generator;
  }
  function tryCatch(fn, obj, arg) {
    try {
      return {
        type: "normal",
        arg: fn.call(obj, arg)
      };
    } catch (err) {
      return {
        type: "throw",
        arg: err
      };
    }
  }
  exports.wrap = wrap;
  var ContinueSentinel = {};
  function Generator() {
  }
  function GeneratorFunction() {
  }
  function GeneratorFunctionPrototype() {
  }
  var IteratorPrototype = {};
  define(IteratorPrototype, iteratorSymbol, function() {
    return this;
  });
  var getProto = Object.getPrototypeOf, NativeIteratorPrototype = getProto && getProto(getProto(values([])));
  NativeIteratorPrototype && NativeIteratorPrototype !== Op && hasOwn.call(NativeIteratorPrototype, iteratorSymbol) && (IteratorPrototype = NativeIteratorPrototype);
  var Gp = GeneratorFunctionPrototype.prototype = Generator.prototype = Object.create(IteratorPrototype);
  function defineIteratorMethods(prototype) {
    ["next", "throw", "return"].forEach(function(method) {
      define(prototype, method, function(arg) {
        return this._invoke(method, arg);
      });
    });
  }
  function AsyncIterator(generator, PromiseImpl) {
    function invoke(method, arg, resolve, reject) {
      var record = tryCatch(generator[method], generator, arg);
      if ("throw" !== record.type) {
        var result = record.arg, value = result.value;
        return value && "object" == typeof value && hasOwn.call(value, "__await") ? PromiseImpl.resolve(value.__await).then(function(value2) {
          invoke("next", value2, resolve, reject);
        }, function(err) {
          invoke("throw", err, resolve, reject);
        }) : PromiseImpl.resolve(value).then(function(unwrapped) {
          result.value = unwrapped, resolve(result);
        }, function(error) {
          return invoke("throw", error, resolve, reject);
        });
      }
      reject(record.arg);
    }
    var previousPromise;
    defineProperty(this, "_invoke", {
      value: function(method, arg) {
        function callInvokeWithMethodAndArg() {
          return new PromiseImpl(function(resolve, reject) {
            invoke(method, arg, resolve, reject);
          });
        }
        return previousPromise = previousPromise ? previousPromise.then(callInvokeWithMethodAndArg, callInvokeWithMethodAndArg) : callInvokeWithMethodAndArg();
      }
    });
  }
  function makeInvokeMethod(innerFn, self, context) {
    var state = "suspendedStart";
    return function(method, arg) {
      if ("executing" === state)
        throw new Error("Generator is already running");
      if ("completed" === state) {
        if ("throw" === method)
          throw arg;
        return doneResult();
      }
      for (context.method = method, context.arg = arg; ; ) {
        var delegate = context.delegate;
        if (delegate) {
          var delegateResult = maybeInvokeDelegate(delegate, context);
          if (delegateResult) {
            if (delegateResult === ContinueSentinel)
              continue;
            return delegateResult;
          }
        }
        if ("next" === context.method)
          context.sent = context._sent = context.arg;
        else if ("throw" === context.method) {
          if ("suspendedStart" === state)
            throw state = "completed", context.arg;
          context.dispatchException(context.arg);
        } else
          "return" === context.method && context.abrupt("return", context.arg);
        state = "executing";
        var record = tryCatch(innerFn, self, context);
        if ("normal" === record.type) {
          if (state = context.done ? "completed" : "suspendedYield", record.arg === ContinueSentinel)
            continue;
          return {
            value: record.arg,
            done: context.done
          };
        }
        "throw" === record.type && (state = "completed", context.method = "throw", context.arg = record.arg);
      }
    };
  }
  function maybeInvokeDelegate(delegate, context) {
    var methodName = context.method, method = delegate.iterator[methodName];
    if (void 0 === method)
      return context.delegate = null, "throw" === methodName && delegate.iterator.return && (context.method = "return", context.arg = void 0, maybeInvokeDelegate(delegate, context), "throw" === context.method) || "return" !== methodName && (context.method = "throw", context.arg = new TypeError("The iterator does not provide a '" + methodName + "' method")), ContinueSentinel;
    var record = tryCatch(method, delegate.iterator, context.arg);
    if ("throw" === record.type)
      return context.method = "throw", context.arg = record.arg, context.delegate = null, ContinueSentinel;
    var info = record.arg;
    return info ? info.done ? (context[delegate.resultName] = info.value, context.next = delegate.nextLoc, "return" !== context.method && (context.method = "next", context.arg = void 0), context.delegate = null, ContinueSentinel) : info : (context.method = "throw", context.arg = new TypeError("iterator result is not an object"), context.delegate = null, ContinueSentinel);
  }
  function pushTryEntry(locs) {
    var entry = {
      tryLoc: locs[0]
    };
    1 in locs && (entry.catchLoc = locs[1]), 2 in locs && (entry.finallyLoc = locs[2], entry.afterLoc = locs[3]), this.tryEntries.push(entry);
  }
  function resetTryEntry(entry) {
    var record = entry.completion || {};
    record.type = "normal", delete record.arg, entry.completion = record;
  }
  function Context(tryLocsList) {
    this.tryEntries = [{
      tryLoc: "root"
    }], tryLocsList.forEach(pushTryEntry, this), this.reset(true);
  }
  function values(iterable) {
    if (iterable) {
      var iteratorMethod = iterable[iteratorSymbol];
      if (iteratorMethod)
        return iteratorMethod.call(iterable);
      if ("function" == typeof iterable.next)
        return iterable;
      if (!isNaN(iterable.length)) {
        var i = -1, next = function next2() {
          for (; ++i < iterable.length; )
            if (hasOwn.call(iterable, i))
              return next2.value = iterable[i], next2.done = false, next2;
          return next2.value = void 0, next2.done = true, next2;
        };
        return next.next = next;
      }
    }
    return {
      next: doneResult
    };
  }
  function doneResult() {
    return {
      value: void 0,
      done: true
    };
  }
  return GeneratorFunction.prototype = GeneratorFunctionPrototype, defineProperty(Gp, "constructor", {
    value: GeneratorFunctionPrototype,
    configurable: true
  }), defineProperty(GeneratorFunctionPrototype, "constructor", {
    value: GeneratorFunction,
    configurable: true
  }), GeneratorFunction.displayName = define(GeneratorFunctionPrototype, toStringTagSymbol, "GeneratorFunction"), exports.isGeneratorFunction = function(genFun) {
    var ctor = "function" == typeof genFun && genFun.constructor;
    return !!ctor && (ctor === GeneratorFunction || "GeneratorFunction" === (ctor.displayName || ctor.name));
  }, exports.mark = function(genFun) {
    return Object.setPrototypeOf ? Object.setPrototypeOf(genFun, GeneratorFunctionPrototype) : (genFun.__proto__ = GeneratorFunctionPrototype, define(genFun, toStringTagSymbol, "GeneratorFunction")), genFun.prototype = Object.create(Gp), genFun;
  }, exports.awrap = function(arg) {
    return {
      __await: arg
    };
  }, defineIteratorMethods(AsyncIterator.prototype), define(AsyncIterator.prototype, asyncIteratorSymbol, function() {
    return this;
  }), exports.AsyncIterator = AsyncIterator, exports.async = function(innerFn, outerFn, self, tryLocsList, PromiseImpl) {
    void 0 === PromiseImpl && (PromiseImpl = Promise);
    var iter = new AsyncIterator(wrap(innerFn, outerFn, self, tryLocsList), PromiseImpl);
    return exports.isGeneratorFunction(outerFn) ? iter : iter.next().then(function(result) {
      return result.done ? result.value : iter.next();
    });
  }, defineIteratorMethods(Gp), define(Gp, toStringTagSymbol, "Generator"), define(Gp, iteratorSymbol, function() {
    return this;
  }), define(Gp, "toString", function() {
    return "[object Generator]";
  }), exports.keys = function(val) {
    var object = Object(val), keys = [];
    for (var key in object)
      keys.push(key);
    return keys.reverse(), function next() {
      for (; keys.length; ) {
        var key2 = keys.pop();
        if (key2 in object)
          return next.value = key2, next.done = false, next;
      }
      return next.done = true, next;
    };
  }, exports.values = values, Context.prototype = {
    constructor: Context,
    reset: function(skipTempReset) {
      if (this.prev = 0, this.next = 0, this.sent = this._sent = void 0, this.done = false, this.delegate = null, this.method = "next", this.arg = void 0, this.tryEntries.forEach(resetTryEntry), !skipTempReset)
        for (var name in this)
          "t" === name.charAt(0) && hasOwn.call(this, name) && !isNaN(+name.slice(1)) && (this[name] = void 0);
    },
    stop: function() {
      this.done = true;
      var rootRecord = this.tryEntries[0].completion;
      if ("throw" === rootRecord.type)
        throw rootRecord.arg;
      return this.rval;
    },
    dispatchException: function(exception) {
      if (this.done)
        throw exception;
      var context = this;
      function handle(loc, caught) {
        return record.type = "throw", record.arg = exception, context.next = loc, caught && (context.method = "next", context.arg = void 0), !!caught;
      }
      for (var i = this.tryEntries.length - 1; i >= 0; --i) {
        var entry = this.tryEntries[i], record = entry.completion;
        if ("root" === entry.tryLoc)
          return handle("end");
        if (entry.tryLoc <= this.prev) {
          var hasCatch = hasOwn.call(entry, "catchLoc"), hasFinally = hasOwn.call(entry, "finallyLoc");
          if (hasCatch && hasFinally) {
            if (this.prev < entry.catchLoc)
              return handle(entry.catchLoc, true);
            if (this.prev < entry.finallyLoc)
              return handle(entry.finallyLoc);
          } else if (hasCatch) {
            if (this.prev < entry.catchLoc)
              return handle(entry.catchLoc, true);
          } else {
            if (!hasFinally)
              throw new Error("try statement without catch or finally");
            if (this.prev < entry.finallyLoc)
              return handle(entry.finallyLoc);
          }
        }
      }
    },
    abrupt: function(type, arg) {
      for (var i = this.tryEntries.length - 1; i >= 0; --i) {
        var entry = this.tryEntries[i];
        if (entry.tryLoc <= this.prev && hasOwn.call(entry, "finallyLoc") && this.prev < entry.finallyLoc) {
          var finallyEntry = entry;
          break;
        }
      }
      finallyEntry && ("break" === type || "continue" === type) && finallyEntry.tryLoc <= arg && arg <= finallyEntry.finallyLoc && (finallyEntry = null);
      var record = finallyEntry ? finallyEntry.completion : {};
      return record.type = type, record.arg = arg, finallyEntry ? (this.method = "next", this.next = finallyEntry.finallyLoc, ContinueSentinel) : this.complete(record);
    },
    complete: function(record, afterLoc) {
      if ("throw" === record.type)
        throw record.arg;
      return "break" === record.type || "continue" === record.type ? this.next = record.arg : "return" === record.type ? (this.rval = this.arg = record.arg, this.method = "return", this.next = "end") : "normal" === record.type && afterLoc && (this.next = afterLoc), ContinueSentinel;
    },
    finish: function(finallyLoc) {
      for (var i = this.tryEntries.length - 1; i >= 0; --i) {
        var entry = this.tryEntries[i];
        if (entry.finallyLoc === finallyLoc)
          return this.complete(entry.completion, entry.afterLoc), resetTryEntry(entry), ContinueSentinel;
      }
    },
    catch: function(tryLoc) {
      for (var i = this.tryEntries.length - 1; i >= 0; --i) {
        var entry = this.tryEntries[i];
        if (entry.tryLoc === tryLoc) {
          var record = entry.completion;
          if ("throw" === record.type) {
            var thrown = record.arg;
            resetTryEntry(entry);
          }
          return thrown;
        }
      }
      throw new Error("illegal catch attempt");
    },
    delegateYield: function(iterable, resultName, nextLoc) {
      return this.delegate = {
        iterator: values(iterable),
        resultName,
        nextLoc
      }, "next" === this.method && (this.arg = void 0), ContinueSentinel;
    }
  }, exports;
}
function _typeof(obj) {
  "@babel/helpers - typeof";
  return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(obj2) {
    return typeof obj2;
  } : function(obj2) {
    return obj2 && "function" == typeof Symbol && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
  }, _typeof(obj);
}
function asyncGeneratorStep2(gen, resolve, reject, _next, _throw, key, arg) {
  try {
    var info = gen[key](arg);
    var value = info.value;
  } catch (error) {
    reject(error);
    return;
  }
  if (info.done) {
    resolve(value);
  } else {
    Promise.resolve(value).then(_next, _throw);
  }
}
function _asyncToGenerator2(fn) {
  return function() {
    var self = this, args = arguments;
    return new Promise(function(resolve, reject) {
      var gen = fn.apply(self, args);
      function _next(value) {
        asyncGeneratorStep2(gen, resolve, reject, _next, _throw, "next", value);
      }
      function _throw(err) {
        asyncGeneratorStep2(gen, resolve, reject, _next, _throw, "throw", err);
      }
      _next(void 0);
    });
  };
}
function _classCallCheck3(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}
function _defineProperties3(target, props) {
  for (var i = 0; i < props.length; i++) {
    var descriptor = props[i];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor)
      descriptor.writable = true;
    Object.defineProperty(target, _toPropertyKey3(descriptor.key), descriptor);
  }
}
function _createClass3(Constructor, protoProps, staticProps) {
  if (protoProps)
    _defineProperties3(Constructor.prototype, protoProps);
  if (staticProps)
    _defineProperties3(Constructor, staticProps);
  Object.defineProperty(Constructor, "prototype", {
    writable: false
  });
  return Constructor;
}
function _defineProperty3(obj, key, value) {
  key = _toPropertyKey3(key);
  if (key in obj) {
    Object.defineProperty(obj, key, {
      value,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key] = value;
  }
  return obj;
}
function _inherits3(subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function");
  }
  subClass.prototype = Object.create(superClass && superClass.prototype, {
    constructor: {
      value: subClass,
      writable: true,
      configurable: true
    }
  });
  Object.defineProperty(subClass, "prototype", {
    writable: false
  });
  if (superClass)
    _setPrototypeOf3(subClass, superClass);
}
function _getPrototypeOf3(o) {
  _getPrototypeOf3 = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf22(o2) {
    return o2.__proto__ || Object.getPrototypeOf(o2);
  };
  return _getPrototypeOf3(o);
}
function _setPrototypeOf3(o, p) {
  _setPrototypeOf3 = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf22(o2, p2) {
    o2.__proto__ = p2;
    return o2;
  };
  return _setPrototypeOf3(o, p);
}
function _isNativeReflectConstruct3() {
  if (typeof Reflect === "undefined" || !Reflect.construct)
    return false;
  if (Reflect.construct.sham)
    return false;
  if (typeof Proxy === "function")
    return true;
  try {
    Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
    }));
    return true;
  } catch (e) {
    return false;
  }
}
function _construct(Parent, args, Class) {
  if (_isNativeReflectConstruct3()) {
    _construct = Reflect.construct.bind();
  } else {
    _construct = function _construct2(Parent2, args2, Class2) {
      var a = [null];
      a.push.apply(a, args2);
      var Constructor = Function.bind.apply(Parent2, a);
      var instance = new Constructor();
      if (Class2)
        _setPrototypeOf3(instance, Class2.prototype);
      return instance;
    };
  }
  return _construct.apply(null, arguments);
}
function _isNativeFunction(fn) {
  return Function.toString.call(fn).indexOf("[native code]") !== -1;
}
function _wrapNativeSuper(Class) {
  var _cache = typeof Map === "function" ? /* @__PURE__ */ new Map() : void 0;
  _wrapNativeSuper = function _wrapNativeSuper2(Class2) {
    if (Class2 === null || !_isNativeFunction(Class2))
      return Class2;
    if (typeof Class2 !== "function") {
      throw new TypeError("Super expression must either be null or a function");
    }
    if (typeof _cache !== "undefined") {
      if (_cache.has(Class2))
        return _cache.get(Class2);
      _cache.set(Class2, Wrapper);
    }
    function Wrapper() {
      return _construct(Class2, arguments, _getPrototypeOf3(this).constructor);
    }
    Wrapper.prototype = Object.create(Class2.prototype, {
      constructor: {
        value: Wrapper,
        enumerable: false,
        writable: true,
        configurable: true
      }
    });
    return _setPrototypeOf3(Wrapper, Class2);
  };
  return _wrapNativeSuper(Class);
}
function _objectWithoutPropertiesLoose(source, excluded) {
  if (source == null)
    return {};
  var target = {};
  var sourceKeys = Object.keys(source);
  var key, i;
  for (i = 0; i < sourceKeys.length; i++) {
    key = sourceKeys[i];
    if (excluded.indexOf(key) >= 0)
      continue;
    target[key] = source[key];
  }
  return target;
}
function _objectWithoutProperties(source, excluded) {
  if (source == null)
    return {};
  var target = _objectWithoutPropertiesLoose(source, excluded);
  var key, i;
  if (Object.getOwnPropertySymbols) {
    var sourceSymbolKeys = Object.getOwnPropertySymbols(source);
    for (i = 0; i < sourceSymbolKeys.length; i++) {
      key = sourceSymbolKeys[i];
      if (excluded.indexOf(key) >= 0)
        continue;
      if (!Object.prototype.propertyIsEnumerable.call(source, key))
        continue;
      target[key] = source[key];
    }
  }
  return target;
}
function _assertThisInitialized3(self) {
  if (self === void 0) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }
  return self;
}
function _possibleConstructorReturn3(self, call) {
  if (call && (typeof call === "object" || typeof call === "function")) {
    return call;
  } else if (call !== void 0) {
    throw new TypeError("Derived constructors may only return object or undefined");
  }
  return _assertThisInitialized3(self);
}
function _createSuper3(Derived) {
  var hasNativeReflectConstruct = _isNativeReflectConstruct3();
  return function _createSuperInternal() {
    var Super = _getPrototypeOf3(Derived), result;
    if (hasNativeReflectConstruct) {
      var NewTarget = _getPrototypeOf3(this).constructor;
      result = Reflect.construct(Super, arguments, NewTarget);
    } else {
      result = Super.apply(this, arguments);
    }
    return _possibleConstructorReturn3(this, result);
  };
}
function _superPropBase(object, property) {
  while (!Object.prototype.hasOwnProperty.call(object, property)) {
    object = _getPrototypeOf3(object);
    if (object === null)
      break;
  }
  return object;
}
function _get() {
  if (typeof Reflect !== "undefined" && Reflect.get) {
    _get = Reflect.get.bind();
  } else {
    _get = function _get2(target, property, receiver) {
      var base = _superPropBase(target, property);
      if (!base)
        return;
      var desc = Object.getOwnPropertyDescriptor(base, property);
      if (desc.get) {
        return desc.get.call(arguments.length < 3 ? target : receiver);
      }
      return desc.value;
    };
  }
  return _get.apply(this, arguments);
}
function _unsupportedIterableToArray2(o, minLen) {
  if (!o)
    return;
  if (typeof o === "string")
    return _arrayLikeToArray2(o, minLen);
  var n = Object.prototype.toString.call(o).slice(8, -1);
  if (n === "Object" && o.constructor)
    n = o.constructor.name;
  if (n === "Map" || n === "Set")
    return Array.from(o);
  if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n))
    return _arrayLikeToArray2(o, minLen);
}
function _arrayLikeToArray2(arr, len) {
  if (len == null || len > arr.length)
    len = arr.length;
  for (var i = 0, arr2 = new Array(len); i < len; i++)
    arr2[i] = arr[i];
  return arr2;
}
function _createForOfIteratorHelper(o, allowArrayLike) {
  var it = typeof Symbol !== "undefined" && o[Symbol.iterator] || o["@@iterator"];
  if (!it) {
    if (Array.isArray(o) || (it = _unsupportedIterableToArray2(o)) || allowArrayLike && o && typeof o.length === "number") {
      if (it)
        o = it;
      var i = 0;
      var F = function() {
      };
      return {
        s: F,
        n: function() {
          if (i >= o.length)
            return {
              done: true
            };
          return {
            done: false,
            value: o[i++]
          };
        },
        e: function(e) {
          throw e;
        },
        f: F
      };
    }
    throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
  }
  var normalCompletion = true, didErr = false, err;
  return {
    s: function() {
      it = it.call(o);
    },
    n: function() {
      var step = it.next();
      normalCompletion = step.done;
      return step;
    },
    e: function(e) {
      didErr = true;
      err = e;
    },
    f: function() {
      try {
        if (!normalCompletion && it.return != null)
          it.return();
      } finally {
        if (didErr)
          throw err;
      }
    }
  };
}
function _toPrimitive3(input, hint) {
  if (typeof input !== "object" || input === null)
    return input;
  var prim = input[Symbol.toPrimitive];
  if (prim !== void 0) {
    var res = prim.call(input, hint || "default");
    if (typeof res !== "object")
      return res;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return (hint === "string" ? String : Number)(input);
}
function _toPropertyKey3(arg) {
  var key = _toPrimitive3(arg, "string");
  return typeof key === "symbol" ? key : String(key);
}

// node_modules/xgplayer-streaming-shared/es/buffer.js
var Buffer2 = function() {
  function Buffer22() {
    _classCallCheck3(this, Buffer22);
  }
  _createClass3(Buffer22, null, [{
    key: "start",
    value: function start(buf) {
      if (!buf || !buf.length)
        return 0;
      if (buf.length === 1 && buf.end(0) - buf.start(0) < 1e-6)
        return 0;
      if (buf.length === 1 && buf.start(0) < 0)
        return 0;
      return buf.start(0);
    }
  }, {
    key: "end",
    value: function end(buf) {
      if (!buf || !buf.length)
        return 0;
      if (buf.length === 1 && buf.end(0) - buf.start(0) < 1e-6)
        return 0;
      return buf.end(buf.length - 1);
    }
  }, {
    key: "get",
    value: function get(b) {
      if (!b)
        return;
      try {
        return b.buffered;
      } catch (error) {
      }
    }
  }, {
    key: "buffers",
    value: function buffers(buf, maxHole) {
      if (!buf || !buf.length)
        return [];
      var buffers2 = [];
      for (var i = 0, l = buf.length; i < l; i++) {
        var bufLen = buffers2.length;
        if (!bufLen || !maxHole) {
          buffers2.push([buf.start(i), buf.end(i)]);
        } else {
          var last = buffers2[bufLen - 1];
          var lastEnd = last[1];
          var start = buf.start(i);
          if (start - lastEnd <= maxHole) {
            var end = buf.end(i);
            if (end > lastEnd) {
              last[1] = end;
            }
          } else {
            buffers2.push([buf.start(i), buf.end(i)]);
          }
        }
      }
      return buffers2;
    }
  }, {
    key: "totalLength",
    value: function totalLength(buffers) {
      if (!buffers || !buffers.length)
        return 0;
      return buffers.reduce(function(a, c) {
        return a += c[1] - c[0];
      }, 0);
    }
  }, {
    key: "info",
    value: function info(buf) {
      var pos = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 0;
      var maxHole = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 0;
      if (!buf || !buf.length)
        return {
          start: 0,
          end: 0,
          buffers: []
        };
      var start = 0;
      var end = 0;
      var index = 0;
      var nextStart = 0;
      var nextEnd = 0;
      var prevStart = 0;
      var prevEnd = 0;
      var buffers = Buffer22.buffers(buf, maxHole);
      for (var i = 0, l = buffers.length; i < l; i++) {
        var item = buffers[i];
        if (pos + maxHole >= item[0] && pos <= item[1]) {
          start = item[0];
          end = item[1];
          index = i;
        } else if (pos + maxHole < item[0]) {
          nextStart = item[0];
          nextEnd = item[1];
          break;
        } else if (pos + maxHole > item[1]) {
          prevStart = item[0];
          prevEnd = item[1];
        }
      }
      return {
        start,
        end,
        index,
        buffers,
        nextStart,
        nextEnd,
        prevStart,
        prevEnd,
        currentTime: pos,
        behind: pos - start,
        remaining: end ? end - pos : 0,
        length: Buffer22.totalLength && Buffer22.totalLength(buffers)
      };
    }
  }]);
  return Buffer22;
}();

// node_modules/xgplayer-streaming-shared/es/env.js
var isBrowser2 = typeof window !== "undefined";

// node_modules/xgplayer-streaming-shared/es/error.js
var _ERR_CODE;
var ERR = {
  MANIFEST: "manifest",
  NETWORK: "network",
  NETWORK_TIMEOUT: "network_timeout",
  NETWORK_FORBIDDEN: "network_forbidden",
  NETWORK_NOTFOUND: "network_notfound",
  NETWROK_RANGE_NOT_SATISFIABLE: "network_range_not_satisfiable",
  DEMUX: "demux",
  REMUX: "remux",
  MEDIA: "media",
  DRM: "drm",
  OTHER: "other",
  RUNTIME: "runtime",
  SUB_TYPES: {
    FLV: "FLV",
    HLS: "HLS",
    MP4: "MP4",
    FMP4: "FMP4",
    MSE_ADD_SB: "MSE_ADD_SB",
    MSE_APPEND_BUFFER: "MSE_APPEND_BUFFER",
    MSE_OTHER: "MSE_OTHER",
    MSE_FULL: "MSE_FULL",
    OPTION: "OPTION",
    DASH: "DASH",
    LICENSE: "LICENSE",
    CUSTOM_LICENSE: "CUSTOM_LICENSE",
    MSE_HIJACK: "MSE_HIJACK",
    EME_HIJACK: "EME_HIJACK",
    SIDX: "SIDX",
    NO_CANPLAY_ERROR: "NO_CANPLAY_ERROR",
    BUFFERBREAK_ERROR: "BUFFERBREAK_ERROR",
    WAITING_TIMEOUT_ERROR: "WAITING_TIMEOUT_ERROR",
    MEDIA_ERR_ABORTED: "MEDIA_ERR_ABORTED",
    MEDIA_ERR_NETWORK: "MEDIA_ERR_NETWORK",
    MEDIA_ERR_DECODE: "MEDIA_ERR_DECODE",
    MEDIA_ERR_SRC_NOT_SUPPORTED: "MEDIA_ERR_SRC_NOT_SUPPORTED",
    MEDIA_ERR_CODEC_NOT_SUPPORTED: "MEDIA_ERR_CODEC_NOT_SUPPORTED",
    MEDIA_ERR_URL_EMPTY: "MEDIA_ERR_URL_EMPTY"
  }
};
var ERR_CODE = (_ERR_CODE = {}, _defineProperty3(_ERR_CODE, ERR.MANIFEST, {
  HLS: 1100,
  DASH: 1200
}), _defineProperty3(_ERR_CODE, ERR.NETWORK, 2100), _defineProperty3(_ERR_CODE, ERR.NETWORK_TIMEOUT, 2101), _defineProperty3(_ERR_CODE, ERR.NETWORK_FORBIDDEN, 2103), _defineProperty3(_ERR_CODE, ERR.NETWORK_NOTFOUND, 2104), _defineProperty3(_ERR_CODE, ERR.NETWROK_RANGE_NOT_SATISFIABLE, 2116), _defineProperty3(_ERR_CODE, ERR.DEMUX, {
  FLV: 3100,
  HLS: 3200,
  MP4: 3300,
  FMP4: 3400,
  SIDX: 3410
}), _defineProperty3(_ERR_CODE, ERR.REMUX, {
  FMP4: 4100,
  MP4: 4200
}), _defineProperty3(_ERR_CODE, ERR.MEDIA, {
  MEDIA_ERR_ABORTED: 5101,
  MEDIA_ERR_NETWORK: 5102,
  MEDIA_ERR_DECODE: 5103,
  MEDIA_ERR_SRC_NOT_SUPPORTED: 5104,
  MEDIA_ERR_CODEC_NOT_SUPPORTED: 5105,
  MEDIA_ERR_URL_EMPTY: 5106,
  MSE_ADD_SB: 5200,
  MSE_APPEND_BUFFER: 5201,
  MSE_OTHER: 5202,
  MSE_FULL: 5203,
  MSE_HIJACK: 5204,
  EME_HIJACK: 5301
}), _defineProperty3(_ERR_CODE, ERR.DRM, {
  LICENSE: 7100,
  CUSTOM_LICENSE: 7200
}), _defineProperty3(_ERR_CODE, ERR.OTHER, 8e3), _defineProperty3(_ERR_CODE, ERR.RUNTIME, {
  NO_CANPLAY_ERROR: 9001,
  BUFFERBREAK_ERROR: 9002,
  WAITING_TIMEOUT_ERROR: 9003
}), _ERR_CODE);
var StreamingError = function(_Error) {
  _inherits3(StreamingError2, _Error);
  var _super = _createSuper3(StreamingError2);
  function StreamingError2(type, subType, origin, payload, msg) {
    var _this;
    _classCallCheck3(this, StreamingError2);
    _this = _super.call(this, msg || (origin === null || origin === void 0 ? void 0 : origin.message));
    _this.errorType = type === ERR.NETWORK_TIMEOUT ? ERR.NETWORK : type;
    _this.originError = origin;
    _this.ext = payload;
    _this.errorCode = ERR_CODE[type][subType] || ERR_CODE[type];
    _this.errorMessage = _this.message;
    if (!_this.errorCode) {
      _this.errorType = ERR.OTHER;
      _this.errorCode = ERR_CODE[_this.errorType];
    }
    return _this;
  }
  _createClass3(StreamingError2, null, [{
    key: "create",
    value: function create(type, subType, origin, payload, msg) {
      if (type instanceof StreamingError2) {
        return type;
      } else if (type instanceof Error) {
        origin = type;
        type = "";
      }
      if (!type)
        type = ERR.OTHER;
      return new StreamingError2(type, subType, origin, payload, msg);
    }
  }, {
    key: "network",
    value: function network(error) {
      var _error$response;
      return new StreamingError2(error !== null && error !== void 0 && error.isTimeout ? ERR.NETWORK_TIMEOUT : ERR.NETWORK, null, error instanceof Error ? error : null, {
        url: error === null || error === void 0 ? void 0 : error.url,
        response: error === null || error === void 0 ? void 0 : error.response,
        httpCode: error === null || error === void 0 ? void 0 : (_error$response = error.response) === null || _error$response === void 0 ? void 0 : _error$response.status
      });
    }
  }]);
  return StreamingError2;
}(_wrapNativeSuper(Error));

// node_modules/xgplayer-streaming-shared/es/logger.js
var LogCacheLevel = {
  "DEBUG": 1,
  "LOG": 2,
  "WARN": 3,
  "ERROR": 4
};
var LOG_MAX_SIZE = 200 * 1024;
var SIMPLE_TYPE = ["Boolean", "Number", "String", "Undefined", "Null", "Date", "Object"];
var Logger3 = function() {
  function Logger22(name, config) {
    _classCallCheck3(this, Logger22);
    this.name = name || "";
    this._prefix = "[".concat(this.name, "]");
    this.logCacheLevel = (config === null || config === void 0 ? void 0 : config.logCacheLevel) || 3;
    this.logMaxSize = (config === null || config === void 0 ? void 0 : config.logMaxSize) || LOG_MAX_SIZE;
    this.logSize = 0;
    this.logTextArray = [];
  }
  _createClass3(Logger22, [{
    key: "debug",
    value: function debug() {
      var _console;
      for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
        args[_key] = arguments[_key];
      }
      this.logCache.apply(this, [LogCacheLevel.DEBUG].concat(args));
      if (Logger22.disabled)
        return;
      (_console = console).debug.apply(_console, [this._prefix, nowTime()].concat(args));
    }
  }, {
    key: "log",
    value: function log2() {
      var _console2;
      for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
        args[_key2] = arguments[_key2];
      }
      this.logCache.apply(this, [LogCacheLevel.LOG].concat(args));
      if (Logger22.disabled)
        return;
      (_console2 = console).log.apply(_console2, [this._prefix, nowTime()].concat(args));
    }
  }, {
    key: "warn",
    value: function warn() {
      var _console3;
      for (var _len3 = arguments.length, args = new Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {
        args[_key3] = arguments[_key3];
      }
      this.logCache.apply(this, [LogCacheLevel.WARN].concat(args));
      if (Logger22.disabled)
        return;
      (_console3 = console).warn.apply(_console3, [this._prefix, nowTime()].concat(args));
    }
  }, {
    key: "error",
    value: function error() {
      var _console4;
      for (var _len4 = arguments.length, args = new Array(_len4), _key4 = 0; _key4 < _len4; _key4++) {
        args[_key4] = arguments[_key4];
      }
      this.logCache.apply(this, [LogCacheLevel.ERROR].concat(args));
      if (Logger22.disabled)
        return;
      (_console4 = console).error.apply(_console4, [this._prefix, nowTime()].concat(args));
    }
  }, {
    key: "logCache",
    value: function logCache(logCacheLevel) {
      if (logCacheLevel < this.logCacheLevel)
        return;
      var text = "";
      try {
        for (var _len5 = arguments.length, logText = new Array(_len5 > 1 ? _len5 - 1 : 0), _key5 = 1; _key5 < _len5; _key5++) {
          logText[_key5 - 1] = arguments[_key5];
        }
        var finLogText = logText.map(function(item) {
          return logable(item);
        });
        text = this._prefix + nowTime() + JSON.stringify(finLogText);
      } catch (e) {
        return;
      }
      if (logCacheLevel >= this.logCacheLevel) {
        this.logSize += text.length;
        this.logTextArray.push(text);
      }
      if (this.logSize > this.logMaxSize) {
        var delLog = this.logTextArray.shift();
        this.logSize -= delLog.length;
      }
    }
  }, {
    key: "getLogCache",
    value: function getLogCache() {
      var logText = this.logTextArray.join("\n");
      this.reset();
      return logText;
    }
  }, {
    key: "reset",
    value: function reset() {
      this.logTextArray = [];
      this.logSize = 0;
    }
  }, {
    key: "table",
    value: function table() {
      var _console5;
      if (Logger22.disabled)
        return;
      console.group(this._prefix);
      (_console5 = console).table.apply(_console5, arguments);
      console.groupEnd();
    }
  }, {
    key: "setLogLevel",
    value: function setLogLevel(val) {
      this.logCacheLevel = val;
    }
  }], [{
    key: "enable",
    value: function enable() {
      Logger22.disabled = false;
    }
  }, {
    key: "disable",
    value: function disable() {
      Logger22.disabled = true;
    }
  }]);
  return Logger22;
}();
_defineProperty3(Logger3, "disabled", true);
function nowTime() {
  return (/* @__PURE__ */ new Date()).toLocaleString();
}
function reduceDepth(val) {
  if (_typeof(val) !== "object") {
    return val;
  }
  var objType = Object.prototype.toString.call(val).slice(8, -1);
  switch (objType) {
    case "Array":
    case "Uint8Array":
    case "ArrayBuffer":
      return objType + "[" + val.length + "]";
    case "Object":
      return "{}";
    default:
      return objType;
  }
}
function logable(obj, maxDepth, depth) {
  if (!depth)
    depth = 1;
  if (!maxDepth)
    maxDepth = 2;
  var result = {};
  if (!obj || _typeof(obj) !== "object") {
    return obj;
  }
  var objType = Object.prototype.toString.call(obj).slice(8, -1);
  if (!SIMPLE_TYPE.includes(objType)) {
    return objType;
  }
  if (depth > maxDepth) {
    return void 0;
  }
  for (var key in obj) {
    if (Object.prototype.hasOwnProperty.call(obj, key)) {
      if (depth === maxDepth) {
        result[key] = reduceDepth(obj[key]);
      } else if (_typeof(obj[key]) === "object") {
        result[key] = logable(obj[key], maxDepth, depth + 1);
      } else {
        result[key] = obj[key];
      }
    }
  }
  return result;
}

// node_modules/xgplayer-streaming-shared/es/utils.js
function createPublicPromise() {
  var res, rej;
  var promise = new Promise(function(resolve, reject) {
    res = resolve;
    rej = reject;
  });
  promise.used = false;
  promise.resolve = function() {
    promise.used = true;
    return res.apply(void 0, arguments);
  };
  promise.reject = function() {
    promise.used = true;
    return rej.apply(void 0, arguments);
  };
  return promise;
}
function nowTime2() {
  try {
    return parseInt(performance.now(), 10);
  } catch (e) {
    return (/* @__PURE__ */ new Date()).getTime();
  }
}
var SafeJSON = {
  stringify: function stringify(obj) {
    try {
      return JSON.stringify(obj);
    } catch (e) {
      return "";
    }
  },
  parse: function parse2(obj) {
    try {
      return JSON.parse(obj);
    } catch (e) {
      return void 0;
    }
  }
};

// node_modules/xgplayer-streaming-shared/es/mse.js
function getMediaSource() {
  var preferMMS = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : true;
  try {
    if (!isBrowser2)
      return null;
    if (preferMMS && typeof ManagedMediaSource !== "undefined")
      return ManagedMediaSource;
    return window.MediaSource;
  } catch (e) {
  }
}
function isMMS(mediaSource) {
  return /ManagedMediaSource/gi.test(Object.prototype.toString.call(mediaSource));
}
function getTimeRanges(buffered) {
  var ranges = [];
  if (buffered instanceof TimeRanges) {
    for (var i = 0; i < buffered.length; i++) {
      ranges.push({
        start: buffered.start(i),
        end: buffered.end(i)
      });
    }
  }
  return ranges;
}
var OP_NAME = {
  APPEND: "appendBuffer",
  REMOVE: "removeBuffer",
  UPDATE_DURATION: "updateDuration"
};
var MSEError = function(_Error) {
  _inherits3(MSEError2, _Error);
  var _super = _createSuper3(MSEError2);
  function MSEError2(type, msg) {
    var _this;
    _classCallCheck3(this, MSEError2);
    _this = _super.call(this, msg || type);
    _this.type = type;
    _this.msg = msg;
    return _this;
  }
  return _createClass3(MSEError2);
}(_wrapNativeSuper(Error));
var MSE = function() {
  function MSE2(media, config) {
    var _this2 = this;
    _classCallCheck3(this, MSE2);
    _defineProperty3(this, "media", null);
    _defineProperty3(this, "mediaSource", null);
    _defineProperty3(this, "_openPromise", createPublicPromise());
    _defineProperty3(this, "_queue", /* @__PURE__ */ Object.create(null));
    _defineProperty3(this, "_sourceBuffer", /* @__PURE__ */ Object.create(null));
    _defineProperty3(this, "_mseFullFlag", {});
    _defineProperty3(this, "_st", 0);
    _defineProperty3(this, "_opst", 0);
    _defineProperty3(this, "_logger", null);
    _defineProperty3(this, "_config", null);
    _defineProperty3(this, "_url", null);
    _defineProperty3(this, "_onStartStreaming", function() {
      _this2._logger.debug("startstreaming");
    });
    _defineProperty3(this, "_onEndStreaming", function() {
      _this2._logger.debug("endstreaming");
    });
    _defineProperty3(this, "_onSBUpdateEnd", function(type) {
      var queue = _this2._queue[type];
      if (queue) {
        var op = queue[0];
        if (!((op === null || op === void 0 ? void 0 : op.opName) === OP_NAME.UPDATE_DURATION)) {
          queue.shift();
        }
        if (op) {
          var _this2$_sourceBuffer$;
          var costtime = nowTime2() - _this2._opst;
          _this2._logger.debug("UpdateEnd(".concat(type, "/").concat(op.opName, ")"), SafeJSON.stringify(getTimeRanges((_this2$_sourceBuffer$ = _this2._sourceBuffer[type]) === null || _this2$_sourceBuffer$ === void 0 ? void 0 : _this2$_sourceBuffer$.buffered)), costtime, op.context);
          op.promise.resolve({
            name: op.opName,
            context: op.context,
            costtime
          });
          _this2._startQueue(type);
        }
      }
    });
    _defineProperty3(this, "_onSBUpdateError", function(type, event) {
      var queue = _this2._queue[type];
      if (queue) {
        var op = queue[0];
        if (op) {
          _this2._logger.error("UpdateError", type, op.opName, op.context);
          op.promise.reject(new StreamingError(ERR.MEDIA, ERR.SUB_TYPES.MSE_APPEND_BUFFER, event));
        }
      }
    });
    this._config = Object.assign(MSE2.getDefaultConfig(), config);
    if (media)
      this.bindMedia(media);
    this._logger = new Logger3("MSE");
    if (this._config.openLog) {
      Logger3.enable();
    }
  }
  _createClass3(MSE2, [{
    key: "isOpened",
    get: function get() {
      var _this$mediaSource;
      return ((_this$mediaSource = this.mediaSource) === null || _this$mediaSource === void 0 ? void 0 : _this$mediaSource.readyState) === "open";
    }
  }, {
    key: "hasOpTasks",
    get: function get() {
      var _this3 = this;
      var flag = false;
      Object.keys(this._queue).forEach(function(k) {
        var queue = _this3._queue[k];
        if (Array.isArray(queue)) {
          flag || (flag = queue.length > 0);
        }
      });
      return flag;
    }
  }, {
    key: "url",
    get: function get() {
      return this._url;
    }
  }, {
    key: "duration",
    get: function get() {
      var _this$mediaSource2;
      return ((_this$mediaSource2 = this.mediaSource) === null || _this$mediaSource2 === void 0 ? void 0 : _this$mediaSource2.duration) || -1;
    }
  }, {
    key: "isEnded",
    get: function get() {
      return this.mediaSource ? this.mediaSource.readyState === "ended" : false;
    }
  }, {
    key: "streaming",
    get: function get() {
      return isMMS(this.mediaSource) ? this.mediaSource.streaming : true;
    }
  }, {
    key: "isFull",
    value: function isFull(type) {
      return type ? this._mseFullFlag[type] : this._mseFullFlag[MSE2.VIDEO];
    }
  }, {
    key: "updateDuration",
    value: function updateDuration(duration) {
      var _this4 = this;
      var isReduceDuration = this.mediaSource && this.mediaSource.duration > duration;
      if (this.mediaSource && this.mediaSource.duration > duration) {
        var bufferEnd = 0;
        Object.keys(this._sourceBuffer).forEach(function(k) {
          try {
            bufferEnd = Math.max(_this4.bufferEnd(k) || 0, bufferEnd);
          } catch (error) {
          }
        });
        if (duration < bufferEnd) {
          return Promise.resolve();
        }
      }
      return this._enqueueBlockingOp(function() {
        if (_this4.isEnded) {
          _this4._logger.debug("setDuration but ended");
          return;
        }
        if (_this4.mediaSource) {
          _this4.mediaSource.duration = duration;
          _this4._logger.debug("setDuration", duration);
        }
      }, OP_NAME.UPDATE_DURATION, {
        isReduceDuration
      });
    }
  }, {
    key: "open",
    value: function open() {
      var _this5 = this;
      if (this._openPromise.used && !this.isOpened && this.mediaSource) {
        var ms = this.mediaSource;
        var onOpen = function onOpen2() {
          var costTime = nowTime2() - _this5._st;
          _this5._logger.debug("sourceopen", costTime);
          ms.removeEventListener("sourceopen", onOpen2);
          _this5._openPromise.resolve({
            costtime: costTime
          });
        };
        ms.addEventListener("sourceopen", onOpen);
        this._openPromise = createPublicPromise();
      }
      return this._openPromise;
    }
  }, {
    key: "bindMedia",
    value: function() {
      var _bindMedia = _asyncToGenerator2(_regeneratorRuntime2().mark(function _callee(media) {
        var _this6 = this;
        var MediaSource2, ms, useMMS, onOpen;
        return _regeneratorRuntime2().wrap(function _callee$(_context) {
          while (1)
            switch (_context.prev = _context.next) {
              case 0:
                if (!(this.mediaSource || this.media)) {
                  _context.next = 3;
                  break;
                }
                _context.next = 3;
                return this.unbindMedia();
              case 3:
                MediaSource2 = getMediaSource(this._config.preferMMS);
                if (!(!media || !MediaSource2)) {
                  _context.next = 6;
                  break;
                }
                throw new Error("Param media or MediaSource does not exist");
              case 6:
                this.media = media;
                ms = this.mediaSource = new MediaSource2();
                useMMS = isMMS(ms);
                this._st = nowTime2();
                onOpen = function onOpen2() {
                  var costTime = nowTime2() - _this6._st;
                  _this6._logger.debug("sourceopen");
                  ms.removeEventListener("sourceopen", onOpen2);
                  URL.revokeObjectURL(media.src);
                  _this6._openPromise.resolve({
                    costtime: costTime
                  });
                };
                ms.addEventListener("sourceopen", onOpen);
                if (useMMS) {
                  ms.addEventListener("startstreaming", this._onStartStreaming);
                  ms.addEventListener("endstreaming", this._onEndStreaming);
                }
                this._url = URL.createObjectURL(ms);
                media.src = this._url;
                media.disableRemotePlayback = useMMS;
                return _context.abrupt("return", this._openPromise);
              case 17:
              case "end":
                return _context.stop();
            }
        }, _callee, this);
      }));
      function bindMedia(_x) {
        return _bindMedia.apply(this, arguments);
      }
      return bindMedia;
    }()
  }, {
    key: "unbindMedia",
    value: function() {
      var _unbindMedia = _asyncToGenerator2(_regeneratorRuntime2().mark(function _callee2() {
        var _this7 = this;
        var ms, hasMetadata, mseOpen;
        return _regeneratorRuntime2().wrap(function _callee2$(_context2) {
          while (1)
            switch (_context2.prev = _context2.next) {
              case 0:
                if (!this._openPromise.used)
                  this._openPromise.resolve();
                ms = this.mediaSource;
                if (ms) {
                  Object.keys(this._queue).forEach(function(t) {
                    var queue = _this7._queue[t];
                    if (queue) {
                      queue.forEach(function(x2) {
                        var _x$promise, _x$promise$resolve;
                        return (_x$promise = x2.promise) === null || _x$promise === void 0 ? void 0 : (_x$promise$resolve = _x$promise.resolve) === null || _x$promise$resolve === void 0 ? void 0 : _x$promise$resolve.call(_x$promise);
                      });
                    }
                  });
                  hasMetadata = !!this.media && this.media.readyState >= 1;
                  mseOpen = ms.readyState === "open";
                  if (hasMetadata && mseOpen) {
                    try {
                      ms.endOfStream();
                    } catch (error) {
                    }
                  }
                  Object.keys(this._sourceBuffer).forEach(function(k) {
                    try {
                      ms.removeSourceBuffer(_this7._sourceBuffer[k]);
                    } catch (error) {
                    }
                  });
                  if (isMMS(ms)) {
                    ms.removeEventListener("startstreaming", this._onStartStreaming);
                    ms.removeEventListener("endstreaming", this._onEndStreaming);
                  }
                }
                if (this.media) {
                  this.media.disableRemotePlayback = false;
                  this.media.removeAttribute("src");
                  try {
                    this.media.load();
                  } catch (error) {
                  }
                  this.media = null;
                }
                this.mediaSource = null;
                this._openPromise = createPublicPromise();
                this._queue = /* @__PURE__ */ Object.create(null);
                this._sourceBuffer = /* @__PURE__ */ Object.create(null);
              case 8:
              case "end":
                return _context2.stop();
            }
        }, _callee2, this);
      }));
      function unbindMedia() {
        return _unbindMedia.apply(this, arguments);
      }
      return unbindMedia;
    }()
  }, {
    key: "createSource",
    value: function createSource(type, mimeType) {
      if (this._sourceBuffer[type] || !this.mediaSource)
        return;
      var sb;
      try {
        sb = this._sourceBuffer[type] = this.mediaSource.addSourceBuffer(mimeType);
      } catch (error) {
        throw new StreamingError(ERR.MEDIA, ERR.SUB_TYPES.MSE_ADD_SB, error);
      }
      sb.mimeType = mimeType;
      sb.addEventListener("updateend", this._onSBUpdateEnd.bind(this, type));
      sb.addEventListener("error", this._onSBUpdateError.bind(this, type));
    }
  }, {
    key: "changeType",
    value: function changeType(type, mimeType) {
      var _this8 = this;
      var sb = this._sourceBuffer[type];
      if (!this.mediaSource || !sb || sb.mimeType === mimeType)
        return Promise.resolve();
      if (typeof sb.changeType !== "function")
        return Promise.reject();
      return this._enqueueOp(type, function() {
        sb.changeType(mimeType);
        sb.mimeType = mimeType;
        _this8._onSBUpdateEnd(type);
      }, "changeType", {
        mimeType
      });
    }
  }, {
    key: "createOrChangeSource",
    value: function createOrChangeSource(type, mimeType) {
      this.createSource(type, mimeType);
      return this.changeType(type, mimeType);
    }
  }, {
    key: "append",
    value: function append(type, buffer, context) {
      var _this9 = this;
      if (!buffer || !buffer.byteLength) {
        return Promise.resolve();
      }
      if (!this._sourceBuffer[type])
        return Promise.resolve();
      return this._enqueueOp(type, function() {
        var _this9$_sourceBuffer$;
        if (!_this9.mediaSource || _this9.media.error)
          return;
        _this9._logger.debug("MSE APPEND START", context);
        _this9._opst = nowTime2();
        (_this9$_sourceBuffer$ = _this9._sourceBuffer[type]) === null || _this9$_sourceBuffer$ === void 0 ? void 0 : _this9$_sourceBuffer$.appendBuffer(buffer);
      }, OP_NAME.APPEND, context);
    }
  }, {
    key: "remove",
    value: function remove(type, startTime, endTime, context) {
      var _this10 = this;
      var isInsertHead = false;
      if (this._mseFullFlag[type]) {
        isInsertHead = true;
      }
      return this._enqueueOp(type, function() {
        if (!_this10.mediaSource || _this10.media.error)
          return;
        var sb = _this10._sourceBuffer[type];
        if (startTime >= endTime || !sb) {
          _this10._onSBUpdateEnd(type);
          return;
        }
        _this10._opst = nowTime2();
        _this10._logger.debug("MSE REMOVE START", type, startTime, endTime, context);
        sb.remove(startTime, endTime);
      }, OP_NAME.REMOVE, context, isInsertHead);
    }
  }, {
    key: "clearBuffer",
    value: function clearBuffer(startTime, endTime) {
      var _this11 = this;
      var p;
      Object.keys(this._sourceBuffer).forEach(function(k) {
        p = _this11.remove(k, startTime, endTime);
      });
      return p || Promise.resolve();
    }
  }, {
    key: "clearAllBuffer",
    value: function clearAllBuffer() {
      var _this12 = this;
      var p;
      Object.keys(this._sourceBuffer).forEach(function(k) {
        var sb = _this12._sourceBuffer[k];
        p = _this12.remove(k, 0, Buffer2.end(Buffer2.get(sb)));
      });
      return p;
    }
  }, {
    key: "clearOpQueues",
    value: function clearOpQueues(type, allClear) {
      var _this$_queue$type;
      this._logger.debug("MSE clearOpQueue START");
      var queue = this._queue[type];
      if (allClear && queue) {
        this._queue[type] = [];
        return;
      }
      if (!queue || !queue[type] || queue.length < 5)
        return;
      var initQueue = [];
      queue.forEach(function(op) {
        if (op.context && op.context.isinit) {
          initQueue.push(op);
        }
      });
      this._queue[type] = queue.slice(0, 2);
      initQueue.length > 0 && (_this$_queue$type = this._queue[type]).push.apply(_this$_queue$type, initQueue);
    }
  }, {
    key: "endOfStream",
    value: function endOfStream(reason) {
      var _this13 = this;
      if (!this.mediaSource || this.mediaSource.readyState !== "open")
        return Promise.resolve();
      return this._enqueueBlockingOp(function() {
        var ms = _this13.mediaSource;
        if (!ms || ms.readyState !== "open")
          return;
        _this13._logger.debug("MSE endOfStream START");
        if (reason) {
          ms.endOfStream(reason);
        } else {
          ms.endOfStream();
        }
      }, "endOfStream");
    }
  }, {
    key: "setLiveSeekableRange",
    value: function setLiveSeekableRange(start, end) {
      var ms = this.mediaSource;
      if (start < 0 || end < start || !(ms !== null && ms !== void 0 && ms.setLiveSeekableRange) || ms.readyState !== "open")
        return;
      ms.setLiveSeekableRange(start, end);
    }
  }, {
    key: "getSourceBuffer",
    value: function getSourceBuffer(type) {
      return this._sourceBuffer[type];
    }
  }, {
    key: "buffered",
    value: function buffered(type) {
      return Buffer2.get(this._sourceBuffer[type]);
    }
  }, {
    key: "bufferStart",
    value: function bufferStart(type) {
      return Buffer2.start(this.buffered(type));
    }
  }, {
    key: "bufferEnd",
    value: function bufferEnd(type) {
      return Buffer2.end(this.buffered(type));
    }
  }, {
    key: "_enqueueOp",
    value: function _enqueueOp(type, exec, opName, context, isInsertHead) {
      var _this14 = this;
      if (!this.mediaSource)
        return Promise.resolve();
      var queue = this._queue[type] = this._queue[type] || [];
      var op = {
        exec,
        promise: createPublicPromise(),
        opName,
        context
      };
      if (isInsertHead) {
        queue.splice(0, 0, op);
        this._mseFullFlag[type] = false;
        this._startQueue(type);
      } else {
        queue.push(op);
      }
      if (this.isOpened || this.isEnded) {
        if (queue.length === 1) {
          this._startQueue(type);
        }
      } else {
        this._openPromise.then(function() {
          if (queue.length === 1) {
            _this14._startQueue(type);
          }
        });
      }
      return op.promise;
    }
  }, {
    key: "_enqueueBlockingOp",
    value: function() {
      var _enqueueBlockingOp2 = _asyncToGenerator2(_regeneratorRuntime2().mark(function _callee3(exec, opName, context) {
        var _this15 = this;
        var types, waiters;
        return _regeneratorRuntime2().wrap(function _callee3$(_context3) {
          while (1)
            switch (_context3.prev = _context3.next) {
              case 0:
                if (this.mediaSource) {
                  _context3.next = 2;
                  break;
                }
                return _context3.abrupt("return", Promise.resolve());
              case 2:
                types = Object.keys(this._sourceBuffer);
                if (types.length) {
                  _context3.next = 5;
                  break;
                }
                return _context3.abrupt("return", exec());
              case 5:
                waiters = [];
                types.forEach(function(t) {
                  var queue = _this15._queue[t];
                  var prom = createPublicPromise();
                  waiters.push(prom);
                  queue.push({
                    exec: function exec2() {
                      prom.resolve();
                    },
                    promise: prom,
                    opName,
                    context
                  });
                  if (queue.length === 1) {
                    _this15._startQueue(t);
                  }
                });
                return _context3.abrupt("return", Promise.all(waiters).then(function() {
                  try {
                    return exec();
                  } finally {
                    types.forEach(function(t) {
                      var queue = _this15._queue[t];
                      var sb = _this15._sourceBuffer[t];
                      queue === null || queue === void 0 ? void 0 : queue.shift();
                      if (!sb || !sb.updating) {
                        _this15._startQueue(t);
                      }
                    });
                  }
                }));
              case 8:
              case "end":
                return _context3.stop();
            }
        }, _callee3, this);
      }));
      function _enqueueBlockingOp(_x2, _x3, _x4) {
        return _enqueueBlockingOp2.apply(this, arguments);
      }
      return _enqueueBlockingOp;
    }()
  }, {
    key: "_startQueue",
    value: function _startQueue(type) {
      var queue = this._queue[type];
      if (queue) {
        var op = queue[0];
        if (op && !this._mseFullFlag[type]) {
          try {
            op.exec();
          } catch (error) {
            if (error && error.message && error.message.indexOf("SourceBuffer is full") >= 0) {
              this._mseFullFlag[type] = true;
              this._logger.error("[MSE error],  context,", op.context, " ,name,", op.opName, ",err,SourceBuffer is full");
              op.promise.reject(new StreamingError(ERR.MEDIA, ERR.SUB_TYPES.MSE_FULL, error));
            } else {
              this._logger.error(error);
              op.promise.reject(new StreamingError(ERR.MEDIA, ERR.SUB_TYPES.MSE_OTHER, error));
              queue.shift();
              this._startQueue(type);
            }
          }
        }
      }
    }
  }, {
    key: "setTimeoffset",
    value: function setTimeoffset(type, timestampOffset, context) {
      var _this16 = this;
      return this._enqueueOp(type, function() {
        if (timestampOffset < 0) {
          timestampOffset += 1e-3;
        }
        _this16._sourceBuffer[type].timestampOffset = timestampOffset;
        _this16._onSBUpdateEnd(type);
      }, "setTimeoffset", context);
    }
  }, {
    key: "abort",
    value: function abort(type, context) {
      var _this17 = this;
      if (!this.isOpened) {
        return Promise.resolve();
      }
      return this._enqueueOp(type, function() {
        _this17._sourceBuffer[type].abort();
        _this17._onSBUpdateEnd(type);
      }, "abort", context);
    }
  }], [{
    key: "isSupported",
    value: function isSupported() {
      var mime = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : 'video/mp4; codecs="avc1.42E01E,mp4a.40.2"';
      var MediaSource2 = getMediaSource();
      if (!MediaSource2)
        return false;
      try {
        return MediaSource2.isTypeSupported(mime);
      } catch (error) {
        this._logger.error(mime, error);
        return false;
      }
    }
  }, {
    key: "isMMSOnly",
    value: function isMMSOnly() {
      return typeof ManagedMediaSource !== "undefined" && typeof MediaSource === "undefined";
    }
  }, {
    key: "getDefaultConfig",
    value: function getDefaultConfig() {
      return {
        openLog: false,
        preferMMS: false
      };
    }
  }]);
  return MSE2;
}();
_defineProperty3(MSE, "VIDEO", "video");
_defineProperty3(MSE, "AUDIO", "audio");

// node_modules/xgplayer-streaming-shared/es/net/types.js
var LoaderType = {
  FETCH: "fetch",
  XHR: "xhr"
};
var ResponseType = {
  ARRAY_BUFFER: "arraybuffer",
  TEXT: "text",
  JSON: "json"
};

// node_modules/xgplayer-streaming-shared/es/net/error.js
var NetError = function(_Error) {
  _inherits3(NetError2, _Error);
  var _super = _createSuper3(NetError2);
  function NetError2(url, request, response, msg) {
    var _this;
    _classCallCheck3(this, NetError2);
    _this = _super.call(this, msg);
    _defineProperty3(_assertThisInitialized3(_this), "retryCount", 0);
    _defineProperty3(_assertThisInitialized3(_this), "isTimeout", false);
    _defineProperty3(_assertThisInitialized3(_this), "loaderType", LoaderType.FETCH);
    _defineProperty3(_assertThisInitialized3(_this), "startTime", 0);
    _defineProperty3(_assertThisInitialized3(_this), "endTime", 0);
    _defineProperty3(_assertThisInitialized3(_this), "options", {});
    _this.url = url;
    _this.request = request;
    _this.response = response;
    return _this;
  }
  return _createClass3(NetError2);
}(_wrapNativeSuper(Error));

// node_modules/xgplayer-streaming-shared/es/is.js
var toString = Object.prototype.toString;
function isObject(a) {
  return a !== null && _typeof(a) === "object";
}
function isPlainObject(val) {
  if (toString.call(val) !== "[object Object]") {
    return false;
  }
  var prototype = Object.getPrototypeOf(val);
  return prototype === null || prototype === Object.prototype;
}
function isDate(a) {
  return toString.call(a) === "[object Date]";
}

// node_modules/xgplayer-streaming-shared/es/net/helper.js
function getRangeValue(value) {
  if (!value || value[0] === null || value[0] === void 0 || value[0] === 0 && (value[1] === null || value[1] === void 0)) {
    return;
  }
  var ret = "bytes=" + value[0] + "-";
  if (value[1])
    ret += value[1];
  return ret;
}
function encode(val) {
  return encodeURIComponent(val).replace(/%3A/gi, ":").replace(/%24/g, "$").replace(/%2C/gi, ",").replace(/%20/g, "+").replace(/%5B/gi, "[").replace(/%5D/gi, "]");
}
function setUrlParams(url, params) {
  if (!url)
    return;
  if (!params)
    return url;
  var v;
  var str = Object.keys(params).map(function(k) {
    v = params[k];
    if (v === null || v === void 0)
      return;
    if (Array.isArray(v)) {
      k = k + "[]";
    } else {
      v = [v];
    }
    return v.map(function(x2) {
      if (isDate(x2)) {
        x2 = x2.toISOString();
      } else if (isObject(x2)) {
        x2 = JSON.stringify(x2);
      }
      return "".concat(encode(k), "=").concat(encode(x2));
    }).join("&");
  }).filter(Boolean).join("&");
  if (str) {
    var hashIndex = url.indexOf("#");
    if (hashIndex !== -1) {
      url = url.slice(0, hashIndex);
    }
    url += (url.indexOf("?") === -1 ? "?" : "&") + str;
  }
  return url;
}
function createResponse(data, done, response, contentLength, age, startTime, firstByteTime, index, range, vid, priOptions) {
  age = age !== null && age !== void 0 ? parseFloat(age) : null;
  contentLength = parseInt(contentLength || "0", 10);
  if (Number.isNaN(contentLength))
    contentLength = 0;
  var options = {
    range,
    vid,
    index,
    contentLength,
    age,
    startTime,
    firstByteTime,
    endTime: Date.now(),
    priOptions
  };
  return {
    data,
    done,
    options,
    response
  };
}
function calculateSpeed(byteLen, millisec) {
  return Math.round(byteLen * 8 * 1e3 / millisec / 1024);
}

// node_modules/xgplayer-streaming-shared/es/event.js
var EVENT = {
  ERROR: "error",
  TTFB: "core.ttfb",
  LOAD_START: "core.loadstart",
  LOAD_RESPONSE_HEADERS: "core.loadresponseheaders",
  LOAD_COMPLETE: "core.loadcomplete",
  LOAD_RETRY: "core.loadretry",
  SOURCEBUFFER_CREATED: "core.sourcebuffercreated",
  MEDIASOURCE_OPENED: "core.mediasourceopened",
  ANALYZE_DURATION_EXCEEDED: "core.analyzedurationexceeded",
  REMOVE_BUFFER: "core.removebuffer",
  BUFFEREOS: "core.buffereos",
  KEYFRAME: "core.keyframe",
  CHASEFRAME: "core.chaseframe",
  METADATA_PARSED: "core.metadataparsed",
  SEI: "core.sei",
  SEI_IN_TIME: "core.seiintime",
  FLV_SCRIPT_DATA: "core.flvscriptdata",
  LOWDECODE: "core.lowdecode",
  SWITCH_URL_SUCCESS: "core.switchurlsuccess",
  SWITCH_URL_FAILED: "core.switchurlfailed",
  SPEED: "core.speed",
  HLS_MANIFEST_LOADED: "core.hlsmanifestloaded",
  HLS_LEVEL_LOADED: "core.hlslevelloaded",
  DEMUXED_TRACK: "core.demuxedtrack",
  STREAM_EXCEPTION: "core.streamexception",
  LARGE_AV_FIRST_FRAME_GAP_DETECT: "LARGE_AV_FIRST_FRAME_GAP_DETECT",
  LARGE_VIDEO_DTS_GAP_DETECT: "LARGE_VIDEO_DTS_GAP_DETECT",
  LARGE_AUDIO_DTS_GAP_DETECT: "LARGE_AUDIO_DTS_GAP_DETECT",
  AUDIO_GAP_DETECT: "AUDIO_GAP_DETECT",
  AUDIO_OVERLAP_DETECT: "AUDIO_OVERLAP_DETECT",
  MAX_DTS_DELTA_WITH_NEXT_SEGMENT_DETECT: "MAX_DTS_DELTA_WITH_NEXT_SEGMENT_DETECT",
  REAL_TIME_SPEED: "real_time_speed"
};

// node_modules/xgplayer-streaming-shared/es/net/fetch.js
var import_eventemitter3 = __toESM(require_eventemitter3());
var CACHESIZE = 2 * 1024 * 1024;
var FetchLoader = function(_EventEmitter) {
  _inherits3(FetchLoader2, _EventEmitter);
  var _super = _createSuper3(FetchLoader2);
  function FetchLoader2() {
    var _this;
    _classCallCheck3(this, FetchLoader2);
    _this = _super.call(this);
    _defineProperty3(_assertThisInitialized3(_this), "_abortController", null);
    _defineProperty3(_assertThisInitialized3(_this), "_timeoutTimer", null);
    _defineProperty3(_assertThisInitialized3(_this), "_reader", null);
    _defineProperty3(_assertThisInitialized3(_this), "_response", null);
    _defineProperty3(_assertThisInitialized3(_this), "_aborted", false);
    _defineProperty3(_assertThisInitialized3(_this), "_index", -1);
    _defineProperty3(_assertThisInitialized3(_this), "_range", null);
    _defineProperty3(_assertThisInitialized3(_this), "_receivedLength", 0);
    _defineProperty3(_assertThisInitialized3(_this), "_running", false);
    _defineProperty3(_assertThisInitialized3(_this), "_logger", null);
    _defineProperty3(_assertThisInitialized3(_this), "_vid", "");
    _defineProperty3(_assertThisInitialized3(_this), "_onProcessMinLen", 0);
    _defineProperty3(_assertThisInitialized3(_this), "_onCancel", null);
    _defineProperty3(_assertThisInitialized3(_this), "_priOptions", null);
    return _this;
  }
  _createClass3(FetchLoader2, [{
    key: "load",
    value: function load(_ref) {
      var _this$_abortControlle, _this2 = this;
      var url = _ref.url, vid = _ref.vid, timeout = _ref.timeout, responseType = _ref.responseType, onProgress = _ref.onProgress, index = _ref.index, onTimeout = _ref.onTimeout, onCancel = _ref.onCancel, range = _ref.range, transformResponse = _ref.transformResponse, request = _ref.request, params = _ref.params, logger3 = _ref.logger, method = _ref.method, headers = _ref.headers, body = _ref.body, mode = _ref.mode, credentials = _ref.credentials, cache = _ref.cache, redirect = _ref.redirect, referrer = _ref.referrer, referrerPolicy = _ref.referrerPolicy, onProcessMinLen = _ref.onProcessMinLen, priOptions = _ref.priOptions;
      this._logger = logger3;
      this._aborted = false;
      this._onProcessMinLen = onProcessMinLen;
      this._onCancel = onCancel;
      this._abortController = typeof AbortController !== "undefined" && new AbortController();
      this._running = true;
      this._index = index;
      this._range = range || [0, 0];
      this._vid = vid || url;
      this._priOptions = priOptions || {};
      var init = {
        method,
        headers,
        body,
        mode,
        credentials,
        cache,
        redirect,
        referrer,
        referrerPolicy,
        signal: (_this$_abortControlle = this._abortController) === null || _this$_abortControlle === void 0 ? void 0 : _this$_abortControlle.signal
      };
      var isTimeout = false;
      clearTimeout(this._timeoutTimer);
      url = setUrlParams(url, params);
      var rangeValue = getRangeValue(range);
      if (rangeValue) {
        if (request) {
          headers = request.headers;
        } else {
          headers = init.headers = init.headers || (Headers ? new Headers() : {});
        }
        if (Headers && headers instanceof Headers) {
          headers.append("Range", rangeValue);
        } else {
          headers.Range = rangeValue;
        }
      }
      if (timeout) {
        this._timeoutTimer = setTimeout(function() {
          isTimeout = true;
          _this2.cancel();
          if (onTimeout) {
            var error = new NetError(url, init, null, "timeout");
            error.isTimeout = true;
            onTimeout(error, {
              index: _this2._index,
              range: _this2._range,
              vid: _this2._vid,
              priOptions: _this2._priOptions
            });
          }
        }, timeout);
      }
      var startTime = Date.now();
      this._logger.debug("[fetch load start], index,", index, ",range,", range);
      return new Promise(function(resolve, reject) {
        fetch(request || url, request ? void 0 : init).then(function() {
          var _ref2 = _asyncToGenerator2(_regeneratorRuntime2().mark(function _callee(response) {
            var firstByteTime, data, costTime, speed;
            return _regeneratorRuntime2().wrap(function _callee$(_context) {
              while (1)
                switch (_context.prev = _context.next) {
                  case 0:
                    clearTimeout(_this2._timeoutTimer);
                    _this2._response = response;
                    if (!(_this2._aborted || !_this2._running)) {
                      _context.next = 4;
                      break;
                    }
                    return _context.abrupt("return");
                  case 4:
                    if (transformResponse) {
                      response = transformResponse(response, url) || response;
                    }
                    if (response.ok) {
                      _context.next = 7;
                      break;
                    }
                    throw new NetError(url, init, response, "bad network response");
                  case 7:
                    firstByteTime = Date.now();
                    if (!(responseType === ResponseType.TEXT)) {
                      _context.next = 15;
                      break;
                    }
                    _context.next = 11;
                    return response.text();
                  case 11:
                    data = _context.sent;
                    _this2._running = false;
                    _context.next = 37;
                    break;
                  case 15:
                    if (!(responseType === ResponseType.JSON)) {
                      _context.next = 22;
                      break;
                    }
                    _context.next = 18;
                    return response.json();
                  case 18:
                    data = _context.sent;
                    _this2._running = false;
                    _context.next = 37;
                    break;
                  case 22:
                    if (!onProgress) {
                      _context.next = 29;
                      break;
                    }
                    _this2.resolve = resolve;
                    _this2.reject = reject;
                    _this2._loadChunk(response, onProgress, startTime, firstByteTime);
                    return _context.abrupt("return");
                  case 29:
                    _context.next = 31;
                    return response.arrayBuffer();
                  case 31:
                    data = _context.sent;
                    data = new Uint8Array(data);
                    _this2._running = false;
                    costTime = Date.now() - startTime;
                    speed = calculateSpeed(data.byteLength, costTime);
                    _this2.emit(EVENT.REAL_TIME_SPEED, {
                      speed,
                      len: data.byteLength,
                      time: costTime,
                      vid: _this2._vid,
                      index: _this2._index,
                      range: _this2._range,
                      priOptions: _this2._priOptions
                    });
                  case 37:
                    _this2._logger.debug("[fetch load end], index,", index, ",range,", range);
                    resolve(createResponse(data, true, response, response.headers.get("Content-Length"), response.headers.get("age"), startTime, firstByteTime, index, range, _this2._vid, _this2._priOptions));
                  case 39:
                  case "end":
                    return _context.stop();
                }
            }, _callee);
          }));
          return function(_x) {
            return _ref2.apply(this, arguments);
          };
        }()).catch(function(error) {
          var _error;
          clearTimeout(_this2._timeoutTimer);
          _this2._running = false;
          if (_this2._aborted && !isTimeout)
            return;
          error = error instanceof NetError ? error : new NetError(url, init, null, (_error = error) === null || _error === void 0 ? void 0 : _error.message);
          error.startTime = startTime;
          error.endTime = Date.now();
          error.isTimeout = isTimeout;
          error.options = {
            index: _this2._index,
            range: _this2._range,
            vid: _this2._vid,
            priOptions: _this2._priOptions
          };
          reject(error);
        });
      });
    }
  }, {
    key: "cancel",
    value: function() {
      var _cancel = _asyncToGenerator2(_regeneratorRuntime2().mark(function _callee2() {
        return _regeneratorRuntime2().wrap(function _callee2$(_context2) {
          while (1)
            switch (_context2.prev = _context2.next) {
              case 0:
                if (!this._aborted) {
                  _context2.next = 2;
                  break;
                }
                return _context2.abrupt("return");
              case 2:
                this._aborted = true;
                this._running = false;
                if (!this._response) {
                  _context2.next = 14;
                  break;
                }
                _context2.prev = 5;
                if (!this._reader) {
                  _context2.next = 9;
                  break;
                }
                _context2.next = 9;
                return this._reader.cancel();
              case 9:
                _context2.next = 13;
                break;
              case 11:
                _context2.prev = 11;
                _context2.t0 = _context2["catch"](5);
              case 13:
                this._response = this._reader = null;
              case 14:
                if (this._abortController) {
                  try {
                    this._abortController.abort();
                  } catch (error) {
                  }
                  this._abortController = null;
                }
                if (this._onCancel) {
                  this._onCancel({
                    index: this._index,
                    range: this._range,
                    vid: this._vid,
                    priOptions: this._priOptions
                  });
                }
              case 16:
              case "end":
                return _context2.stop();
            }
        }, _callee2, this, [[5, 11]]);
      }));
      function cancel() {
        return _cancel.apply(this, arguments);
      }
      return cancel;
    }()
  }, {
    key: "_loadChunk",
    value: function _loadChunk(response, onProgress, st, firstByteTime) {
      var _this3 = this;
      if (!response.body || !response.body.getReader) {
        this._running = false;
        var err = new NetError(response.url, "", response, "onProgress of bad response.body.getReader");
        err.options = {
          index: this._index,
          range: this._range,
          vid: this._vid,
          priOptions: this._priOptions
        };
        this.reject(err);
        return;
      }
      if (this._onProcessMinLen > 0) {
        this._cache = new Uint8Array(CACHESIZE);
        this._writeIdx = 0;
      }
      var reader = this._reader = response.body.getReader();
      var data;
      var startTime;
      var endTime;
      var pump = function() {
        var _ref3 = _asyncToGenerator2(_regeneratorRuntime2().mark(function _callee3() {
          var _this3$_range;
          var startRange, startByte, curLen, retData, temp, costTime, speed;
          return _regeneratorRuntime2().wrap(function _callee3$(_context3) {
            while (1)
              switch (_context3.prev = _context3.next) {
                case 0:
                  startTime = Date.now();
                  _context3.prev = 1;
                  _context3.next = 4;
                  return reader.read();
                case 4:
                  data = _context3.sent;
                  endTime = Date.now();
                  _context3.next = 13;
                  break;
                case 8:
                  _context3.prev = 8;
                  _context3.t0 = _context3["catch"](1);
                  endTime = Date.now();
                  if (!_this3._aborted) {
                    _this3._running = false;
                    _context3.t0.options = {
                      index: _this3._index,
                      range: _this3._range,
                      vid: _this3._vid,
                      priOptions: _this3._priOptions
                    };
                    _this3.reject(_context3.t0);
                  }
                  return _context3.abrupt("return");
                case 13:
                  startRange = ((_this3$_range = _this3._range) === null || _this3$_range === void 0 ? void 0 : _this3$_range.length) > 0 ? _this3._range[0] : 0;
                  startByte = startRange + _this3._receivedLength;
                  if (!_this3._aborted) {
                    _context3.next = 19;
                    break;
                  }
                  _this3._running = false;
                  onProgress(void 0, false, {
                    range: [startByte, startByte],
                    vid: _this3._vid,
                    index: _this3._index,
                    startTime,
                    endTime,
                    st,
                    firstByteTime,
                    priOptions: _this3._priOptions
                  }, response);
                  return _context3.abrupt("return");
                case 19:
                  curLen = data.value ? data.value.byteLength : 0;
                  _this3._receivedLength += curLen;
                  _this3._logger.debug("【fetchLoader,onProgress call】,task,", _this3._range, ", start,", startByte, ", end,", startRange + _this3._receivedLength, ", done,", data.done);
                  if (_this3._onProcessMinLen > 0) {
                    if (_this3._writeIdx + curLen >= _this3._onProcessMinLen || data.done) {
                      retData = new Uint8Array(_this3._writeIdx + curLen);
                      retData.set(_this3._cache.slice(0, _this3._writeIdx), 0);
                      curLen > 0 && retData.set(data.value, _this3._writeIdx);
                      _this3._writeIdx = 0;
                      _this3._logger.debug("【fetchLoader,onProgress enough】,done,", data.done, ",len,", retData.byteLength, ", writeIdx,", _this3._writeIdx);
                    } else {
                      if (curLen > 0 && _this3._writeIdx + curLen < CACHESIZE) {
                        _this3._cache.set(data.value, _this3._writeIdx);
                        _this3._writeIdx += curLen;
                        _this3._logger.debug("【fetchLoader,onProgress cache】,len,", curLen, ", writeIdx,", _this3._writeIdx);
                      } else if (curLen > 0) {
                        temp = new Uint8Array(_this3._writeIdx + curLen + 2048);
                        _this3._logger.debug("【fetchLoader,onProgress extra start】,size,", _this3._writeIdx + curLen + 2048, ", datalen,", curLen, ", writeIdx,", _this3._writeIdx);
                        temp.set(_this3._cache.slice(0, _this3._writeIdx), 0);
                        curLen > 0 && temp.set(data.value, _this3._writeIdx);
                        _this3._writeIdx += curLen;
                        delete _this3._cache;
                        _this3._cache = temp;
                        _this3._logger.debug("【fetchLoader,onProgress extra end】,len,", curLen, ", writeIdx,", _this3._writeIdx);
                      }
                    }
                  } else {
                    retData = data.value;
                  }
                  if (retData && retData.byteLength > 0 || data.done) {
                    onProgress(retData, data.done, {
                      range: [_this3._range[0] + _this3._receivedLength - (retData ? retData.byteLength : 0), _this3._range[0] + _this3._receivedLength],
                      vid: _this3._vid,
                      index: _this3._index,
                      startTime,
                      endTime,
                      st,
                      firstByteTime,
                      priOptions: _this3._priOptions
                    }, response);
                  }
                  if (!data.done) {
                    pump();
                  } else {
                    costTime = Date.now() - st;
                    speed = calculateSpeed(_this3._receivedLength, costTime);
                    _this3.emit(EVENT.REAL_TIME_SPEED, {
                      speed,
                      len: _this3._receivedLength,
                      time: costTime,
                      vid: _this3._vid,
                      index: _this3._index,
                      range: _this3._range,
                      priOptions: _this3._priOptions
                    });
                    _this3._running = false;
                    _this3._logger.debug("[fetchLoader onProgress end],task,", _this3._range, ",done,", data.done);
                    _this3.resolve(createResponse(data, true, response, response.headers.get("Content-Length"), response.headers.get("age"), st, firstByteTime, _this3._index, _this3._range, _this3._vid, _this3._priOptions));
                  }
                case 25:
                case "end":
                  return _context3.stop();
              }
          }, _callee3, null, [[1, 8]]);
        }));
        return function pump2() {
          return _ref3.apply(this, arguments);
        };
      }();
      pump();
    }
  }, {
    key: "receiveLen",
    get: function get() {
      return this._receivedLength;
    }
  }, {
    key: "running",
    get: function get() {
      return this._running;
    },
    set: function set(status) {
      this._running = status;
    }
  }], [{
    key: "isSupported",
    value: function isSupported() {
      return !!(typeof fetch !== "undefined");
    }
  }]);
  return FetchLoader2;
}(import_eventemitter3.default);

// node_modules/xgplayer-streaming-shared/es/net/config.js
function getConfig(cfg) {
  return _objectSpread22({
    loaderType: LoaderType.FETCH,
    retry: 0,
    retryDelay: 0,
    timeout: 0,
    request: null,
    onTimeout: void 0,
    onProgress: void 0,
    onRetryError: void 0,
    transformRequest: void 0,
    transformResponse: void 0,
    transformError: void 0,
    responseType: ResponseType.TEXT,
    range: void 0,
    url: "",
    params: void 0,
    method: "GET",
    headers: {},
    body: void 0,
    mode: void 0,
    credentials: void 0,
    cache: void 0,
    redirect: void 0,
    referrer: void 0,
    referrerPolicy: void 0,
    integrity: void 0,
    onProcessMinLen: 0
  }, cfg);
}

// node_modules/xgplayer-streaming-shared/es/net/xhr.js
var import_eventemitter32 = __toESM(require_eventemitter3());
var XhrLoader = function(_EventEmitter) {
  _inherits3(XhrLoader2, _EventEmitter);
  var _super = _createSuper3(XhrLoader2);
  function XhrLoader2() {
    var _this;
    _classCallCheck3(this, XhrLoader2);
    _this = _super.call(this);
    _defineProperty3(_assertThisInitialized3(_this), "_xhr", null);
    _defineProperty3(_assertThisInitialized3(_this), "_aborted", false);
    _defineProperty3(_assertThisInitialized3(_this), "_timeoutTimer", null);
    _defineProperty3(_assertThisInitialized3(_this), "_range", null);
    _defineProperty3(_assertThisInitialized3(_this), "_receivedLength", 0);
    _defineProperty3(_assertThisInitialized3(_this), "_url", null);
    _defineProperty3(_assertThisInitialized3(_this), "_onProgress", null);
    _defineProperty3(_assertThisInitialized3(_this), "_index", -1);
    _defineProperty3(_assertThisInitialized3(_this), "_headers", null);
    _defineProperty3(_assertThisInitialized3(_this), "_currentChunkSizeKB", 384);
    _defineProperty3(_assertThisInitialized3(_this), "_timeout", null);
    _defineProperty3(_assertThisInitialized3(_this), "_xhr", null);
    _defineProperty3(_assertThisInitialized3(_this), "_withCredentials", null);
    _defineProperty3(_assertThisInitialized3(_this), "_startTime", -1);
    _defineProperty3(_assertThisInitialized3(_this), "_loadCompleteResolve", null);
    _defineProperty3(_assertThisInitialized3(_this), "_loadCompleteReject", null);
    _defineProperty3(_assertThisInitialized3(_this), "_runing", false);
    _defineProperty3(_assertThisInitialized3(_this), "_logger", false);
    _defineProperty3(_assertThisInitialized3(_this), "_vid", "");
    _defineProperty3(_assertThisInitialized3(_this), "_responseType", void 0);
    _defineProperty3(_assertThisInitialized3(_this), "_credentials", void 0);
    _defineProperty3(_assertThisInitialized3(_this), "_method", void 0);
    _defineProperty3(_assertThisInitialized3(_this), "_transformResponse", void 0);
    _defineProperty3(_assertThisInitialized3(_this), "_firstRtt", void 0);
    _defineProperty3(_assertThisInitialized3(_this), "_onCancel", null);
    _defineProperty3(_assertThisInitialized3(_this), "_priOptions", null);
    return _this;
  }
  _createClass3(XhrLoader2, [{
    key: "load",
    value: function load(req) {
      var _this2 = this;
      clearTimeout(this._timeoutTimer);
      this._logger = req.logger;
      this._range = req.range;
      this._onProgress = req.onProgress;
      this._index = req.index;
      this._headers = req.headers;
      this._withCredentials = req.credentials === "include" || req.credentials === "same-origin";
      this._body = req.body || null;
      req.method && (this._method = req.method);
      this._timeout = req.timeout || null;
      this._runing = true;
      this._vid = req.vid || req.url;
      this._responseType = req.responseType;
      this._firstRtt = -1;
      this._onTimeout = req.onTimeout;
      this._onCancel = req.onCancel;
      this._request = req.request;
      this._priOptions = req.priOptions || {};
      this._logger.debug("【xhrLoader task】, range", this._range);
      this._url = setUrlParams(req.url, req.params);
      var startTime = Date.now();
      return new Promise(function(resolve, reject) {
        _this2._loadCompleteResolve = resolve;
        _this2._loadCompleteReject = reject;
        _this2._startLoad();
      }).catch(function(error) {
        clearTimeout(_this2._timeoutTimer);
        _this2._runing = false;
        if (_this2._aborted)
          return;
        error = error instanceof NetError ? error : new NetError(_this2._url, _this2._request);
        error.startTime = startTime;
        error.endTime = Date.now();
        error.options = {
          index: _this2._index,
          vid: _this2._vid,
          priOptions: _this2._priOptions
        };
        throw error;
      });
    }
  }, {
    key: "_startLoad",
    value: function _startLoad() {
      var range = null;
      if (this._responseType === ResponseType.ARRAY_BUFFER && this._range && this._range.length > 1) {
        if (this._onProgress) {
          this._firstRtt = -1;
          var chunkSize = this._currentChunkSizeKB * 1024;
          var from = this._range[0] + this._receivedLength;
          var to = this._range[1];
          if (chunkSize < this._range[1] - from) {
            to = from + chunkSize;
          }
          range = [from, to];
          this._logger.debug("[xhr_loader->],tast :", this._range, ", SubRange, ", range);
        } else {
          range = this._range;
          this._logger.debug("[xhr_loader->],tast :", this._range, ", allRange, ", range);
        }
      }
      this._internalOpen(range);
    }
  }, {
    key: "_internalOpen",
    value: function _internalOpen(range) {
      var _this3 = this;
      try {
        this._startTime = Date.now();
        var xhr = this._xhr = new XMLHttpRequest();
        xhr.open(this._method || "GET", this._url, true);
        xhr.responseType = this._responseType;
        this._timeout && (xhr.timeout = this._timeout);
        xhr.withCredentials = this._withCredentials;
        xhr.onload = this._onLoad.bind(this);
        xhr.onreadystatechange = this._onReadyStatechange.bind(this);
        xhr.onerror = function(errorEvent) {
          var _errorEvent$currentTa, _errorEvent$currentTa2, _errorEvent$currentTa3;
          _this3._running = false;
          var error = new NetError(_this3._url, _this3._request, errorEvent === null || errorEvent === void 0 ? void 0 : (_errorEvent$currentTa = errorEvent.currentTarget) === null || _errorEvent$currentTa === void 0 ? void 0 : _errorEvent$currentTa.response, "xhr.onerror.status:" + (errorEvent === null || errorEvent === void 0 ? void 0 : (_errorEvent$currentTa2 = errorEvent.currentTarget) === null || _errorEvent$currentTa2 === void 0 ? void 0 : _errorEvent$currentTa2.status) + ",statusText," + (errorEvent === null || errorEvent === void 0 ? void 0 : (_errorEvent$currentTa3 = errorEvent.currentTarget) === null || _errorEvent$currentTa3 === void 0 ? void 0 : _errorEvent$currentTa3.statusText));
          error.options = {
            index: _this3._index,
            range: _this3._range,
            vid: _this3._vid,
            priOptions: _this3._priOptions
          };
          _this3._loadCompleteReject(error);
        };
        xhr.ontimeout = function(event) {
          _this3.cancel();
          var error = new NetError(_this3._url, _this3._request, {
            status: 408
          }, "timeout");
          if (_this3._onTimeout) {
            error.isTimeout = true;
            _this3._onTimeout(error, {
              index: _this3._index,
              range: _this3._range,
              vid: _this3._vid,
              priOptions: _this3._priOptions
            });
          }
          error.options = {
            index: _this3._index,
            range: _this3._range,
            vid: _this3._vid,
            priOptions: _this3._priOptions
          };
          _this3._loadCompleteReject(error);
        };
        var headers = this._headers || {};
        var rangeValue = getRangeValue(range);
        if (rangeValue) {
          headers.Range = rangeValue;
        }
        if (headers) {
          Object.keys(headers).forEach(function(k) {
            xhr.setRequestHeader(k, headers[k]);
          });
        }
        this._logger.debug("[xhr.send->] tast,", this._range, ",load sub range, ", range);
        xhr.send(this._body);
      } catch (e) {
        e.options = {
          index: this._index,
          range,
          vid: this._vid,
          priOptions: this._priOptions
        };
        this._loadCompleteReject(e);
      }
    }
  }, {
    key: "_onReadyStatechange",
    value: function _onReadyStatechange(e) {
      var xhr = e.target;
      if (xhr.readyState === 2) {
        this._firstRtt < 0 && (this._firstRtt = Date.now());
      }
    }
  }, {
    key: "_onLoad",
    value: function _onLoad(e) {
      var _this$_range;
      var status = e.target.status;
      if (status < 200 || status > 299) {
        var error = new NetError(this._url, null, _objectSpread22(_objectSpread22({}, e.target.response), {}, {
          status
        }), "bad response,status:" + status);
        error.options = {
          index: this._index,
          range: this._range,
          vid: this._vid,
          priOptions: this._priOptions
        };
        return this._loadCompleteReject(error);
      }
      var data = null;
      var done = false;
      var byteStart;
      var startRange = ((_this$_range = this._range) === null || _this$_range === void 0 ? void 0 : _this$_range.length) > 0 ? this._range[0] : 0;
      if (this._responseType === ResponseType.ARRAY_BUFFER) {
        var _this$_range2;
        var chunk = new Uint8Array(e.target.response);
        byteStart = startRange + this._receivedLength;
        if (chunk && chunk.byteLength > 0) {
          this._receivedLength += chunk.byteLength;
          var costTime = Date.now() - this._startTime;
          var speed = calculateSpeed(this._receivedLength, costTime);
          this.emit(EVENT.REAL_TIME_SPEED, {
            speed,
            len: this._receivedLength,
            time: costTime,
            vid: this._vid,
            index: this._index,
            range: [byteStart, startRange + this._receivedLength],
            priOptions: this._priOptions
          });
        }
        data = chunk;
        if (((_this$_range2 = this._range) === null || _this$_range2 === void 0 ? void 0 : _this$_range2.length) > 1 && this._range[1] && this._receivedLength < this._range[1] - this._range[0]) {
          done = false;
        } else {
          done = true;
        }
        this._logger.debug("[xhr load done->], tast :", this._range, ", start", byteStart, "end ", startRange + this._receivedLength, ",dataLen,", chunk ? chunk.byteLength : 0, ",receivedLength", this._receivedLength, ",index,", this._index, ", done,", done);
      } else {
        done = true;
        data = e.target.response;
      }
      var response = {
        ok: status >= 200 && status < 300,
        status,
        statusText: this._xhr.statusText,
        url: this._xhr.responseURL,
        headers: this._getHeaders(this._xhr),
        body: this._xhr.response
      };
      if (this._transformResponse) {
        response = this._transformResponse(response, this._url) || response;
      }
      if (this._onProgress) {
        this._onProgress(data, done, {
          index: this._index,
          vid: this._vid,
          range: [byteStart, startRange + this._receivedLength],
          startTime: this._startTime,
          endTime: Date.now(),
          priOptions: this._priOptions
        }, response);
      }
      if (!done) {
        this._startLoad();
      } else {
        this._runing = false;
        this._loadCompleteResolve && this._loadCompleteResolve(createResponse(this._onProgress ? null : data, done, response, response.headers["content-length"], response.headers.age, this._startTime, this._firstRtt, this._index, this._range, this._vid, this._priOptions));
      }
    }
  }, {
    key: "cancel",
    value: function cancel() {
      if (this._aborted)
        return;
      this._aborted = true;
      this._runing = false;
      _get(_getPrototypeOf3(XhrLoader2.prototype), "removeAllListeners", this).call(this);
      if (this._onCancel) {
        this._onCancel({
          index: this._index,
          range: this._range,
          vid: this._vid,
          priOptions: this._priOptions
        });
      }
      if (this._xhr) {
        return this._xhr.abort();
      }
    }
  }, {
    key: "receiveLen",
    get: function get() {
      return this._receivedLength;
    }
  }, {
    key: "running",
    get: function get() {
      return this._running;
    },
    set: function set(status) {
      this._running = status;
    }
  }, {
    key: "_getHeaders",
    value: function _getHeaders(xhr) {
      var headerLines = xhr.getAllResponseHeaders().trim().split("\r\n");
      var headers = {};
      var _iterator = _createForOfIteratorHelper(headerLines), _step;
      try {
        for (_iterator.s(); !(_step = _iterator.n()).done; ) {
          var header = _step.value;
          var parts = header.split(": ");
          headers[parts[0].toLowerCase()] = parts.slice(1).join(": ");
        }
      } catch (err) {
        _iterator.e(err);
      } finally {
        _iterator.f();
      }
      return headers;
    }
  }], [{
    key: "isSupported",
    value: function isSupported() {
      return typeof XMLHttpRequest !== "undefined";
    }
  }]);
  return XhrLoader2;
}(import_eventemitter32.default);

// node_modules/xgplayer-streaming-shared/es/net/task.js
var _excluded = ["retry", "retryDelay", "onRetryError", "transformError"];
var Task = function() {
  function Task2(type, config) {
    _classCallCheck3(this, Task2);
    this.promise = createPublicPromise();
    this.alive = !!config.onProgress;
    !config.logger && (config.logger = new Logger3("Loader"));
    this._loaderType = type;
    this._loader = type === LoaderType.FETCH && typeof fetch !== "undefined" ? new FetchLoader() : new XhrLoader();
    this._config = config;
    this._retryCount = 0;
    this._retryTimer = null;
    this._canceled = false;
    this._retryCheckFunc = config.retryCheckFunc;
    this._logger = config.logger;
  }
  _createClass3(Task2, [{
    key: "exec",
    value: function exec() {
      var _this = this;
      var _this$_config = this._config, retry = _this$_config.retry, retryDelay = _this$_config.retryDelay, onRetryError = _this$_config.onRetryError, transformError = _this$_config.transformError, rest = _objectWithoutProperties(_this$_config, _excluded);
      var request = function() {
        var _ref = _asyncToGenerator2(_regeneratorRuntime2().mark(function _callee() {
          var response, error, isRetry;
          return _regeneratorRuntime2().wrap(function _callee$(_context) {
            while (1)
              switch (_context.prev = _context.next) {
                case 0:
                  _context.prev = 0;
                  _context.next = 3;
                  return _this._loader.load(rest);
                case 3:
                  response = _context.sent;
                  _this.promise.resolve(response);
                  _context.next = 27;
                  break;
                case 7:
                  _context.prev = 7;
                  _context.t0 = _context["catch"](0);
                  _this._loader.running = false;
                  _this._logger.debug("[task request catch err]", _context.t0);
                  if (!_this._canceled) {
                    _context.next = 13;
                    break;
                  }
                  return _context.abrupt("return");
                case 13:
                  _context.t0.loaderType = _this._loaderType;
                  _context.t0.retryCount = _this._retryCount;
                  error = _context.t0;
                  if (transformError) {
                    error = transformError(error) || error;
                  }
                  if (onRetryError && _this._retryCount > 0)
                    onRetryError(error, _this._retryCount, {
                      index: rest.index,
                      vid: rest.vid,
                      range: rest.range,
                      priOptions: rest.priOptions
                    });
                  _this._retryCount++;
                  isRetry = true;
                  if (_this._retryCheckFunc) {
                    isRetry = _this._retryCheckFunc(_context.t0);
                  }
                  if (!(isRetry && _this._retryCount <= retry)) {
                    _context.next = 26;
                    break;
                  }
                  clearTimeout(_this._retryTimer);
                  _this._logger.debug("[task request setTimeout],retry", _this._retryCount, ",retry range,", rest.range);
                  _this._retryTimer = setTimeout(request, retryDelay);
                  return _context.abrupt("return");
                case 26:
                  _this.promise.reject(error);
                case 27:
                case "end":
                  return _context.stop();
              }
          }, _callee, null, [[0, 7]]);
        }));
        return function request2() {
          return _ref.apply(this, arguments);
        };
      }();
      request();
      return this.promise;
    }
  }, {
    key: "cancel",
    value: function() {
      var _cancel = _asyncToGenerator2(_regeneratorRuntime2().mark(function _callee2() {
        return _regeneratorRuntime2().wrap(function _callee2$(_context2) {
          while (1)
            switch (_context2.prev = _context2.next) {
              case 0:
                clearTimeout(this._retryTimer);
                this._canceled = true;
                this._loader.running = false;
                return _context2.abrupt("return", this._loader.cancel());
              case 4:
              case "end":
                return _context2.stop();
            }
        }, _callee2, this);
      }));
      function cancel() {
        return _cancel.apply(this, arguments);
      }
      return cancel;
    }()
  }, {
    key: "running",
    get: function get() {
      return this._loader && this._loader.running;
    }
  }, {
    key: "loader",
    get: function get() {
      return this._loader;
    }
  }]);
  return Task2;
}();

// node_modules/xgplayer-streaming-shared/es/streaming-helper.js
function concatUint8Array2() {
  for (var _len = arguments.length, arr = new Array(_len), _key = 0; _key < _len; _key++) {
    arr[_key] = arguments[_key];
  }
  arr = arr.filter(Boolean);
  if (arr.length < 2)
    return arr[0];
  var data = new Uint8Array(arr.reduce(function(p, c) {
    return p + c.byteLength;
  }, 0));
  var prevLen = 0;
  arr.forEach(function(d2) {
    data.set(d2, prevLen);
    prevLen += d2.byteLength;
  });
  return data;
}
function sleep() {
  var t = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : 0;
  return new Promise(function(resolve) {
    return setTimeout(resolve, t);
  });
}

// node_modules/xgplayer-streaming-shared/es/net/index.js
var import_eventemitter33 = __toESM(require_eventemitter3());
var NetLoader = function(_EventEmitter) {
  _inherits3(NetLoader2, _EventEmitter);
  var _super = _createSuper3(NetLoader2);
  function NetLoader2(cfg) {
    var _this;
    _classCallCheck3(this, NetLoader2);
    _this = _super.call(this, cfg);
    _defineProperty3(_assertThisInitialized3(_this), "type", LoaderType.FETCH);
    _defineProperty3(_assertThisInitialized3(_this), "_queue", []);
    _defineProperty3(_assertThisInitialized3(_this), "_alive", []);
    _defineProperty3(_assertThisInitialized3(_this), "_currentTask", null);
    _defineProperty3(_assertThisInitialized3(_this), "_finnalUrl", "");
    _defineProperty3(_assertThisInitialized3(_this), "_config", void 0);
    _this._config = getConfig(cfg);
    if (_this._config.loaderType === LoaderType.XHR || !FetchLoader.isSupported()) {
      _this.type = LoaderType.XHR;
    }
    _this.log = cfg.logger;
    return _this;
  }
  _createClass3(NetLoader2, [{
    key: "isFetch",
    value: function isFetch() {
      return this.type === LoaderType.FETCH;
    }
  }, {
    key: "load",
    value: function load(url) {
      var _this2 = this;
      var config = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
      if (typeof url === "string" || !url) {
        config.url = url || config.url || this._config.url;
      } else {
        config = url;
      }
      config = Object.assign({}, this._config, config);
      if (config.params)
        config.params = Object.assign({}, config.params);
      if (config.headers && isPlainObject(config.headers))
        config.headers = Object.assign({}, config.headers);
      if (config.body && isPlainObject(config.body))
        config.body = Object.assign({}, config.body);
      if (config.transformRequest) {
        config = config.transformRequest(config) || config;
      }
      config.logger = this.log;
      var task = new Task(this.type, config);
      task.loader.on(EVENT.REAL_TIME_SPEED, function(data) {
        _this2.emit(EVENT.REAL_TIME_SPEED, data);
      });
      this._queue.push(task);
      if (this._queue.length === 1 && (!this._currentTask || !this._currentTask.running)) {
        this._processTask();
      }
      return task.promise;
    }
  }, {
    key: "cancel",
    value: function() {
      var _cancel = _asyncToGenerator2(_regeneratorRuntime2().mark(function _callee() {
        var cancels;
        return _regeneratorRuntime2().wrap(function _callee$(_context) {
          while (1)
            switch (_context.prev = _context.next) {
              case 0:
                cancels = this._queue.map(function(t) {
                  return t.cancel();
                }).concat(this._alive.map(function(t) {
                  return t.cancel();
                }));
                if (this._currentTask) {
                  cancels.push(this._currentTask.cancel());
                }
                this._queue = [];
                this._alive = [];
                _context.next = 6;
                return Promise.all(cancels);
              case 6:
                _context.next = 8;
                return sleep();
              case 8:
              case "end":
                return _context.stop();
            }
        }, _callee, this);
      }));
      function cancel() {
        return _cancel.apply(this, arguments);
      }
      return cancel;
    }()
  }, {
    key: "_processTask",
    value: function _processTask() {
      var _this3 = this;
      this._currentTask = this._queue.shift();
      if (!this._currentTask)
        return;
      if (this._currentTask.alive) {
        this._alive.push(this._currentTask);
      }
      var req = this._currentTask.exec().catch(function(e) {
      });
      if (!(req && typeof req.finally === "function"))
        return;
      req.finally(function() {
        var _this3$_currentTask, _this3$_alive;
        if ((_this3$_currentTask = _this3._currentTask) !== null && _this3$_currentTask !== void 0 && _this3$_currentTask.alive && ((_this3$_alive = _this3._alive) === null || _this3$_alive === void 0 ? void 0 : _this3$_alive.length) > 0) {
          _this3._alive = _this3._alive.filter(function(task) {
            return task && task !== _this3._currentTask;
          });
        }
        _this3._processTask();
      });
    }
  }], [{
    key: "isFetchSupport",
    value: function isFetchSupport() {
      return FetchLoader.isSupported();
    }
  }]);
  return NetLoader2;
}(import_eventemitter33.default);

// node_modules/xgplayer-streaming-shared/es/services/gap.js
var GapService = function() {
  function GapService2() {
    _classCallCheck3(this, GapService2);
    _defineProperty3(this, "_prevCurrentTime", 0);
  }
  _createClass3(GapService2, [{
    key: "do",
    value: function _do(media) {
      var maxJumpDistance = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 3;
      var isLive = arguments.length > 2 ? arguments[2] : void 0;
      var seekThreshold = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : 1;
      if (!media)
        return;
      var currentTime = media.currentTime;
      var jumpTo = 0;
      if (this._prevCurrentTime === currentTime) {
        var info = Buffer2.info(Buffer2.get(media), currentTime);
        if (!info.buffers.length)
          return;
        if (isLive && info.nextStart || info.nextStart && info.nextStart - currentTime < maxJumpDistance) {
          jumpTo = info.nextStart + 0.1;
        } else if (info.end && info.end - currentTime > seekThreshold && !media.seeking) {
          jumpTo = currentTime + 0.1;
        }
      }
      this._prevCurrentTime = currentTime;
      if (jumpTo && currentTime !== jumpTo) {
        media.currentTime = jumpTo;
      }
    }
  }]);
  return GapService2;
}();

// node_modules/xgplayer-streaming-shared/es/services/sei.js
var SeiService = function() {
  function SeiService2(emitter) {
    var _this = this;
    _classCallCheck3(this, SeiService2);
    _defineProperty3(this, "_seiSet", /* @__PURE__ */ new Set());
    this.emitter = emitter;
    emitter.on(EVENT.SEI, function(sei) {
      if (sei)
        _this._seiSet.add(sei);
    });
  }
  _createClass3(SeiService2, [{
    key: "throw",
    value: function _throw(currentTime, isLive) {
      var _this2 = this;
      if (currentTime === null || currentTime === void 0 || !this._seiSet.size)
        return;
      var min = currentTime - 0.2;
      var max = currentTime + 0.2;
      var toThrow = [];
      this._seiSet.forEach(function(sei) {
        if (sei.time >= min && sei.time <= max) {
          toThrow.push(sei);
        }
      });
      toThrow.forEach(function(sei) {
        _this2._seiSet.delete(sei);
        _this2.emitter.emit(EVENT.SEI_IN_TIME, sei);
      });
      if (!isLive)
        return;
      this._seiSet.forEach(function(s) {
        if (s.time < currentTime - 5) {
          _this2._seiSet.delete(s);
        }
      });
    }
  }, {
    key: "reset",
    value: function reset() {
      this._seiSet.clear();
    }
  }]);
  return SeiService2;
}();

// node_modules/xgplayer-streaming-shared/es/services/bandwidth.js
var BandwidthService = function() {
  function BandwidthService2() {
    _classCallCheck3(this, BandwidthService2);
    _defineProperty3(this, "_chunkSpeeds", []);
    _defineProperty3(this, "_speeds", []);
  }
  _createClass3(BandwidthService2, [{
    key: "addRecord",
    value: function addRecord(totalByte, ms) {
      if (!totalByte || !ms)
        return;
      this._speeds.push(8e3 * totalByte / ms);
      this._speeds = this._speeds.slice(-3);
    }
  }, {
    key: "addChunkRecord",
    value: function addChunkRecord(totalByte, ms) {
      if (!totalByte || !ms)
        return;
      this._chunkSpeeds.push(8e3 * totalByte / ms);
      this._chunkSpeeds = this._chunkSpeeds.slice(-100);
    }
  }, {
    key: "getAvgSpeed",
    value: function getAvgSpeed() {
      if (!this._chunkSpeeds.length && !this._speeds.length)
        return 0;
      if (this._speeds.length) {
        return this._speeds.reduce(function(a, c) {
          return a += c;
        }) / this._speeds.length;
      }
      return this._chunkSpeeds.reduce(function(a, c) {
        return a += c;
      }) / this._chunkSpeeds.length;
    }
  }, {
    key: "getLatestSpeed",
    value: function getLatestSpeed() {
      if (!this._chunkSpeeds.length && !this._speeds.length)
        return 0;
      if (this._speeds.length) {
        return this._speeds[this._speeds.length - 1];
      }
      return this._chunkSpeeds[this._chunkSpeeds.length - 1];
    }
  }, {
    key: "reset",
    value: function reset() {
      this._chunkSpeeds = [];
      this._speeds = [];
    }
  }]);
  return BandwidthService2;
}();

// node_modules/xgplayer-streaming-shared/es/services/stats.js
var import_eventemitter34 = __toESM(require_eventemitter3());
var Stats = function() {
  function Stats2(timescale) {
    _classCallCheck3(this, Stats2);
    _defineProperty3(this, "encodeType", "");
    _defineProperty3(this, "audioCodec", "");
    _defineProperty3(this, "videoCodec", "");
    _defineProperty3(this, "domain", "");
    _defineProperty3(this, "fps", 0);
    _defineProperty3(this, "bitrate", 0);
    _defineProperty3(this, "width", 0);
    _defineProperty3(this, "height", 0);
    _defineProperty3(this, "samplerate", 0);
    _defineProperty3(this, "channelCount", 0);
    _defineProperty3(this, "gop", 0);
    _defineProperty3(this, "_bitsAccumulateSize", 0);
    _defineProperty3(this, "_bitsAccumulateDuration", 0);
    _defineProperty3(this, "_startGopId", -1);
    this._timescale = timescale;
  }
  _createClass3(Stats2, [{
    key: "getStats",
    value: function getStats() {
      return {
        encodeType: this.encodeType,
        audioCodec: this.audioCodec,
        videoCodec: this.videoCodec,
        domain: this.domain,
        fps: this.fps,
        bitrate: this.bitrate,
        width: this.width,
        height: this.height,
        samplerate: this.samplerate,
        channelCount: this.channelCount,
        gop: this.gop
      };
    }
  }, {
    key: "setEncodeType",
    value: function setEncodeType(encode2) {
      this.encodeType = encode2;
    }
  }, {
    key: "setFpsFromScriptData",
    value: function setFpsFromScriptData(_ref) {
      var _data$onMetaData;
      var data = _ref.data;
      var fps = data === null || data === void 0 ? void 0 : (_data$onMetaData = data.onMetaData) === null || _data$onMetaData === void 0 ? void 0 : _data$onMetaData.framerate;
      if (fps && fps > 0 && fps < 100) {
        this.fps = fps;
      }
    }
  }, {
    key: "setVideoMeta",
    value: function setVideoMeta(track) {
      this.width = track.width;
      this.height = track.height;
      this.videoCodec = track.codec;
      this.encodeType = track.codecType;
      if (track.fpsNum && track.fpsDen) {
        var fps = track.fpsNum / track.fpsDen;
        if (fps > 0 && fps < 100) {
          this.fps = fps;
        }
      }
    }
  }, {
    key: "setAudioMeta",
    value: function setAudioMeta(track) {
      this.audioCodec = track.codec;
      this.samplerate = track.sampleRate;
      this.channelCount = track.channelCount;
    }
  }, {
    key: "setDomain",
    value: function setDomain(responseUrl) {
      this.domain = responseUrl.split("/").slice(2, 3)[0];
    }
  }, {
    key: "updateBitrate",
    value: function updateBitrate(samples) {
      var _this = this;
      if (!this.fps || this.fps >= 100) {
        if (samples.length) {
          var duration = samples.reduce(function(a, b) {
            return a += b.duration;
          }, 0) / samples.length;
          this.fps = Math.round(this._timescale / duration);
        }
      }
      samples.forEach(function(sample) {
        if (_this._startGopId === -1) {
          _this._startGopId = sample.gopId;
        }
        if (sample.gopId === _this._startGopId) {
          _this.gop++;
        }
        _this._bitsAccumulateDuration += sample.duration / (_this._timescale / 1e3);
        _this._bitsAccumulateSize += sample.units.reduce(function(a, c) {
          return a += c.length;
        }, 0);
        if (_this._bitsAccumulateDuration >= 1e3) {
          _this.bitrate = _this._bitsAccumulateSize * 8;
          _this._bitsAccumulateDuration = 0;
          _this._bitsAccumulateSize = 0;
        }
      });
    }
  }]);
  return Stats2;
}();
var MediaStatsService = function() {
  function MediaStatsService2(core) {
    var timescale = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 1e3;
    _classCallCheck3(this, MediaStatsService2);
    _defineProperty3(this, "_core", null);
    _defineProperty3(this, "_samples", []);
    this._core = core;
    this._timescale = timescale;
    this._stats = new Stats(timescale);
    this._bindEvents();
  }
  _createClass3(MediaStatsService2, [{
    key: "getStats",
    value: function getStats() {
      var _this$_core, _this$_core2, _this$_core2$speedInf, _this$_core3, _this$_core3$speedInf, _this$_core4, _this$_core4$bufferIn;
      var _ref2 = ((_this$_core = this._core) === null || _this$_core === void 0 ? void 0 : _this$_core.media) || {}, _ref2$currentTime = _ref2.currentTime, currentTime = _ref2$currentTime === void 0 ? 0 : _ref2$currentTime, _ref2$decodeFps = _ref2.decodeFps, decodeFps = _ref2$decodeFps === void 0 ? 0 : _ref2$decodeFps;
      return _objectSpread22(_objectSpread22({}, this._stats.getStats()), {}, {
        downloadSpeed: ((_this$_core2 = this._core) === null || _this$_core2 === void 0 ? void 0 : (_this$_core2$speedInf = _this$_core2.speedInfo) === null || _this$_core2$speedInf === void 0 ? void 0 : _this$_core2$speedInf.call(_this$_core2).speed) || 0,
        avgSpeed: ((_this$_core3 = this._core) === null || _this$_core3 === void 0 ? void 0 : (_this$_core3$speedInf = _this$_core3.speedInfo) === null || _this$_core3$speedInf === void 0 ? void 0 : _this$_core3$speedInf.call(_this$_core3).avgSpeed) || 0,
        currentTime,
        bufferEnd: ((_this$_core4 = this._core) === null || _this$_core4 === void 0 ? void 0 : (_this$_core4$bufferIn = _this$_core4.bufferInfo()) === null || _this$_core4$bufferIn === void 0 ? void 0 : _this$_core4$bufferIn.remaining) || 0,
        decodeFps
      });
    }
  }, {
    key: "_bindEvents",
    value: function _bindEvents() {
      var _this2 = this;
      this._core.on(EVENT.DEMUXED_TRACK, function(_ref3) {
        var videoTrack = _ref3.videoTrack;
        return _this2._stats.updateBitrate(videoTrack.samples);
      });
      this._core.on(EVENT.FLV_SCRIPT_DATA, function(data) {
        _this2._stats.setFpsFromScriptData(data);
      });
      this._core.on(EVENT.METADATA_PARSED, function(e) {
        if (e.type === "video") {
          _this2._stats.setVideoMeta(e.track);
        } else {
          _this2._stats.setAudioMeta(e.track);
        }
      });
      this._core.on(EVENT.TTFB, function(e) {
        _this2._stats.setDomain(e.responseUrl);
      });
    }
  }, {
    key: "reset",
    value: function reset() {
      this._samples = [];
      this._stats = new Stats(this._timescale);
    }
  }]);
  return MediaStatsService2;
}();

// node_modules/xgplayer-mp4/es/error.js
var ERROR_CODES = {
  416: ERR_CODE[ERR.NETWROK_RANGE_NOT_SATISFIABLE],
  403: ERR_CODE[ERR.NETWORK_FORBIDDEN],
  404: ERR_CODE[ERR.NETWORK_NOTFOUND],
  timeout: ERR_CODE[ERR.NETWORK_TIMEOUT],
  "4xx": "".concat(ERR_CODE[ERR.NETWORK], "4XX"),
  "5xx": "".concat(ERR_CODE[ERR.NETWORK], "5XX"),
  networkError: ERR_CODE[ERR.NETWORK],
  contentError: "".concat(ERR_CODE[ERR.NETWORK], "contentError"),
  mse: ERR_CODE[ERR.MEDIA][ERR.SUB_TYPES.MSE_OTHER],
  mseOpen: ERR_CODE[ERR.MEDIA][ERR.SUB_TYPES.MSE_ADD_SB],
  mseAppend: ERR_CODE[ERR.MEDIA][ERR.SUB_TYPES.MSE_APPEND_BUFFER],
  mse_hijack: ERR_CODE[ERR.MEDIA][ERR.SUB_TYPES.MSE_HIJACK],
  eme_hijack: ERR_CODE[ERR.MEDIA][ERR.SUB_TYPES.EME_HIJACK],
  metaError: ERR_CODE[ERR.DEMUX][ERR.SUB_TYPES.MP4],
  muxError: ERR_CODE[ERR.REMUX][ERR.SUB_TYPES.FMP4],
  other: ERR_CODE[ERR.OTHER],
  waitTimeout: ERR_CODE[ERR.RUNTIME][ERR.SUB_TYPES.BUFFERBREAK_ERROR],
  waitTimeoutWithHidden: ERR_CODE[ERR.RUNTIME][ERR.SUB_TYPES.WAITING_TIMEOUT_ERROR],
  drm: ERR_CODE[ERR.DRM][ERR.SUB_TYPES.LICENSE]
};
var ERROR_TYPES = ERR;
function getErrorCodeByHttpCode(httpCode) {
  return ERROR_CODES[httpCode] || httpCode;
}
var NetWorkError = _createClass(function NetWorkError2(type, httpCode, context) {
  _classCallCheck(this, NetWorkError2);
  var rangeStart = 0;
  var rangeEnd = 0;
  if (context && context.range && context.range.length > 1) {
    rangeStart = context.range[0];
    rangeEnd = context.range[1];
  }
  var _errCode = getErrorCodeByHttpCode(httpCode);
  return {
    errorCode: _errCode,
    errorType: type,
    errorMessage: (context === null || context === void 0 ? void 0 : context.httpText) || (context === null || context === void 0 ? void 0 : context.message),
    url: context === null || context === void 0 ? void 0 : context.url,
    httpCode,
    version,
    rangeStart,
    rangeEnd,
    ext: context,
    mediaError: {
      code: _errCode,
      message: (context === null || context === void 0 ? void 0 : context.httpText) || (context === null || context === void 0 ? void 0 : context.message)
    }
  };
});
var ParserError = _createClass(function ParserError2(type, errorCode, ext) {
  _classCallCheck(this, ParserError2);
  return {
    errorCode,
    errorType: type,
    version,
    errorMessage: ext.msg,
    ext,
    mediaError: {
      code: errorCode,
      message: ext.msg
    }
  };
});

// node_modules/xgplayer-mp4/es/util/index.js
var util2 = {};
util2.nowTime = function() {
  try {
    return parseInt(performance.now(), 10);
  } catch (e) {
    return (/* @__PURE__ */ new Date()).getTime();
  }
};
util2.concatData = function(video, audio) {
  var resBuffers = [];
  var bufferSize = 0;
  if (video) {
    resBuffers.push(video);
  }
  if (audio) {
    resBuffers.push(audio);
  }
  resBuffers.every(function(item) {
    item && (bufferSize += item.byteLength);
    return true;
  });
  var buffer = new Uint8Array(bufferSize);
  var offset = 0;
  resBuffers.every(function(item) {
    if (item) {
      buffer.set(item, offset);
      offset += item.byteLength;
    }
    return true;
  });
  return buffer;
};

// node_modules/xgplayer-mp4-loader/es/_virtual/_rollupPluginBabelHelpers.js
function _iterableToArrayLimit2(arr, i) {
  var _i = null == arr ? null : "undefined" != typeof Symbol && arr[Symbol.iterator] || arr["@@iterator"];
  if (null != _i) {
    var _s, _e, _x, _r, _arr = [], _n = true, _d = false;
    try {
      if (_x = (_i = _i.call(arr)).next, 0 === i) {
        if (Object(_i) !== _i)
          return;
        _n = false;
      } else
        for (; !(_n = (_s = _x.call(_i)).done) && (_arr.push(_s.value), _arr.length !== i); _n = true)
          ;
    } catch (err) {
      _d = true, _e = err;
    } finally {
      try {
        if (!_n && null != _i.return && (_r = _i.return(), Object(_r) !== _r))
          return;
      } finally {
        if (_d)
          throw _e;
      }
    }
    return _arr;
  }
}
function ownKeys3(object, enumerableOnly) {
  var keys = Object.keys(object);
  if (Object.getOwnPropertySymbols) {
    var symbols = Object.getOwnPropertySymbols(object);
    enumerableOnly && (symbols = symbols.filter(function(sym) {
      return Object.getOwnPropertyDescriptor(object, sym).enumerable;
    })), keys.push.apply(keys, symbols);
  }
  return keys;
}
function _objectSpread23(target) {
  for (var i = 1; i < arguments.length; i++) {
    var source = null != arguments[i] ? arguments[i] : {};
    i % 2 ? ownKeys3(Object(source), true).forEach(function(key) {
      _defineProperty4(target, key, source[key]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys3(Object(source)).forEach(function(key) {
      Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
    });
  }
  return target;
}
function _regeneratorRuntime3() {
  _regeneratorRuntime3 = function() {
    return exports;
  };
  var exports = {}, Op = Object.prototype, hasOwn = Op.hasOwnProperty, defineProperty = Object.defineProperty || function(obj, key, desc) {
    obj[key] = desc.value;
  }, $Symbol = "function" == typeof Symbol ? Symbol : {}, iteratorSymbol = $Symbol.iterator || "@@iterator", asyncIteratorSymbol = $Symbol.asyncIterator || "@@asyncIterator", toStringTagSymbol = $Symbol.toStringTag || "@@toStringTag";
  function define(obj, key, value) {
    return Object.defineProperty(obj, key, {
      value,
      enumerable: true,
      configurable: true,
      writable: true
    }), obj[key];
  }
  try {
    define({}, "");
  } catch (err) {
    define = function(obj, key, value) {
      return obj[key] = value;
    };
  }
  function wrap(innerFn, outerFn, self, tryLocsList) {
    var protoGenerator = outerFn && outerFn.prototype instanceof Generator ? outerFn : Generator, generator = Object.create(protoGenerator.prototype), context = new Context(tryLocsList || []);
    return defineProperty(generator, "_invoke", {
      value: makeInvokeMethod(innerFn, self, context)
    }), generator;
  }
  function tryCatch(fn, obj, arg) {
    try {
      return {
        type: "normal",
        arg: fn.call(obj, arg)
      };
    } catch (err) {
      return {
        type: "throw",
        arg: err
      };
    }
  }
  exports.wrap = wrap;
  var ContinueSentinel = {};
  function Generator() {
  }
  function GeneratorFunction() {
  }
  function GeneratorFunctionPrototype() {
  }
  var IteratorPrototype = {};
  define(IteratorPrototype, iteratorSymbol, function() {
    return this;
  });
  var getProto = Object.getPrototypeOf, NativeIteratorPrototype = getProto && getProto(getProto(values([])));
  NativeIteratorPrototype && NativeIteratorPrototype !== Op && hasOwn.call(NativeIteratorPrototype, iteratorSymbol) && (IteratorPrototype = NativeIteratorPrototype);
  var Gp = GeneratorFunctionPrototype.prototype = Generator.prototype = Object.create(IteratorPrototype);
  function defineIteratorMethods(prototype) {
    ["next", "throw", "return"].forEach(function(method) {
      define(prototype, method, function(arg) {
        return this._invoke(method, arg);
      });
    });
  }
  function AsyncIterator(generator, PromiseImpl) {
    function invoke(method, arg, resolve, reject) {
      var record = tryCatch(generator[method], generator, arg);
      if ("throw" !== record.type) {
        var result = record.arg, value = result.value;
        return value && "object" == typeof value && hasOwn.call(value, "__await") ? PromiseImpl.resolve(value.__await).then(function(value2) {
          invoke("next", value2, resolve, reject);
        }, function(err) {
          invoke("throw", err, resolve, reject);
        }) : PromiseImpl.resolve(value).then(function(unwrapped) {
          result.value = unwrapped, resolve(result);
        }, function(error) {
          return invoke("throw", error, resolve, reject);
        });
      }
      reject(record.arg);
    }
    var previousPromise;
    defineProperty(this, "_invoke", {
      value: function(method, arg) {
        function callInvokeWithMethodAndArg() {
          return new PromiseImpl(function(resolve, reject) {
            invoke(method, arg, resolve, reject);
          });
        }
        return previousPromise = previousPromise ? previousPromise.then(callInvokeWithMethodAndArg, callInvokeWithMethodAndArg) : callInvokeWithMethodAndArg();
      }
    });
  }
  function makeInvokeMethod(innerFn, self, context) {
    var state = "suspendedStart";
    return function(method, arg) {
      if ("executing" === state)
        throw new Error("Generator is already running");
      if ("completed" === state) {
        if ("throw" === method)
          throw arg;
        return doneResult();
      }
      for (context.method = method, context.arg = arg; ; ) {
        var delegate = context.delegate;
        if (delegate) {
          var delegateResult = maybeInvokeDelegate(delegate, context);
          if (delegateResult) {
            if (delegateResult === ContinueSentinel)
              continue;
            return delegateResult;
          }
        }
        if ("next" === context.method)
          context.sent = context._sent = context.arg;
        else if ("throw" === context.method) {
          if ("suspendedStart" === state)
            throw state = "completed", context.arg;
          context.dispatchException(context.arg);
        } else
          "return" === context.method && context.abrupt("return", context.arg);
        state = "executing";
        var record = tryCatch(innerFn, self, context);
        if ("normal" === record.type) {
          if (state = context.done ? "completed" : "suspendedYield", record.arg === ContinueSentinel)
            continue;
          return {
            value: record.arg,
            done: context.done
          };
        }
        "throw" === record.type && (state = "completed", context.method = "throw", context.arg = record.arg);
      }
    };
  }
  function maybeInvokeDelegate(delegate, context) {
    var methodName = context.method, method = delegate.iterator[methodName];
    if (void 0 === method)
      return context.delegate = null, "throw" === methodName && delegate.iterator.return && (context.method = "return", context.arg = void 0, maybeInvokeDelegate(delegate, context), "throw" === context.method) || "return" !== methodName && (context.method = "throw", context.arg = new TypeError("The iterator does not provide a '" + methodName + "' method")), ContinueSentinel;
    var record = tryCatch(method, delegate.iterator, context.arg);
    if ("throw" === record.type)
      return context.method = "throw", context.arg = record.arg, context.delegate = null, ContinueSentinel;
    var info = record.arg;
    return info ? info.done ? (context[delegate.resultName] = info.value, context.next = delegate.nextLoc, "return" !== context.method && (context.method = "next", context.arg = void 0), context.delegate = null, ContinueSentinel) : info : (context.method = "throw", context.arg = new TypeError("iterator result is not an object"), context.delegate = null, ContinueSentinel);
  }
  function pushTryEntry(locs) {
    var entry = {
      tryLoc: locs[0]
    };
    1 in locs && (entry.catchLoc = locs[1]), 2 in locs && (entry.finallyLoc = locs[2], entry.afterLoc = locs[3]), this.tryEntries.push(entry);
  }
  function resetTryEntry(entry) {
    var record = entry.completion || {};
    record.type = "normal", delete record.arg, entry.completion = record;
  }
  function Context(tryLocsList) {
    this.tryEntries = [{
      tryLoc: "root"
    }], tryLocsList.forEach(pushTryEntry, this), this.reset(true);
  }
  function values(iterable) {
    if (iterable) {
      var iteratorMethod = iterable[iteratorSymbol];
      if (iteratorMethod)
        return iteratorMethod.call(iterable);
      if ("function" == typeof iterable.next)
        return iterable;
      if (!isNaN(iterable.length)) {
        var i = -1, next = function next2() {
          for (; ++i < iterable.length; )
            if (hasOwn.call(iterable, i))
              return next2.value = iterable[i], next2.done = false, next2;
          return next2.value = void 0, next2.done = true, next2;
        };
        return next.next = next;
      }
    }
    return {
      next: doneResult
    };
  }
  function doneResult() {
    return {
      value: void 0,
      done: true
    };
  }
  return GeneratorFunction.prototype = GeneratorFunctionPrototype, defineProperty(Gp, "constructor", {
    value: GeneratorFunctionPrototype,
    configurable: true
  }), defineProperty(GeneratorFunctionPrototype, "constructor", {
    value: GeneratorFunction,
    configurable: true
  }), GeneratorFunction.displayName = define(GeneratorFunctionPrototype, toStringTagSymbol, "GeneratorFunction"), exports.isGeneratorFunction = function(genFun) {
    var ctor = "function" == typeof genFun && genFun.constructor;
    return !!ctor && (ctor === GeneratorFunction || "GeneratorFunction" === (ctor.displayName || ctor.name));
  }, exports.mark = function(genFun) {
    return Object.setPrototypeOf ? Object.setPrototypeOf(genFun, GeneratorFunctionPrototype) : (genFun.__proto__ = GeneratorFunctionPrototype, define(genFun, toStringTagSymbol, "GeneratorFunction")), genFun.prototype = Object.create(Gp), genFun;
  }, exports.awrap = function(arg) {
    return {
      __await: arg
    };
  }, defineIteratorMethods(AsyncIterator.prototype), define(AsyncIterator.prototype, asyncIteratorSymbol, function() {
    return this;
  }), exports.AsyncIterator = AsyncIterator, exports.async = function(innerFn, outerFn, self, tryLocsList, PromiseImpl) {
    void 0 === PromiseImpl && (PromiseImpl = Promise);
    var iter = new AsyncIterator(wrap(innerFn, outerFn, self, tryLocsList), PromiseImpl);
    return exports.isGeneratorFunction(outerFn) ? iter : iter.next().then(function(result) {
      return result.done ? result.value : iter.next();
    });
  }, defineIteratorMethods(Gp), define(Gp, toStringTagSymbol, "Generator"), define(Gp, iteratorSymbol, function() {
    return this;
  }), define(Gp, "toString", function() {
    return "[object Generator]";
  }), exports.keys = function(val) {
    var object = Object(val), keys = [];
    for (var key in object)
      keys.push(key);
    return keys.reverse(), function next() {
      for (; keys.length; ) {
        var key2 = keys.pop();
        if (key2 in object)
          return next.value = key2, next.done = false, next;
      }
      return next.done = true, next;
    };
  }, exports.values = values, Context.prototype = {
    constructor: Context,
    reset: function(skipTempReset) {
      if (this.prev = 0, this.next = 0, this.sent = this._sent = void 0, this.done = false, this.delegate = null, this.method = "next", this.arg = void 0, this.tryEntries.forEach(resetTryEntry), !skipTempReset)
        for (var name in this)
          "t" === name.charAt(0) && hasOwn.call(this, name) && !isNaN(+name.slice(1)) && (this[name] = void 0);
    },
    stop: function() {
      this.done = true;
      var rootRecord = this.tryEntries[0].completion;
      if ("throw" === rootRecord.type)
        throw rootRecord.arg;
      return this.rval;
    },
    dispatchException: function(exception) {
      if (this.done)
        throw exception;
      var context = this;
      function handle(loc, caught) {
        return record.type = "throw", record.arg = exception, context.next = loc, caught && (context.method = "next", context.arg = void 0), !!caught;
      }
      for (var i = this.tryEntries.length - 1; i >= 0; --i) {
        var entry = this.tryEntries[i], record = entry.completion;
        if ("root" === entry.tryLoc)
          return handle("end");
        if (entry.tryLoc <= this.prev) {
          var hasCatch = hasOwn.call(entry, "catchLoc"), hasFinally = hasOwn.call(entry, "finallyLoc");
          if (hasCatch && hasFinally) {
            if (this.prev < entry.catchLoc)
              return handle(entry.catchLoc, true);
            if (this.prev < entry.finallyLoc)
              return handle(entry.finallyLoc);
          } else if (hasCatch) {
            if (this.prev < entry.catchLoc)
              return handle(entry.catchLoc, true);
          } else {
            if (!hasFinally)
              throw new Error("try statement without catch or finally");
            if (this.prev < entry.finallyLoc)
              return handle(entry.finallyLoc);
          }
        }
      }
    },
    abrupt: function(type, arg) {
      for (var i = this.tryEntries.length - 1; i >= 0; --i) {
        var entry = this.tryEntries[i];
        if (entry.tryLoc <= this.prev && hasOwn.call(entry, "finallyLoc") && this.prev < entry.finallyLoc) {
          var finallyEntry = entry;
          break;
        }
      }
      finallyEntry && ("break" === type || "continue" === type) && finallyEntry.tryLoc <= arg && arg <= finallyEntry.finallyLoc && (finallyEntry = null);
      var record = finallyEntry ? finallyEntry.completion : {};
      return record.type = type, record.arg = arg, finallyEntry ? (this.method = "next", this.next = finallyEntry.finallyLoc, ContinueSentinel) : this.complete(record);
    },
    complete: function(record, afterLoc) {
      if ("throw" === record.type)
        throw record.arg;
      return "break" === record.type || "continue" === record.type ? this.next = record.arg : "return" === record.type ? (this.rval = this.arg = record.arg, this.method = "return", this.next = "end") : "normal" === record.type && afterLoc && (this.next = afterLoc), ContinueSentinel;
    },
    finish: function(finallyLoc) {
      for (var i = this.tryEntries.length - 1; i >= 0; --i) {
        var entry = this.tryEntries[i];
        if (entry.finallyLoc === finallyLoc)
          return this.complete(entry.completion, entry.afterLoc), resetTryEntry(entry), ContinueSentinel;
      }
    },
    catch: function(tryLoc) {
      for (var i = this.tryEntries.length - 1; i >= 0; --i) {
        var entry = this.tryEntries[i];
        if (entry.tryLoc === tryLoc) {
          var record = entry.completion;
          if ("throw" === record.type) {
            var thrown = record.arg;
            resetTryEntry(entry);
          }
          return thrown;
        }
      }
      throw new Error("illegal catch attempt");
    },
    delegateYield: function(iterable, resultName, nextLoc) {
      return this.delegate = {
        iterator: values(iterable),
        resultName,
        nextLoc
      }, "next" === this.method && (this.arg = void 0), ContinueSentinel;
    }
  }, exports;
}
function asyncGeneratorStep3(gen, resolve, reject, _next, _throw, key, arg) {
  try {
    var info = gen[key](arg);
    var value = info.value;
  } catch (error) {
    reject(error);
    return;
  }
  if (info.done) {
    resolve(value);
  } else {
    Promise.resolve(value).then(_next, _throw);
  }
}
function _asyncToGenerator3(fn) {
  return function() {
    var self = this, args = arguments;
    return new Promise(function(resolve, reject) {
      var gen = fn.apply(self, args);
      function _next(value) {
        asyncGeneratorStep3(gen, resolve, reject, _next, _throw, "next", value);
      }
      function _throw(err) {
        asyncGeneratorStep3(gen, resolve, reject, _next, _throw, "throw", err);
      }
      _next(void 0);
    });
  };
}
function _classCallCheck4(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}
function _defineProperties4(target, props) {
  for (var i = 0; i < props.length; i++) {
    var descriptor = props[i];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor)
      descriptor.writable = true;
    Object.defineProperty(target, _toPropertyKey4(descriptor.key), descriptor);
  }
}
function _createClass4(Constructor, protoProps, staticProps) {
  if (protoProps)
    _defineProperties4(Constructor.prototype, protoProps);
  if (staticProps)
    _defineProperties4(Constructor, staticProps);
  Object.defineProperty(Constructor, "prototype", {
    writable: false
  });
  return Constructor;
}
function _defineProperty4(obj, key, value) {
  key = _toPropertyKey4(key);
  if (key in obj) {
    Object.defineProperty(obj, key, {
      value,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key] = value;
  }
  return obj;
}
function _inherits4(subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function");
  }
  subClass.prototype = Object.create(superClass && superClass.prototype, {
    constructor: {
      value: subClass,
      writable: true,
      configurable: true
    }
  });
  Object.defineProperty(subClass, "prototype", {
    writable: false
  });
  if (superClass)
    _setPrototypeOf4(subClass, superClass);
}
function _getPrototypeOf4(o) {
  _getPrototypeOf4 = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf22(o2) {
    return o2.__proto__ || Object.getPrototypeOf(o2);
  };
  return _getPrototypeOf4(o);
}
function _setPrototypeOf4(o, p) {
  _setPrototypeOf4 = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf22(o2, p2) {
    o2.__proto__ = p2;
    return o2;
  };
  return _setPrototypeOf4(o, p);
}
function _isNativeReflectConstruct4() {
  if (typeof Reflect === "undefined" || !Reflect.construct)
    return false;
  if (Reflect.construct.sham)
    return false;
  if (typeof Proxy === "function")
    return true;
  try {
    Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
    }));
    return true;
  } catch (e) {
    return false;
  }
}
function _objectWithoutPropertiesLoose2(source, excluded) {
  if (source == null)
    return {};
  var target = {};
  var sourceKeys = Object.keys(source);
  var key, i;
  for (i = 0; i < sourceKeys.length; i++) {
    key = sourceKeys[i];
    if (excluded.indexOf(key) >= 0)
      continue;
    target[key] = source[key];
  }
  return target;
}
function _objectWithoutProperties2(source, excluded) {
  if (source == null)
    return {};
  var target = _objectWithoutPropertiesLoose2(source, excluded);
  var key, i;
  if (Object.getOwnPropertySymbols) {
    var sourceSymbolKeys = Object.getOwnPropertySymbols(source);
    for (i = 0; i < sourceSymbolKeys.length; i++) {
      key = sourceSymbolKeys[i];
      if (excluded.indexOf(key) >= 0)
        continue;
      if (!Object.prototype.propertyIsEnumerable.call(source, key))
        continue;
      target[key] = source[key];
    }
  }
  return target;
}
function _assertThisInitialized4(self) {
  if (self === void 0) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }
  return self;
}
function _possibleConstructorReturn4(self, call) {
  if (call && (typeof call === "object" || typeof call === "function")) {
    return call;
  } else if (call !== void 0) {
    throw new TypeError("Derived constructors may only return object or undefined");
  }
  return _assertThisInitialized4(self);
}
function _createSuper4(Derived) {
  var hasNativeReflectConstruct = _isNativeReflectConstruct4();
  return function _createSuperInternal() {
    var Super = _getPrototypeOf4(Derived), result;
    if (hasNativeReflectConstruct) {
      var NewTarget = _getPrototypeOf4(this).constructor;
      result = Reflect.construct(Super, arguments, NewTarget);
    } else {
      result = Super.apply(this, arguments);
    }
    return _possibleConstructorReturn4(this, result);
  };
}
function _slicedToArray2(arr, i) {
  return _arrayWithHoles2(arr) || _iterableToArrayLimit2(arr, i) || _unsupportedIterableToArray3(arr, i) || _nonIterableRest2();
}
function _toConsumableArray2(arr) {
  return _arrayWithoutHoles2(arr) || _iterableToArray2(arr) || _unsupportedIterableToArray3(arr) || _nonIterableSpread2();
}
function _arrayWithoutHoles2(arr) {
  if (Array.isArray(arr))
    return _arrayLikeToArray3(arr);
}
function _arrayWithHoles2(arr) {
  if (Array.isArray(arr))
    return arr;
}
function _iterableToArray2(iter) {
  if (typeof Symbol !== "undefined" && iter[Symbol.iterator] != null || iter["@@iterator"] != null)
    return Array.from(iter);
}
function _unsupportedIterableToArray3(o, minLen) {
  if (!o)
    return;
  if (typeof o === "string")
    return _arrayLikeToArray3(o, minLen);
  var n = Object.prototype.toString.call(o).slice(8, -1);
  if (n === "Object" && o.constructor)
    n = o.constructor.name;
  if (n === "Map" || n === "Set")
    return Array.from(o);
  if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n))
    return _arrayLikeToArray3(o, minLen);
}
function _arrayLikeToArray3(arr, len) {
  if (len == null || len > arr.length)
    len = arr.length;
  for (var i = 0, arr2 = new Array(len); i < len; i++)
    arr2[i] = arr[i];
  return arr2;
}
function _nonIterableSpread2() {
  throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}
function _nonIterableRest2() {
  throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}
function _toPrimitive4(input, hint) {
  if (typeof input !== "object" || input === null)
    return input;
  var prim = input[Symbol.toPrimitive];
  if (prim !== void 0) {
    var res = prim.call(input, hint || "default");
    if (typeof res !== "object")
      return res;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return (hint === "string" ? String : Number)(input);
}
function _toPropertyKey4(arg) {
  var key = _toPrimitive4(arg, "string");
  return typeof key === "symbol" ? key : String(key);
}

// node_modules/xgplayer-mp4-loader/es/config.js
function getConfig2(cfg) {
  return _objectSpread23({
    vid: "",
    moovEnd: 8e4,
    segmentDuration: 2,
    maxDownloadInfoSize: 30,
    responseType: "arraybuffer",
    cache: null
  }, cfg);
}

// node_modules/xgplayer-mp4-loader/es/error.js
var MediaError = _createClass4(function MediaError2(msg, data) {
  _classCallCheck4(this, MediaError2);
  this.type = "file";
  this.message = msg;
  this.data = data;
});

// node_modules/xgplayer-mp4-loader/es/cache.js
var Cache = function() {
  function Cache2() {
    _classCallCheck4(this, Cache2);
    _defineProperty4(this, "_data", /* @__PURE__ */ Object.create(null));
  }
  _createClass4(Cache2, [{
    key: "set",
    value: function set(id, data) {
      this._data[id] = data;
    }
  }, {
    key: "get",
    value: function get(id) {
      return this._data[id];
    }
  }, {
    key: "clear",
    value: function clear() {
      this._data = /* @__PURE__ */ Object.create(null);
    }
  }]);
  return Cache2;
}();

// node_modules/xgplayer-mp4-loader/es/utils.js
function moovToSegments(moov, duration) {
  var tracks = moov.trak;
  if (!tracks || !tracks.length)
    return;
  var videoTrack = tracks.find(function(t) {
    var _t$mdia, _t$mdia$hdlr;
    return ((_t$mdia = t.mdia) === null || _t$mdia === void 0 ? void 0 : (_t$mdia$hdlr = _t$mdia.hdlr) === null || _t$mdia$hdlr === void 0 ? void 0 : _t$mdia$hdlr.handlerType) === "vide";
  });
  var audioTrack = tracks.find(function(t) {
    var _t$mdia2, _t$mdia2$hdlr;
    return ((_t$mdia2 = t.mdia) === null || _t$mdia2 === void 0 ? void 0 : (_t$mdia2$hdlr = _t$mdia2.hdlr) === null || _t$mdia2$hdlr === void 0 ? void 0 : _t$mdia2$hdlr.handlerType) === "soun";
  });
  if (!videoTrack && !audioTrack)
    return;
  var videoSegments = [];
  var audioSegments = [];
  var segmentDurations;
  if (videoTrack) {
    var _videoTrack$mdia, _videoTrack$mdia$minf, _videoTrack$mdia$mdhd;
    var videoStbl = (_videoTrack$mdia = videoTrack.mdia) === null || _videoTrack$mdia === void 0 ? void 0 : (_videoTrack$mdia$minf = _videoTrack$mdia.minf) === null || _videoTrack$mdia$minf === void 0 ? void 0 : _videoTrack$mdia$minf.stbl;
    if (!videoStbl)
      return;
    var timescale = (_videoTrack$mdia$mdhd = videoTrack.mdia.mdhd) === null || _videoTrack$mdia$mdhd === void 0 ? void 0 : _videoTrack$mdia$mdhd.timescale;
    var stts = videoStbl.stts, stsc = videoStbl.stsc, stsz = videoStbl.stsz, stco = videoStbl.stco, stss = videoStbl.stss, ctts = videoStbl.ctts;
    if (!timescale || !stts || !stsc || !stsz || !stco || !stss)
      return;
    videoSegments = getSegments(duration, timescale, stts, stsc, stsz, stco, stss, ctts);
    segmentDurations = videoSegments.map(function(x2) {
      return x2.duration;
    });
  }
  if (audioTrack) {
    var _audioTrack$mdia, _audioTrack$mdia$minf, _audioTrack$mdia$mdhd;
    var audioStbl = (_audioTrack$mdia = audioTrack.mdia) === null || _audioTrack$mdia === void 0 ? void 0 : (_audioTrack$mdia$minf = _audioTrack$mdia.minf) === null || _audioTrack$mdia$minf === void 0 ? void 0 : _audioTrack$mdia$minf.stbl;
    if (!audioStbl)
      return;
    var _timescale = (_audioTrack$mdia$mdhd = audioTrack.mdia.mdhd) === null || _audioTrack$mdia$mdhd === void 0 ? void 0 : _audioTrack$mdia$mdhd.timescale;
    var _stts = audioStbl.stts, _stsc = audioStbl.stsc, _stsz = audioStbl.stsz, _stco = audioStbl.stco;
    if (!_timescale || !_stts || !_stsc || !_stsz || !_stco)
      return;
    audioSegments = getSegments(duration, _timescale, _stts, _stsc, _stsz, _stco, null, null, segmentDurations);
  }
  return {
    videoSegments,
    audioSegments
  };
}
function getSegments(segDuration, timescale, stts, stsc, stsz, stco, stss, ctts, segmentDurations) {
  var frames = [];
  var gop = [];
  var gopDuration = [];
  var stscEntries = stsc.entries;
  var stcoEntries = stco.entries;
  var stszEntrySizes = stsz.entrySizes;
  var stssEntries = stss === null || stss === void 0 ? void 0 : stss.entries;
  var cttsEntries = ctts === null || ctts === void 0 ? void 0 : ctts.entries;
  var cttsArr;
  if (cttsEntries) {
    cttsArr = [];
    cttsEntries.forEach(function(_ref) {
      var count = _ref.count, offset = _ref.offset;
      for (var i2 = 0; i2 < count; i2++) {
        cttsArr.push(offset);
      }
    });
  }
  var keyframeMap;
  if (stssEntries) {
    keyframeMap = {};
    stssEntries.forEach(function(x2) {
      keyframeMap[x2 - 1] = true;
    });
  }
  var frame;
  var duration;
  var startTime = 0;
  var pos = 0;
  var chunkIndex = 0;
  var chunkRunIndex = 0;
  var offsetInChunk = 0;
  var lastSampleInChunk = stscEntries[0].samplesPerChunk;
  var lastChunkInRun = stscEntries[1] ? stscEntries[1].firstChunk - 1 : Infinity;
  var dts = 0;
  var gopId = -1;
  stts.entries.forEach(function(_ref2) {
    var count = _ref2.count, delta = _ref2.delta;
    duration = delta;
    for (var i2 = 0; i2 < count; i2++) {
      frame = {
        dts,
        startTime,
        duration,
        size: stszEntrySizes[pos] || stsz.sampleSize,
        offset: stcoEntries[chunkIndex] + offsetInChunk,
        index: pos
      };
      if (stssEntries) {
        frame.keyframe = keyframeMap[pos];
        if (frame.keyframe) {
          gopId++;
          gop.push([frame]);
          gopDuration.push(frame.duration);
        } else {
          gop[gop.length - 1].push(frame);
          gopDuration[gop.length - 1] += frame.duration;
        }
        frame.gopId = gopId;
      }
      if (cttsArr && pos < cttsArr.length) {
        frame.pts = dts + cttsArr[pos];
      }
      if (pos === 0) {
        frame.pts = 0;
      }
      frames.push(frame);
      startTime += duration;
      dts += delta;
      pos++;
      if (pos < lastSampleInChunk) {
        offsetInChunk += frame.size;
      } else {
        chunkIndex++;
        offsetInChunk = 0;
        if (chunkIndex >= lastChunkInRun) {
          chunkRunIndex++;
          lastChunkInRun = stscEntries[chunkRunIndex + 1] ? stscEntries[chunkRunIndex + 1].firstChunk - 1 : Infinity;
        }
        lastSampleInChunk += stscEntries[chunkRunIndex].samplesPerChunk;
      }
    }
  });
  var l = frames.length;
  if (!l || stss && !frames[0].keyframe)
    return;
  var segments = [];
  var segFrames = [];
  var time = 0;
  var lastFrame;
  var adjust = 0;
  var pushSegment = function pushSegment2(duration2) {
    var _segments;
    lastFrame = segFrames[segFrames.length - 1];
    segments.push({
      index: segments.length,
      startTime: ((_segments = segments[segments.length - 1]) === null || _segments === void 0 ? void 0 : _segments.endTime) || segFrames[0].startTime / timescale,
      endTime: (lastFrame.startTime + lastFrame.duration) / timescale,
      duration: duration2,
      range: [segFrames[0].offset, lastFrame.offset + lastFrame.size],
      frames: segFrames
    });
    time = 0;
    segFrames = [];
  };
  if (stss) {
    var _duration = segDuration * timescale;
    for (var i = 0, _l = gop.length; i < _l; i++) {
      var _segFrames;
      time += gopDuration[i];
      (_segFrames = segFrames).push.apply(_segFrames, _toConsumableArray2(gop[i]));
      if (i + 1 < _l) {
        if (i === 0 || time > _duration) {
          pushSegment(time / timescale);
        }
      } else {
        pushSegment(time / timescale);
      }
    }
  } else {
    segmentDurations = segmentDurations || [];
    var _duration2 = segmentDurations[0] || segDuration;
    for (var _i = 0; _i < l; _i++) {
      segFrames.push(frames[_i]);
      time += frames[_i].duration;
      var curTime = time / timescale;
      if (_i + 1 >= l || curTime + adjust >= _duration2) {
        adjust += curTime - _duration2;
        pushSegment(curTime);
        _duration2 = segmentDurations[segments.length] || segDuration;
      }
    }
  }
  return segments;
}
function moovToMeta(moov) {
  var videoCodec = "";
  var audioCodec = "";
  var width = 0;
  var height = 0;
  var audioChannelCount = 0;
  var audioSampleRate = 0;
  var duration = 0;
  var videoTimescale = 0;
  var audioTimescale = 0;
  if (moov.mvhd) {
    duration = moov.mvhd.duration / moov.mvhd.timescale;
  }
  var tracks = moov.trak;
  if (tracks) {
    var videoTrack = tracks.find(function(t) {
      var _t$mdia3, _t$mdia3$hdlr;
      return ((_t$mdia3 = t.mdia) === null || _t$mdia3 === void 0 ? void 0 : (_t$mdia3$hdlr = _t$mdia3.hdlr) === null || _t$mdia3$hdlr === void 0 ? void 0 : _t$mdia3$hdlr.handlerType) === "vide";
    });
    var audioTrack = tracks.find(function(t) {
      var _t$mdia4, _t$mdia4$hdlr;
      return ((_t$mdia4 = t.mdia) === null || _t$mdia4 === void 0 ? void 0 : (_t$mdia4$hdlr = _t$mdia4.hdlr) === null || _t$mdia4$hdlr === void 0 ? void 0 : _t$mdia4$hdlr.handlerType) === "soun";
    });
    var e1 = null;
    var defaultKID;
    if (videoTrack) {
      var _videoTrack$mdia2, _videoTrack$mdia2$min, _videoTrack$mdia2$min2;
      e1 = (_videoTrack$mdia2 = videoTrack.mdia) === null || _videoTrack$mdia2 === void 0 ? void 0 : (_videoTrack$mdia2$min = _videoTrack$mdia2.minf) === null || _videoTrack$mdia2$min === void 0 ? void 0 : (_videoTrack$mdia2$min2 = _videoTrack$mdia2$min.stbl) === null || _videoTrack$mdia2$min2 === void 0 ? void 0 : _videoTrack$mdia2$min2.stsd.entries[0];
      if (e1) {
        var _videoTrack$mdia3, _videoTrack$mdia3$mdh, _ref3;
        width = e1.width;
        height = e1.height;
        videoTimescale = (_videoTrack$mdia3 = videoTrack.mdia) === null || _videoTrack$mdia3 === void 0 ? void 0 : (_videoTrack$mdia3$mdh = _videoTrack$mdia3.mdhd) === null || _videoTrack$mdia3$mdh === void 0 ? void 0 : _videoTrack$mdia3$mdh.timescale;
        videoCodec = (_ref3 = e1.avcC || e1.hvcC) === null || _ref3 === void 0 ? void 0 : _ref3.codec;
        if (e1.type === "encv") {
          var _e1$sinf, _e1$sinf$schi;
          defaultKID = (_e1$sinf = e1.sinf) === null || _e1$sinf === void 0 ? void 0 : (_e1$sinf$schi = _e1$sinf.schi) === null || _e1$sinf$schi === void 0 ? void 0 : _e1$sinf$schi.tenc.default_KID;
        }
      }
    }
    if (audioTrack) {
      var _audioTrack$mdia2, _audioTrack$mdia2$min, _audioTrack$mdia2$min2;
      e1 = (_audioTrack$mdia2 = audioTrack.mdia) === null || _audioTrack$mdia2 === void 0 ? void 0 : (_audioTrack$mdia2$min = _audioTrack$mdia2.minf) === null || _audioTrack$mdia2$min === void 0 ? void 0 : (_audioTrack$mdia2$min2 = _audioTrack$mdia2$min.stbl) === null || _audioTrack$mdia2$min2 === void 0 ? void 0 : _audioTrack$mdia2$min2.stsd.entries[0];
      if (e1) {
        var _e1$esds, _audioTrack$mdia3, _audioTrack$mdia3$mdh;
        audioChannelCount = e1.channelCount;
        audioSampleRate = e1.sampleRate;
        audioCodec = (_e1$esds = e1.esds) === null || _e1$esds === void 0 ? void 0 : _e1$esds.codec;
        audioTimescale = (_audioTrack$mdia3 = audioTrack.mdia) === null || _audioTrack$mdia3 === void 0 ? void 0 : (_audioTrack$mdia3$mdh = _audioTrack$mdia3.mdhd) === null || _audioTrack$mdia3$mdh === void 0 ? void 0 : _audioTrack$mdia3$mdh.timescale;
        if (e1.type === "enca") {
          var _e1$sinf2, _e1$sinf2$schi;
          defaultKID = defaultKID || ((_e1$sinf2 = e1.sinf) === null || _e1$sinf2 === void 0 ? void 0 : (_e1$sinf2$schi = _e1$sinf2.schi) === null || _e1$sinf2$schi === void 0 ? void 0 : _e1$sinf2$schi.tenc.default_KID);
        }
      }
    }
    return {
      kid: defaultKID ? defaultKID.join("") : null,
      videoCodec,
      audioCodec,
      width,
      height,
      videoTimescale,
      audioChannelCount,
      audioSampleRate,
      duration,
      audioTimescale,
      moov
    };
  }
}
function isNumber(n) {
  return typeof n === "number" && !Number.isNaN(n);
}

// node_modules/xgplayer-mp4-loader/es/loader.js
var import_eventemitter35 = __toESM(require_eventemitter3());
var _excluded2 = ["vid", "cache"];
var MP4Loader = function(_EventEmitter) {
  _inherits4(MP4Loader2, _EventEmitter);
  var _super = _createSuper4(MP4Loader2);
  function MP4Loader2(config) {
    var _this;
    _classCallCheck4(this, MP4Loader2);
    _this = _super.call(this);
    _defineProperty4(_assertThisInitialized4(_this), "vid", "");
    _defineProperty4(_assertThisInitialized4(_this), "url", "");
    _defineProperty4(_assertThisInitialized4(_this), "meta", {});
    _defineProperty4(_assertThisInitialized4(_this), "downloadInfo", []);
    _defineProperty4(_assertThisInitialized4(_this), "videoSegments", []);
    _defineProperty4(_assertThisInitialized4(_this), "audioSegments", []);
    _defineProperty4(_assertThisInitialized4(_this), "cache", null);
    _defineProperty4(_assertThisInitialized4(_this), "_currentSegmentIndex", -1);
    _defineProperty4(_assertThisInitialized4(_this), "_currentLoadingSegmentIndex", -1);
    _defineProperty4(_assertThisInitialized4(_this), "buffer", void 0);
    _defineProperty4(_assertThisInitialized4(_this), "_error", void 0);
    _defineProperty4(_assertThisInitialized4(_this), "_transformError", function(error) {
      return error;
    });
    _this._config = getConfig2(config);
    var _this$_config = _this._config, vid = _this$_config.vid, cache = _this$_config.cache, rest = _objectWithoutProperties2(_this$_config, _excluded2);
    _this.cache = cache || new Cache();
    _this.vid = vid || rest.url;
    _this.url = rest.url;
    rest.transformError = _this._transformError;
    _this.logger = new Logger3("MP4Loader_" + _this.vid);
    !!config.openLog && Logger3.enable();
    rest.logger = _this.logger;
    _this._loader = new NetLoader(rest);
    _this._loader.on(EVENT.REAL_TIME_SPEED, function(data) {
      _this.emit(EVENT.REAL_TIME_SPEED, data);
    });
    return _this;
  }
  _createClass4(MP4Loader2, [{
    key: "isMetaLoaded",
    get: function get() {
      return this.videoSegments.length || this.audioSegments.length;
    }
  }, {
    key: "setCurrentSegment",
    value: function setCurrentSegment(segIndex) {
      if (isNumber(segIndex)) {
        this._currentSegmentIndex = segIndex;
      }
    }
  }, {
    key: "isLastSegment",
    value: function isLastSegment(segIndex) {
      if (isNumber(segIndex)) {
        var _this$videoSegments, _this$audioSegments;
        var lastIndex = ((_this$videoSegments = this.videoSegments[this.videoSegments.length - 1]) === null || _this$videoSegments === void 0 ? void 0 : _this$videoSegments.index) || ((_this$audioSegments = this.audioSegments[this.audioSegments.length - 1]) === null || _this$audioSegments === void 0 ? void 0 : _this$audioSegments.index) || 0;
        return segIndex >= lastIndex;
      }
      return false;
    }
  }, {
    key: "isSegmentLoading",
    value: function isSegmentLoading(segIndex) {
      return segIndex === this._currentLoadingSegmentIndex;
    }
  }, {
    key: "changeUrl",
    value: function() {
      var _changeUrl = _asyncToGenerator3(_regeneratorRuntime3().mark(function _callee(url) {
        var vid, moovEnd, notCancelLoader, _args = arguments;
        return _regeneratorRuntime3().wrap(function _callee$(_context) {
          while (1)
            switch (_context.prev = _context.next) {
              case 0:
                vid = _args.length > 1 && _args[1] !== void 0 ? _args[1] : url;
                moovEnd = _args.length > 2 ? _args[2] : void 0;
                notCancelLoader = _args.length > 3 ? _args[3] : void 0;
                _context.next = 5;
                return this.reset(notCancelLoader);
              case 5:
                if (url)
                  this.url = url;
                if (vid)
                  this.vid = vid;
                if (moovEnd)
                  this._config.moovEnd = moovEnd;
              case 8:
              case "end":
                return _context.stop();
            }
        }, _callee, this);
      }));
      function changeUrl(_x) {
        return _changeUrl.apply(this, arguments);
      }
      return changeUrl;
    }()
  }, {
    key: "getOrLoadMeta",
    value: function() {
      var _getOrLoadMeta = _asyncToGenerator3(_regeneratorRuntime3().mark(function _callee2(cache) {
        return _regeneratorRuntime3().wrap(function _callee2$(_context2) {
          while (1)
            switch (_context2.prev = _context2.next) {
              case 0:
                if (this.isMetaLoaded) {
                  _context2.next = 3;
                  break;
                }
                _context2.next = 3;
                return this.loadMeta(cache);
              case 3:
                return _context2.abrupt("return", this.meta);
              case 4:
              case "end":
                return _context2.stop();
            }
        }, _callee2, this);
      }));
      function getOrLoadMeta(_x2) {
        return _getOrLoadMeta.apply(this, arguments);
      }
      return getOrLoadMeta;
    }()
  }, {
    key: "loadMetaProcess",
    value: function() {
      var _loadMetaProcess = _asyncToGenerator3(_regeneratorRuntime3().mark(function _callee4(cache, _ref, onProgress, config) {
        var _this2 = this;
        var _ref2, moovStart, moovEnd, OnProgressHandle;
        return _regeneratorRuntime3().wrap(function _callee4$(_context4) {
          while (1)
            switch (_context4.prev = _context4.next) {
              case 0:
                _ref2 = _slicedToArray2(_ref, 2), moovStart = _ref2[0], moovEnd = _ref2[1];
                this._error = false;
                this.logger.debug("[loadMetaProcess start], range,", [moovStart, moovEnd]);
                OnProgressHandle = function() {
                  var _ref3 = _asyncToGenerator3(_regeneratorRuntime3().mark(function _callee3(data, state, options) {
                    var moov, mdat, _moovStart, res, parsedMoov, segments, videoSegments, audioSegments;
                    return _regeneratorRuntime3().wrap(function _callee3$(_context3) {
                      while (1)
                        switch (_context3.prev = _context3.next) {
                          case 0:
                            if (_this2.meta && options !== null && options !== void 0 && options.range && options.range.length > 0 && options.range[1] >= moovEnd) {
                              state = true;
                              _this2.logger.debug("[loadMetaProcess],data done,setstate true,[", moovStart, moovEnd, "]");
                            }
                            if (state && options !== null && options !== void 0 && options.range && options.range.length > 0 && options.range[1] < moovEnd) {
                              state = false;
                              _this2.logger.debug("[loadMetaProcess],data not done,setstate false,[", moovStart, moovEnd, "]");
                            }
                            _this2.logger.debug("[loadMetaProcess],task,[", moovStart, moovEnd, "], range,", options.range, ",dataLen,", data ? data.byteLength : void 0, ", state,", state, ",err,", _this2._error);
                            !_this2._error && data && data.byteLength > 0 && onProgress(data, state, options);
                            if (!(_this2.meta.moov || _this2._error)) {
                              _context3.next = 6;
                              break;
                            }
                            return _context3.abrupt("return");
                          case 6:
                            if (!(data && data.byteLength > 0)) {
                              _context3.next = 44;
                              break;
                            }
                            _this2.buffer = concatUint8Array2(_this2.buffer, data);
                            moov = MP4Parser.findBox(_this2.buffer, ["moov"])[0];
                            if (moov) {
                              _context3.next = 23;
                              break;
                            }
                            mdat = MP4Parser.findBox(_this2.buffer, ["mdat"])[0];
                            if (!state) {
                              _context3.next = 23;
                              break;
                            }
                            if (mdat) {
                              _context3.next = 18;
                              break;
                            }
                            _this2._error = true;
                            onProgress(null, state, options, {
                              err: "cannot find moov or mdat box"
                            });
                            return _context3.abrupt("return");
                          case 18:
                            _moovStart = mdat.start + mdat.size;
                            _context3.next = 21;
                            return _this2.loadData([_moovStart, ""], cache, config);
                          case 21:
                            res = _context3.sent;
                            if (res) {
                              moov = MP4Parser.findBox(res.data, ["moov"])[0];
                            }
                          case 23:
                            if (!(moov && state && moov.size > moov.data.length)) {
                              _context3.next = 27;
                              break;
                            }
                            _this2.logger.debug("[loadMetaProcess],moov not all, range,", options.range[1], ",dataLen,", _this2.buffer.byteLength, ", state,", state);
                            _context3.next = 27;
                            return _this2.loadMetaProcess(cache, [options.range[1], moov.start + moov.size - 1], onProgress);
                          case 27:
                            if (!(moov && moov.size <= moov.data.length && !_this2.meta.moov)) {
                              _context3.next = 44;
                              break;
                            }
                            parsedMoov = MP4Parser.moov(moov);
                            if (parsedMoov) {
                              _context3.next = 33;
                              break;
                            }
                            _this2._error = true;
                            onProgress(null, state, options, {
                              err: "cannot parse moov box"
                            });
                            return _context3.abrupt("return");
                          case 33:
                            segments = moovToSegments(parsedMoov, _this2._config.segmentDuration);
                            if (segments) {
                              _context3.next = 38;
                              break;
                            }
                            _this2._error = true;
                            onProgress(null, state, options, {
                              err: "cannot parse segments"
                            });
                            return _context3.abrupt("return");
                          case 38:
                            _this2.meta = moovToMeta(parsedMoov);
                            videoSegments = segments.videoSegments, audioSegments = segments.audioSegments;
                            _this2.videoSegments = videoSegments;
                            _this2.audioSegments = audioSegments;
                            _this2.logger.debug("[loadMetaProcess] moov ok");
                            onProgress(void 0, state, {
                              meta: {
                                meta: _this2.meta,
                                videoSegments,
                                audioSegments
                              }
                            });
                          case 44:
                          case "end":
                            return _context3.stop();
                        }
                    }, _callee3);
                  }));
                  return function OnProgressHandle2(_x7, _x8, _x9) {
                    return _ref3.apply(this, arguments);
                  };
                }();
                _context4.next = 6;
                return this.loadData([moovStart, moovEnd || this._config.moovEnd], cache, _objectSpread23({
                  onProgress: OnProgressHandle
                }, config));
              case 6:
              case "end":
                return _context4.stop();
            }
        }, _callee4, this);
      }));
      function loadMetaProcess(_x3, _x4, _x5, _x6) {
        return _loadMetaProcess.apply(this, arguments);
      }
      return loadMetaProcess;
    }()
  }, {
    key: "loadMeta",
    value: function() {
      var _loadMeta = _asyncToGenerator3(_regeneratorRuntime3().mark(function _callee5(cache, moovEnd, config) {
        var responses, res, moov, mdat, moovStart, parsedMoov, segments, videoSegments, audioSegments;
        return _regeneratorRuntime3().wrap(function _callee5$(_context5) {
          while (1)
            switch (_context5.prev = _context5.next) {
              case 0:
                responses = [];
                this.logger.debug("[loadMeta start]");
                _context5.next = 4;
                return this.loadData([0, moovEnd || this._config.moovEnd], cache, config);
              case 4:
                res = _context5.sent;
                if (res) {
                  _context5.next = 7;
                  break;
                }
                return _context5.abrupt("return");
              case 7:
                responses.push(res);
                moov = MP4Parser.findBox(res.data, ["moov"])[0];
                if (moov) {
                  _context5.next = 23;
                  break;
                }
                mdat = MP4Parser.findBox(res.data, ["mdat"])[0];
                if (mdat) {
                  _context5.next = 13;
                  break;
                }
                throw new MediaError("cannot find moov or mdat box", res.data);
              case 13:
                moovStart = mdat.start + mdat.size;
                _context5.next = 16;
                return this.loadData([moovStart], cache, config);
              case 16:
                res = _context5.sent;
                if (res) {
                  _context5.next = 19;
                  break;
                }
                return _context5.abrupt("return");
              case 19:
                responses.push(res);
                moov = MP4Parser.findBox(res.data, ["moov"], moovStart)[0];
                if (moov) {
                  _context5.next = 23;
                  break;
                }
                throw new MediaError("cannot find moov box", res.data);
              case 23:
                if (!(moov.size > moov.data.length)) {
                  _context5.next = 31;
                  break;
                }
                _context5.next = 26;
                return this.loadData([res.data.length, moov.start + moov.size - 1], cache, config);
              case 26:
                res = _context5.sent;
                if (res) {
                  _context5.next = 29;
                  break;
                }
                return _context5.abrupt("return");
              case 29:
                responses.push(res);
                moov.data = concatUint8Array2(moov.data, res.data);
              case 31:
                parsedMoov = MP4Parser.moov(moov);
                if (parsedMoov) {
                  _context5.next = 34;
                  break;
                }
                throw new MediaError("cannot parse moov box", moov.data);
              case 34:
                segments = moovToSegments(parsedMoov, this._config.segmentDuration);
                if (segments) {
                  _context5.next = 37;
                  break;
                }
                throw new MediaError("cannot parse segments", moov.data);
              case 37:
                this.meta = moovToMeta(parsedMoov);
                videoSegments = segments.videoSegments, audioSegments = segments.audioSegments;
                this.videoSegments = videoSegments;
                this.audioSegments = audioSegments;
                this.logger.debug("[load moov end!!!!!]");
                return _context5.abrupt("return", {
                  meta: this.meta,
                  videoSegments,
                  audioSegments,
                  responses
                });
              case 43:
              case "end":
                return _context5.stop();
            }
        }, _callee5, this);
      }));
      function loadMeta(_x10, _x11, _x12) {
        return _loadMeta.apply(this, arguments);
      }
      return loadMeta;
    }()
  }, {
    key: "loadCacheMeta",
    value: function loadCacheMeta(meta, segmentIndex) {
      var moov = meta.moov;
      var segments = moovToSegments(moov, this._config.segmentDuration);
      var videoSegments = segments.videoSegments, audioSegments = segments.audioSegments;
      this.videoSegments = videoSegments;
      this.audioSegments = audioSegments;
      this._currentSegmentIndex = segmentIndex;
      this.meta = meta;
    }
  }, {
    key: "getSegmentByTime",
    value: function getSegmentByTime(time) {
      var video;
      var audio;
      if (!this.videoSegments.length) {
        audio = this.audioSegments.find(function(x2) {
          return x2.startTime <= time && x2.endTime > time;
        });
      } else {
        video = this.videoSegments.find(function(x2) {
          return x2.startTime <= time && x2.endTime > time;
        });
        if (video) {
          audio = this.audioSegments[video.index];
        }
      }
      return {
        video,
        audio
      };
    }
  }, {
    key: "loadSegmentByTime",
    value: function() {
      var _loadSegmentByTime = _asyncToGenerator3(_regeneratorRuntime3().mark(function _callee6(time, cache) {
        var changeCurrent, config, _this$getSegmentByTim, video, audio, _args6 = arguments;
        return _regeneratorRuntime3().wrap(function _callee6$(_context6) {
          while (1)
            switch (_context6.prev = _context6.next) {
              case 0:
                changeCurrent = _args6.length > 2 && _args6[2] !== void 0 ? _args6[2] : true;
                config = _args6.length > 3 && _args6[3] !== void 0 ? _args6[3] : {};
                if (this.isMetaLoaded) {
                  _context6.next = 5;
                  break;
                }
                _context6.next = 5;
                return this.loadMeta(cache);
              case 5:
                _this$getSegmentByTim = this.getSegmentByTime(time), video = _this$getSegmentByTim.video, audio = _this$getSegmentByTim.audio;
                return _context6.abrupt("return", this._loadSegment(video, audio, cache, changeCurrent, config));
              case 7:
              case "end":
                return _context6.stop();
            }
        }, _callee6, this);
      }));
      function loadSegmentByTime(_x13, _x14) {
        return _loadSegmentByTime.apply(this, arguments);
      }
      return loadSegmentByTime;
    }()
  }, {
    key: "loadNextSegment",
    value: function() {
      var _loadNextSegment = _asyncToGenerator3(_regeneratorRuntime3().mark(function _callee7(cache) {
        var changeCurrent, config, video, audio, _args7 = arguments;
        return _regeneratorRuntime3().wrap(function _callee7$(_context7) {
          while (1)
            switch (_context7.prev = _context7.next) {
              case 0:
                changeCurrent = _args7.length > 1 && _args7[1] !== void 0 ? _args7[1] : true;
                config = _args7.length > 2 && _args7[2] !== void 0 ? _args7[2] : {};
                if (this.isMetaLoaded) {
                  _context7.next = 5;
                  break;
                }
                _context7.next = 5;
                return this.loadMeta();
              case 5:
                video = this.videoSegments[this._currentSegmentIndex + 1];
                audio = this.audioSegments[this._currentSegmentIndex + 1];
                return _context7.abrupt("return", this._loadSegment(video, audio, cache, changeCurrent, config));
              case 8:
              case "end":
                return _context7.stop();
            }
        }, _callee7, this);
      }));
      function loadNextSegment(_x15) {
        return _loadNextSegment.apply(this, arguments);
      }
      return loadNextSegment;
    }()
  }, {
    key: "preload",
    value: function() {
      var _preload = _asyncToGenerator3(_regeneratorRuntime3().mark(function _callee9(time) {
        var _this3 = this;
        var _this$getSegmentByTim2, video, audio, index, videos, audios, load;
        return _regeneratorRuntime3().wrap(function _callee9$(_context9) {
          while (1)
            switch (_context9.prev = _context9.next) {
              case 0:
                if (this.isMetaLoaded) {
                  _context9.next = 3;
                  break;
                }
                _context9.next = 3;
                return this.loadMeta(true);
              case 3:
                if (!(!time || time < 0)) {
                  _context9.next = 5;
                  break;
                }
                return _context9.abrupt("return");
              case 5:
                _this$getSegmentByTim2 = this.getSegmentByTime(time), video = _this$getSegmentByTim2.video, audio = _this$getSegmentByTim2.audio;
                index = Math.max((video === null || video === void 0 ? void 0 : video.index) || 0, (audio === null || audio === void 0 ? void 0 : audio.index) || 0);
                if (index) {
                  _context9.next = 9;
                  break;
                }
                return _context9.abrupt("return");
              case 9:
                videos = this.videoSegments.slice(0, index);
                audios = this.audioSegments.slice(0, index);
                load = function() {
                  var _ref4 = _asyncToGenerator3(_regeneratorRuntime3().mark(function _callee8(i) {
                    return _regeneratorRuntime3().wrap(function _callee8$(_context8) {
                      while (1)
                        switch (_context8.prev = _context8.next) {
                          case 0:
                            if (!(i > index)) {
                              _context8.next = 2;
                              break;
                            }
                            return _context8.abrupt("return");
                          case 2:
                            _context8.next = 4;
                            return _this3._loadSegment(videos[i], audios[i], true, false);
                          case 4:
                            _context8.next = 6;
                            return load(i + 1);
                          case 6:
                          case "end":
                            return _context8.stop();
                        }
                    }, _callee8);
                  }));
                  return function load2(_x17) {
                    return _ref4.apply(this, arguments);
                  };
                }();
                _context9.next = 14;
                return load(0);
              case 14:
              case "end":
                return _context9.stop();
            }
        }, _callee9, this);
      }));
      function preload(_x16) {
        return _preload.apply(this, arguments);
      }
      return preload;
    }()
  }, {
    key: "cancel",
    value: function cancel() {
      return this._loader.cancel();
    }
  }, {
    key: "reset",
    value: function() {
      var _reset = _asyncToGenerator3(_regeneratorRuntime3().mark(function _callee10() {
        var notCancelLoader, _args10 = arguments;
        return _regeneratorRuntime3().wrap(function _callee10$(_context10) {
          while (1)
            switch (_context10.prev = _context10.next) {
              case 0:
                notCancelLoader = _args10.length > 0 && _args10[0] !== void 0 ? _args10[0] : false;
                if (notCancelLoader) {
                  _context10.next = 5;
                  break;
                }
                this.logger.debug("[MP4loader reset func call loader.cancel]");
                _context10.next = 5;
                return this._loader.cancel();
              case 5:
                this.vid = this.url = "";
                this.meta = {};
                this.downloadInfo = [];
                this.videoSegments = [];
                this.audioSegments = [];
                this._currentSegmentIndex = -1;
                this._currentLoadingSegmentIndex = -1;
              case 12:
              case "end":
                return _context10.stop();
            }
        }, _callee10, this);
      }));
      function reset() {
        return _reset.apply(this, arguments);
      }
      return reset;
    }()
  }, {
    key: "destroy",
    value: function() {
      var _destroy = _asyncToGenerator3(_regeneratorRuntime3().mark(function _callee11() {
        return _regeneratorRuntime3().wrap(function _callee11$(_context11) {
          while (1)
            switch (_context11.prev = _context11.next) {
              case 0:
                _context11.next = 2;
                return this.reset();
              case 2:
                this.cache.clear();
              case 3:
              case "end":
                return _context11.stop();
            }
        }, _callee11, this);
      }));
      function destroy() {
        return _destroy.apply(this, arguments);
      }
      return destroy;
    }()
  }, {
    key: "_loadSegment",
    value: function() {
      var _loadSegment2 = _asyncToGenerator3(_regeneratorRuntime3().mark(function _callee12(video, audio, cache, changeCurrent, config) {
        var segIndex, res;
        return _regeneratorRuntime3().wrap(function _callee12$(_context12) {
          while (1)
            switch (_context12.prev = _context12.next) {
              case 0:
                if (!(!video && !audio)) {
                  _context12.next = 2;
                  break;
                }
                return _context12.abrupt("return");
              case 2:
                segIndex = (video === null || video === void 0 ? void 0 : video.index) || (audio === null || audio === void 0 ? void 0 : audio.index) || 0;
                this._currentLoadingSegmentIndex = segIndex;
                _context12.prev = 4;
                _context12.next = 7;
                return this.loadData([Math.min((video === null || video === void 0 ? void 0 : video.range[0]) || Infinity, (audio === null || audio === void 0 ? void 0 : audio.range[0]) || Infinity), Math.max((video === null || video === void 0 ? void 0 : video.range[1]) || 0, (audio === null || audio === void 0 ? void 0 : audio.range[1]) || 0)], cache, config);
              case 7:
                res = _context12.sent;
              case 8:
                _context12.prev = 8;
                this._currentLoadingSegmentIndex = -1;
                return _context12.finish(8);
              case 11:
                if (res) {
                  _context12.next = 13;
                  break;
                }
                return _context12.abrupt("return");
              case 13:
                if (changeCurrent) {
                  this._currentSegmentIndex = segIndex;
                }
                res.video = video;
                res.audio = audio;
                return _context12.abrupt("return", res);
              case 17:
              case "end":
                return _context12.stop();
            }
        }, _callee12, this, [[4, , 8, 11]]);
      }));
      function _loadSegment(_x18, _x19, _x20, _x21, _x22) {
        return _loadSegment2.apply(this, arguments);
      }
      return _loadSegment;
    }()
  }, {
    key: "loadData",
    value: function() {
      var _loadData = _asyncToGenerator3(_regeneratorRuntime3().mark(function _callee13(range, cache, config) {
        var cacheKey, data, res, url;
        return _regeneratorRuntime3().wrap(function _callee13$(_context13) {
          while (1)
            switch (_context13.prev = _context13.next) {
              case 0:
                cacheKey = this._getCacheKey(range);
                _context13.next = 3;
                return this.cache.get(cacheKey);
              case 3:
                data = _context13.sent;
                if (data) {
                  _context13.next = 11;
                  break;
                }
                url = config && config.url ? config.url : this.url;
                _context13.next = 8;
                return this._loader.load(url, _objectSpread23({
                  range,
                  vid: this.vid
                }, config));
              case 8:
                res = _context13.sent;
                _context13.next = 12;
                break;
              case 11:
                res = {
                  data,
                  state: true,
                  options: {
                    fromCache: true,
                    range,
                    vid: this.vid
                  }
                };
              case 12:
                if (res) {
                  _context13.next = 14;
                  break;
                }
                return _context13.abrupt("return");
              case 14:
                if (!data) {
                  res.data && this.downloadInfo.push({
                    startTime: res.startTime,
                    endTime: res.endTime,
                    size: res.data.byteLength,
                    range
                  });
                  if (this.downloadInfo && this.downloadInfo.length > this._config.maxDownloadInfoSize) {
                    this.downloadInfo = this.downloadInfo.slice(-this._config.maxDownloadInfoSize);
                  }
                }
                return _context13.abrupt("return", res);
              case 17:
              case "end":
                return _context13.stop();
            }
        }, _callee13, this);
      }));
      function loadData(_x23, _x24, _x25) {
        return _loadData.apply(this, arguments);
      }
      return loadData;
    }()
  }, {
    key: "_getCacheKey",
    value: function _getCacheKey(range) {
      return (this.vid || this.url) + ":" + range;
    }
  }]);
  return MP4Loader2;
}(import_eventemitter35.default);

// node_modules/xgplayer-mp4/es/util/logger.js
var isSupport = _isLocalStorageUsable();
var openLog = checkOpenLog();
checkTestOpenLog();
function probeSupport() {
  try {
    return typeof localStorage !== "undefined" && "setItem" in window.localStorage && !!window.localStorage.setItem;
  } catch (e) {
    return false;
  }
}
function checkIfLocalStorageThrows() {
  var localStorageTestKey = "_localstorage_support_test";
  try {
    window.localStorage.setItem(localStorageTestKey, true);
    window.localStorage.removeItem(localStorageTestKey);
    return false;
  } catch (e) {
    return true;
  }
}
function checkOpenLog() {
  if (isSupport) {
    try {
      return !!window.localStorage.getItem("playerlog");
    } catch (e) {
      return false;
    }
  }
  return false;
}
function _isLocalStorageUsable() {
  return probeSupport() && !checkIfLocalStorageThrows();
}
function log(message) {
  var _console;
  for (var _len = arguments.length, optionalParams = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
    optionalParams[_key - 1] = arguments[_key];
  }
  openLog && console.log && (_console = console).log.apply(_console, ["[logger]", util2.nowTime(), message].concat(optionalParams));
}
function checkTestOpenLog() {
  if (isSupport) {
    try {
      return !!window.localStorage.getItem("playertestlog");
    } catch (e) {
      return false;
    }
  }
  return false;
}

// node_modules/xgplayer-mp4/es/worker/index.js
var import_eventemitter36 = __toESM(require_eventemitter3());

// node_modules/xgplayer-mp4/es/worker/transmuxerworker.js
var encodedJs = "IWZ1bmN0aW9uKCl7InVzZSBzdHJpY3QiO2Z1bmN0aW9uIGUoZSx0KXt2YXIgcj1PYmplY3Qua2V5cyhlKTtpZihPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKXt2YXIgYT1PYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKGUpO3QmJihhPWEuZmlsdGVyKChmdW5jdGlvbih0KXtyZXR1cm4gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihlLHQpLmVudW1lcmFibGV9KSkpLHIucHVzaC5hcHBseShyLGEpfXJldHVybiByfWZ1bmN0aW9uIHQodCl7Zm9yKHZhciByPTE7cjxhcmd1bWVudHMubGVuZ3RoO3IrKyl7dmFyIGE9bnVsbCE9YXJndW1lbnRzW3JdP2FyZ3VtZW50c1tyXTp7fTtyJTI/ZShPYmplY3QoYSksITApLmZvckVhY2goKGZ1bmN0aW9uKGUpe2kodCxlLGFbZV0pfSkpOk9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JzP09iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKHQsT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcnMoYSkpOmUoT2JqZWN0KGEpKS5mb3JFYWNoKChmdW5jdGlvbihlKXtPYmplY3QuZGVmaW5lUHJvcGVydHkodCxlLE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IoYSxlKSl9KSl9cmV0dXJuIHR9ZnVuY3Rpb24gcihlLHQpe2lmKCEoZSBpbnN0YW5jZW9mIHQpKXRocm93IG5ldyBUeXBlRXJyb3IoIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvbiIpfWZ1bmN0aW9uIGEoZSx0KXtmb3IodmFyIHI9MDtyPHQubGVuZ3RoO3IrKyl7dmFyIGE9dFtyXTthLmVudW1lcmFibGU9YS5lbnVtZXJhYmxlfHwhMSxhLmNvbmZpZ3VyYWJsZT0hMCwidmFsdWUiaW4gYSYmKGEud3JpdGFibGU9ITApLE9iamVjdC5kZWZpbmVQcm9wZXJ0eShlLGsoYS5rZXkpLGEpfX1mdW5jdGlvbiBuKGUsdCxyKXtyZXR1cm4gdCYmYShlLnByb3RvdHlwZSx0KSxyJiZhKGUsciksT2JqZWN0LmRlZmluZVByb3BlcnR5KGUsInByb3RvdHlwZSIse3dyaXRhYmxlOiExfSksZX1mdW5jdGlvbiBpKGUsdCxyKXtyZXR1cm4odD1rKHQpKWluIGU/T2JqZWN0LmRlZmluZVByb3BlcnR5KGUsdCx7dmFsdWU6cixlbnVtZXJhYmxlOiEwLGNvbmZpZ3VyYWJsZTohMCx3cml0YWJsZTohMH0pOmVbdF09cixlfWZ1bmN0aW9uIHMoZSx0KXtpZigiZnVuY3Rpb24iIT10eXBlb2YgdCYmbnVsbCE9PXQpdGhyb3cgbmV3IFR5cGVFcnJvcigiU3VwZXIgZXhwcmVzc2lvbiBtdXN0IGVpdGhlciBiZSBudWxsIG9yIGEgZnVuY3Rpb24iKTtlLnByb3RvdHlwZT1PYmplY3QuY3JlYXRlKHQmJnQucHJvdG90eXBlLHtjb25zdHJ1Y3Rvcjp7dmFsdWU6ZSx3cml0YWJsZTohMCxjb25maWd1cmFibGU6ITB9fSksT2JqZWN0LmRlZmluZVByb3BlcnR5KGUsInByb3RvdHlwZSIse3dyaXRhYmxlOiExfSksdCYmdShlLHQpfWZ1bmN0aW9uIG8oZSl7cmV0dXJuKG89T2JqZWN0LnNldFByb3RvdHlwZU9mP09iamVjdC5nZXRQcm90b3R5cGVPZi5iaW5kKCk6ZnVuY3Rpb24oZSl7cmV0dXJuIGUuX19wcm90b19ffHxPYmplY3QuZ2V0UHJvdG90eXBlT2YoZSl9KShlKX1mdW5jdGlvbiB1KGUsdCl7cmV0dXJuKHU9T2JqZWN0LnNldFByb3RvdHlwZU9mP09iamVjdC5zZXRQcm90b3R5cGVPZi5iaW5kKCk6ZnVuY3Rpb24oZSx0KXtyZXR1cm4gZS5fX3Byb3RvX189dCxlfSkoZSx0KX1mdW5jdGlvbiBjKCl7aWYoInVuZGVmaW5lZCI9PXR5cGVvZiBSZWZsZWN0fHwhUmVmbGVjdC5jb25zdHJ1Y3QpcmV0dXJuITE7aWYoUmVmbGVjdC5jb25zdHJ1Y3Quc2hhbSlyZXR1cm4hMTtpZigiZnVuY3Rpb24iPT10eXBlb2YgUHJveHkpcmV0dXJuITA7dHJ5e3JldHVybiBCb29sZWFuLnByb3RvdHlwZS52YWx1ZU9mLmNhbGwoUmVmbGVjdC5jb25zdHJ1Y3QoQm9vbGVhbixbXSwoZnVuY3Rpb24oKXt9KSkpLCEwfWNhdGNoKGUpe3JldHVybiExfX1mdW5jdGlvbiBsKGUsdCxyKXtyZXR1cm4obD1jKCk/UmVmbGVjdC5jb25zdHJ1Y3QuYmluZCgpOmZ1bmN0aW9uKGUsdCxyKXt2YXIgYT1bbnVsbF07YS5wdXNoLmFwcGx5KGEsdCk7dmFyIG49bmV3KEZ1bmN0aW9uLmJpbmQuYXBwbHkoZSxhKSk7cmV0dXJuIHImJnUobixyLnByb3RvdHlwZSksbn0pLmFwcGx5KG51bGwsYXJndW1lbnRzKX1mdW5jdGlvbiBmKGUsdCl7aWYodCYmKCJvYmplY3QiPT10eXBlb2YgdHx8ImZ1bmN0aW9uIj09dHlwZW9mIHQpKXJldHVybiB0O2lmKHZvaWQgMCE9PXQpdGhyb3cgbmV3IFR5cGVFcnJvcigiRGVyaXZlZCBjb25zdHJ1Y3RvcnMgbWF5IG9ubHkgcmV0dXJuIG9iamVjdCBvciB1bmRlZmluZWQiKTtyZXR1cm4gZnVuY3Rpb24oZSl7aWYodm9pZCAwPT09ZSl0aHJvdyBuZXcgUmVmZXJlbmNlRXJyb3IoInRoaXMgaGFzbid0IGJlZW4gaW5pdGlhbGlzZWQgLSBzdXBlcigpIGhhc24ndCBiZWVuIGNhbGxlZCIpO3JldHVybiBlfShlKX1mdW5jdGlvbiBkKGUpe3ZhciB0PWMoKTtyZXR1cm4gZnVuY3Rpb24oKXt2YXIgcixhPW8oZSk7aWYodCl7dmFyIG49byh0aGlzKS5jb25zdHJ1Y3RvcjtyPVJlZmxlY3QuY29uc3RydWN0KGEsYXJndW1lbnRzLG4pfWVsc2Ugcj1hLmFwcGx5KHRoaXMsYXJndW1lbnRzKTtyZXR1cm4gZih0aGlzLHIpfX1mdW5jdGlvbiBoKGUsdCl7Zm9yKDshT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKGUsdCkmJm51bGwhPT0oZT1vKGUpKTspO3JldHVybiBlfWZ1bmN0aW9uIHAoKXtyZXR1cm4gcD0idW5kZWZpbmVkIiE9dHlwZW9mIFJlZmxlY3QmJlJlZmxlY3QuZ2V0P1JlZmxlY3QuZ2V0LmJpbmQoKTpmdW5jdGlvbihlLHQscil7dmFyIGE9aChlLHQpO2lmKGEpe3ZhciBuPU9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IoYSx0KTtyZXR1cm4gbi5nZXQ/bi5nZXQuY2FsbChhcmd1bWVudHMubGVuZ3RoPDM/ZTpyKTpuLnZhbHVlfX0scC5hcHBseSh0aGlzLGFyZ3VtZW50cyl9ZnVuY3Rpb24gdihlLHQpe3JldHVybiBmdW5jdGlvbihlKXtpZihBcnJheS5pc0FycmF5KGUpKXJldHVybiBlfShlKXx8ZnVuY3Rpb24oZSx0KXt2YXIgcj1udWxsPT1lP251bGw6InVuZGVmaW5lZCIhPXR5cGVvZiBTeW1ib2wmJmVbU3ltYm9sLml0ZXJhdG9yXXx8ZVsiQEBpdGVyYXRvciJdO2lmKG51bGwhPXIpe3ZhciBhLG4saSxzLG89W10sdT0hMCxjPSExO3RyeXtpZihpPShyPXIuY2FsbChlKSkubmV4dCwwPT09dCl7aWYoT2JqZWN0KHIpIT09cilyZXR1cm47dT0hMX1lbHNlIGZvcig7ISh1PShhPWkuY2FsbChyKSkuZG9uZSkmJihvLnB1c2goYS52YWx1ZSksby5sZW5ndGghPT10KTt1PSEwKTt9Y2F0Y2gobCl7Yz0hMCxuPWx9ZmluYWxseXt0cnl7aWYoIXUmJm51bGwhPXIucmV0dXJuJiYocz1yLnJldHVybigpLE9iamVjdChzKSE9PXMpKXJldHVybn1maW5hbGx5e2lmKGMpdGhyb3cgbn19cmV0dXJuIG99fShlLHQpfHxtKGUsdCl8fGZ1bmN0aW9uKCl7dGhyb3cgbmV3IFR5cGVFcnJvcigiSW52YWxpZCBhdHRlbXB0IHRvIGRlc3RydWN0dXJlIG5vbi1pdGVyYWJsZSBpbnN0YW5jZS5cbkluIG9yZGVyIHRvIGJlIGl0ZXJhYmxlLCBub24tYXJyYXkgb2JqZWN0cyBtdXN0IGhhdmUgYSBbU3ltYm9sLml0ZXJhdG9yXSgpIG1ldGhvZC4iKX0oKX1mdW5jdGlvbiB5KGUpe3JldHVybiBmdW5jdGlvbihlKXtpZihBcnJheS5pc0FycmF5KGUpKXJldHVybiBnKGUpfShlKXx8ZnVuY3Rpb24oZSl7aWYoInVuZGVmaW5lZCIhPXR5cGVvZiBTeW1ib2wmJm51bGwhPWVbU3ltYm9sLml0ZXJhdG9yXXx8bnVsbCE9ZVsiQEBpdGVyYXRvciJdKXJldHVybiBBcnJheS5mcm9tKGUpfShlKXx8bShlKXx8ZnVuY3Rpb24oKXt0aHJvdyBuZXcgVHlwZUVycm9yKCJJbnZhbGlkIGF0dGVtcHQgdG8gc3ByZWFkIG5vbi1pdGVyYWJsZSBpbnN0YW5jZS5cbkluIG9yZGVyIHRvIGJlIGl0ZXJhYmxlLCBub24tYXJyYXkgb2JqZWN0cyBtdXN0IGhhdmUgYSBbU3ltYm9sLml0ZXJhdG9yXSgpIG1ldGhvZC4iKX0oKX1mdW5jdGlvbiBtKGUsdCl7aWYoZSl7aWYoInN0cmluZyI9PXR5cGVvZiBlKXJldHVybiBnKGUsdCk7dmFyIHI9T2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKGUpLnNsaWNlKDgsLTEpO3JldHVybiJPYmplY3QiPT09ciYmZS5jb25zdHJ1Y3RvciYmKHI9ZS5jb25zdHJ1Y3Rvci5uYW1lKSwiTWFwIj09PXJ8fCJTZXQiPT09cj9BcnJheS5mcm9tKGUpOiJBcmd1bWVudHMiPT09cnx8L14oPzpVaXxJKW50KD86OHwxNnwzMikoPzpDbGFtcGVkKT9BcnJheSQvLnRlc3Qocik/ZyhlLHQpOnZvaWQgMH19ZnVuY3Rpb24gZyhlLHQpeyhudWxsPT10fHx0PmUubGVuZ3RoKSYmKHQ9ZS5sZW5ndGgpO2Zvcih2YXIgcj0wLGE9bmV3IEFycmF5KHQpO3I8dDtyKyspYVtyXT1lW3JdO3JldHVybiBhfWZ1bmN0aW9uIGsoZSl7dmFyIHQ9ZnVuY3Rpb24oZSx0KXtpZigib2JqZWN0IiE9dHlwZW9mIGV8fG51bGw9PT1lKXJldHVybiBlO3ZhciByPWVbU3ltYm9sLnRvUHJpbWl0aXZlXTtpZih2b2lkIDAhPT1yKXt2YXIgYT1yLmNhbGwoZSx0fHwiZGVmYXVsdCIpO2lmKCJvYmplY3QiIT10eXBlb2YgYSlyZXR1cm4gYTt0aHJvdyBuZXcgVHlwZUVycm9yKCJAQHRvUHJpbWl0aXZlIG11c3QgcmV0dXJuIGEgcHJpbWl0aXZlIHZhbHVlLiIpfXJldHVybigic3RyaW5nIj09PXQ/U3RyaW5nOk51bWJlcikoZSl9KGUsInN0cmluZyIpO3JldHVybiJzeW1ib2wiPT10eXBlb2YgdD90OlN0cmluZyh0KX12YXIgYj0idmlkZW8iLF89ImF1ZGlvIix3PSJtZXRhZGF0YSIseD0iYXZjIixTPSJoZXZjIixBPSJhYWMiLEQ9Imc3MTEwYSIsRT0iZzcxMTBtIixCPSJMQVJHRV9BVl9TSElGVCIsVD0iTEFSR0VfVklERU9fR0FQIixDPSJMQVJHRV9WSURFT19HQVBfQkVUV0VFTl9DSFVOSyIsVT0iTEFSR0VfQVVESU9fR0FQIixQPSJBVURJT19GSUxMRUQiLEk9IkFVRElPX0RST1BQRUQiLHo9ZnVuY3Rpb24oKXtmdW5jdGlvbiBlKCl7cih0aGlzLGUpLGkodGhpcywiaWQiLDEpLGkodGhpcywidHlwZSIsYiksaSh0aGlzLCJjb2RlY1R5cGUiLHgpLGkodGhpcywicGlkIiwtMSksaSh0aGlzLCJodmNDIix2b2lkIDApLGkodGhpcywiY29kZWMiLCIiKSxpKHRoaXMsInRpbWVzY2FsZSIsMCksaSh0aGlzLCJmb3JtYXRUaW1lc2NhbGUiLDApLGkodGhpcywic2VxdWVuY2VOdW1iZXIiLDApLGkodGhpcywiYmFzZU1lZGlhRGVjb2RlVGltZSIsMCksaSh0aGlzLCJiYXNlRHRzIiwwKSxpKHRoaXMsImR1cmF0aW9uIiwwKSxpKHRoaXMsIndhcm5pbmdzIixbXSksaSh0aGlzLCJzYW1wbGVzIixbXSksaSh0aGlzLCJwcHMiLFtdKSxpKHRoaXMsInNwcyIsW10pLGkodGhpcywidnBzIixbXSksaSh0aGlzLCJmcHNOdW0iLDApLGkodGhpcywiZnBzRGVuIiwwKSxpKHRoaXMsInNhclJhdGlvIixbXSksaSh0aGlzLCJ3aWR0aCIsMCksaSh0aGlzLCJoZWlnaHQiLDApLGkodGhpcywibmFsVW5pdFNpemUiLDQpLGkodGhpcywicHJlc2VudCIsITEpLGkodGhpcywiaXNWaWRlb0VuY3J5cHRpb24iLCExKSxpKHRoaXMsImlzQXVkaW9FbmNyeXB0aW9uIiwhMSksaSh0aGlzLCJpc1ZpZGVvIiwhMCksaSh0aGlzLCJraWQiLG51bGwpLGkodGhpcywicHNzaCIsbnVsbCksaSh0aGlzLCJleHQiLHZvaWQgMCl9cmV0dXJuIG4oZSxbe2tleToicmVzZXQiLHZhbHVlOmZ1bmN0aW9uKCl7dGhpcy5zZXF1ZW5jZU51bWJlcj10aGlzLndpZHRoPXRoaXMuaGVpZ2h0PXRoaXMuZnBzRGVuPXRoaXMuZnBzTnVtPXRoaXMuZHVyYXRpb249dGhpcy5iYXNlTWVkaWFEZWNvZGVUaW1lPXRoaXMudGltZXNjYWxlPTAsdGhpcy5jb2RlYz0iIix0aGlzLnByZXNlbnQ9ITEsdGhpcy5waWQ9LTEsdGhpcy5wcHM9W10sdGhpcy5zcHM9W10sdGhpcy52cHM9W10sdGhpcy5zYXJSYXRpbz1bXSx0aGlzLnNhbXBsZXM9W10sdGhpcy53YXJuaW5ncz1bXSx0aGlzLmh2Y0M9bnVsbH19LHtrZXk6ImZpcnN0RHRzIixnZXQ6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5zYW1wbGVzLmxlbmd0aD90aGlzLnNhbXBsZXNbMF0uZHRzOm51bGx9fSx7a2V5OiJmaXJzdFB0cyIsZ2V0OmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuc2FtcGxlcy5sZW5ndGg/dGhpcy5zYW1wbGVzWzBdLnB0czpudWxsfX0se2tleToic2FtcGxlc0R1cmF0aW9uIixnZXQ6ZnVuY3Rpb24oKXtpZih0aGlzLnNhbXBsZXMubGVuZ3RoPjApe3ZhciBlPXRoaXMuc2FtcGxlc1swXSx0PXRoaXMuc2FtcGxlc1t0aGlzLnNhbXBsZXMubGVuZ3RoLTFdO3JldHVybiB0LmR0cy1lLmR0cyt0LmR1cmF0aW9ufXJldHVybiAwfX0se2tleToiZXhpc3QiLHZhbHVlOmZ1bmN0aW9uKCl7cmV0dXJuISEodGhpcy5wcHMubGVuZ3RoJiZ0aGlzLnNwcy5sZW5ndGgmJnRoaXMuY29kZWMpfX0se2tleToiaGFzU2FtcGxlIix2YWx1ZTpmdW5jdGlvbigpe3JldHVybiEhdGhpcy5zYW1wbGVzLmxlbmd0aH19LHtrZXk6ImlzRW5jcnlwdGlvbiIsZ2V0OmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuaXNWaWRlb0VuY3J5cHRpb259fV0pLGV9KCksTT1mdW5jdGlvbigpe2Z1bmN0aW9uIGUoKXtyKHRoaXMsZSksaSh0aGlzLCJpZCIsMiksaSh0aGlzLCJ0eXBlIixfKSxpKHRoaXMsImNvZGVjVHlwZSIsQSksaSh0aGlzLCJwaWQiLC0xKSxpKHRoaXMsImNvZGVjIiwiIiksaSh0aGlzLCJzZXF1ZW5jZU51bWJlciIsMCksaSh0aGlzLCJzYW1wbGVEdXJhdGlvbiIsMCksaSh0aGlzLCJ0aW1lc2NhbGUiLDApLGkodGhpcywiZm9ybWF0VGltZXNjYWxlIiwwKSxpKHRoaXMsImJhc2VNZWRpYURlY29kZVRpbWUiLDApLGkodGhpcywiZHVyYXRpb24iLDApLGkodGhpcywid2FybmluZ3MiLFtdKSxpKHRoaXMsInNhbXBsZXMiLFtdKSxpKHRoaXMsImJhc2VEdHMiLDApLGkodGhpcywic2FtcGxlU2l6ZSIsMTYpLGkodGhpcywic2FtcGxlUmF0ZSIsMCksaSh0aGlzLCJjaGFubmVsQ291bnQiLDApLGkodGhpcywib2JqZWN0VHlwZSIsMCksaSh0aGlzLCJzYW1wbGVSYXRlSW5kZXgiLDApLGkodGhpcywiY29uZmlnIixbXSksaSh0aGlzLCJwcmVzZW50IiwhMSksaSh0aGlzLCJpc1ZpZGVvRW5jcnlwdGlvbiIsITEpLGkodGhpcywiaXNBdWRpb0VuY3J5cHRpb24iLCExKSxpKHRoaXMsImtpZCIsbnVsbCksaSh0aGlzLCJleHQiLHZvaWQgMCl9cmV0dXJuIG4oZSxbe2tleToicmVzZXQiLHZhbHVlOmZ1bmN0aW9uKCl7dGhpcy5zZXF1ZW5jZU51bWJlcj0wLHRoaXMudGltZXNjYWxlPTAsdGhpcy5zYW1wbGVEdXJhdGlvbj0wLHRoaXMuc2FtcGxlUmF0ZT0wLHRoaXMuY2hhbm5lbENvdW50PTAsdGhpcy5iYXNlTWVkaWFEZWNvZGVUaW1lPTAsdGhpcy5wcmVzZW50PSExLHRoaXMucGlkPS0xLHRoaXMuY29kZWM9IiIsdGhpcy5zYW1wbGVzPVtdLHRoaXMuY29uZmlnPVtdLHRoaXMud2FybmluZ3M9W119fSx7a2V5OiJleGlzdCIsdmFsdWU6ZnVuY3Rpb24oKXtyZXR1cm4hISh0aGlzLnNhbXBsZVJhdGUmJnRoaXMuY2hhbm5lbENvdW50JiZ0aGlzLmNvZGVjJiZ0aGlzLmNvZGVjVHlwZT09PUEpfX0se2tleToiaGFzU2FtcGxlIix2YWx1ZTpmdW5jdGlvbigpe3JldHVybiEhdGhpcy5zYW1wbGVzLmxlbmd0aH19LHtrZXk6ImlzRW5jcnlwdGlvbiIsZ2V0OmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuaXNBdWRpb0VuY3J5cHRpb259fSx7a2V5OiJmaXJzdER0cyIsZ2V0OmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuc2FtcGxlcy5sZW5ndGg/dGhpcy5zYW1wbGVzWzBdLmR0czpudWxsfX0se2tleToiZmlyc3RQdHMiLGdldDpmdW5jdGlvbigpe3JldHVybiB0aGlzLnNhbXBsZXMubGVuZ3RoP3RoaXMuc2FtcGxlc1swXS5wdHM6bnVsbH19LHtrZXk6InNhbXBsZXNEdXJhdGlvbiIsZ2V0OmZ1bmN0aW9uKCl7aWYodGhpcy5zYW1wbGVzLmxlbmd0aD4wKXt2YXIgZT10aGlzLnNhbXBsZXNbMF0sdD10aGlzLnNhbXBsZXNbdGhpcy5zYW1wbGVzLmxlbmd0aC0xXTtyZXR1cm4gdC5kdHMtZS5kdHMrdC5kdXJhdGlvbn1yZXR1cm4gMH19XSksZX0oKSxSPWZ1bmN0aW9uKCl7ZnVuY3Rpb24gZSh0LGEsbil7cih0aGlzLGUpLGkodGhpcywiZmxhZyIse30pLGkodGhpcywia2V5ZnJhbWUiLCExKSxpKHRoaXMsImdvcElkIiwwKSxpKHRoaXMsImR1cmF0aW9uIiwwKSxpKHRoaXMsInNpemUiLDApLGkodGhpcywidW5pdHMiLFtdKSxpKHRoaXMsImNocm9tYUZvcm1hdCIsNDIwKSx0aGlzLm9yaWdpblB0cz10aGlzLnB0cz10LHRoaXMub3JpZ2luRHRzPXRoaXMuZHRzPWEsbiYmKHRoaXMudW5pdHM9bil9cmV0dXJuIG4oZSxbe2tleToiY3RzIixnZXQ6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5wdHMtdGhpcy5kdHN9fSx7a2V5OiJzZXRUb0tleWZyYW1lIix2YWx1ZTpmdW5jdGlvbigpe3RoaXMua2V5ZnJhbWU9ITAsdGhpcy5mbGFnLmRlcGVuZHNPbj0yLHRoaXMuZmxhZy5pc05vblN5bmNTYW1wbGU9MH19XSksZX0oKSxPPW4oKGZ1bmN0aW9uIGUodCxhLG4scyl7cih0aGlzLGUpLGkodGhpcywiZHVyYXRpb24iLDEwMjQpLGkodGhpcywiZmxhZyIse2RlcGVuZHNPbjoyLGlzTm9uU3luY1NhbXBsZTowfSksaSh0aGlzLCJrZXlmcmFtZSIsITApLHRoaXMub3JpZ2luUHRzPXRoaXMucHRzPXRoaXMuZHRzPXQsdGhpcy5kYXRhPWEsdGhpcy5zaXplPWEuYnl0ZUxlbmd0aCx0aGlzLnNhbXBsZU9mZnNldD1zLG4mJih0aGlzLmR1cmF0aW9uPW4pfSkpLEw9bigoZnVuY3Rpb24gZSh0LGEpe3IodGhpcyxlKSxpKHRoaXMsInRpbWUiLDApLHRoaXMuZGF0YT10LHRoaXMub3JpZ2luUHRzPXRoaXMucHRzPWF9KSksVj1mdW5jdGlvbihlKXtzKGEsZSk7dmFyIHQ9ZChhKTtmdW5jdGlvbiBhKCl7cmV0dXJuIHIodGhpcyxhKSx0LmFwcGx5KHRoaXMsYXJndW1lbnRzKX1yZXR1cm4gbihhKX0oTCksRj1mdW5jdGlvbihlKXtzKGEsZSk7dmFyIHQ9ZChhKTtmdW5jdGlvbiBhKCl7cmV0dXJuIHIodGhpcyxhKSx0LmFwcGx5KHRoaXMsYXJndW1lbnRzKX1yZXR1cm4gbihhKX0oTCksTj1mdW5jdGlvbigpe2Z1bmN0aW9uIGUoKXtyKHRoaXMsZSksaSh0aGlzLCJpZCIsMyksaSh0aGlzLCJ0eXBlIix3KSxpKHRoaXMsInRpbWVzY2FsZSIsMCksaSh0aGlzLCJmbHZTY3JpcHRTYW1wbGVzIixbXSksaSh0aGlzLCJzZWlTYW1wbGVzIixbXSl9cmV0dXJuIG4oZSxbe2tleToiZXhpc3QiLHZhbHVlOmZ1bmN0aW9uKCl7cmV0dXJuISghdGhpcy5mbHZTY3JpcHRTYW1wbGVzLmxlbmd0aCYmIXRoaXMuc2VpU2FtcGxlcy5sZW5ndGh8fCF0aGlzLnRpbWVzY2FsZSl9fSx7a2V5OiJyZXNldCIsdmFsdWU6ZnVuY3Rpb24oKXt0aGlzLnRpbWVzY2FsZT0wLHRoaXMuZmx2U2NyaXB0U2FtcGxlcz1bXSx0aGlzLnNlaVNhbXBsZXM9W119fSx7a2V5OiJoYXNTYW1wbGUiLHZhbHVlOmZ1bmN0aW9uKCl7cmV0dXJuISghdGhpcy5mbHZTY3JpcHRTYW1wbGVzLmxlbmd0aCYmIXRoaXMuc2VpU2FtcGxlcy5sZW5ndGgpfX1dKSxlfSgpLGo9ZnVuY3Rpb24oKXtmdW5jdGlvbiBlKHQpe2lmKHIodGhpcyxlKSxpKHRoaXMsIl9ieXRlc0F2YWlsYWJsZSIsdm9pZCAwKSxpKHRoaXMsIl9iaXRzQXZhaWxhYmxlIiwwKSxpKHRoaXMsIl93b3JkIiwwKSwhdCl0aHJvdyBuZXcgRXJyb3IoIkV4cEdvbG9tYiBkYXRhIHBhcmFtcyBpcyByZXF1aXJlZCIpO3RoaXMuX2RhdGE9dCx0aGlzLl9ieXRlc0F2YWlsYWJsZT10LmJ5dGVMZW5ndGgsdGhpcy5fYnl0ZXNBdmFpbGFibGUmJnRoaXMuX2xvYWRXb3JkKCl9cmV0dXJuIG4oZSxbe2tleToiYml0c0F2YWlsYWJsZSIsZ2V0OmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuX2JpdHNBdmFpbGFibGV9fSx7a2V5OiJfbG9hZFdvcmQiLHZhbHVlOmZ1bmN0aW9uKCl7dmFyIGU9dGhpcy5fZGF0YS5ieXRlTGVuZ3RoLXRoaXMuX2J5dGVzQXZhaWxhYmxlLHQ9TWF0aC5taW4oNCx0aGlzLl9ieXRlc0F2YWlsYWJsZSk7aWYoMD09PXQpdGhyb3cgbmV3IEVycm9yKCJObyBieXRlcyBhdmFpbGFibGUiKTt2YXIgcj1uZXcgVWludDhBcnJheSg0KTtyLnNldCh0aGlzLl9kYXRhLnN1YmFycmF5KGUsZSt0KSksdGhpcy5fd29yZD1uZXcgRGF0YVZpZXcoci5idWZmZXIpLmdldFVpbnQzMigwKSx0aGlzLl9iaXRzQXZhaWxhYmxlPTgqdCx0aGlzLl9ieXRlc0F2YWlsYWJsZS09dH19LHtrZXk6InNraXBCaXRzIix2YWx1ZTpmdW5jdGlvbihlKXtpZih0aGlzLl9iaXRzQXZhaWxhYmxlPmUpdGhpcy5fd29yZDw8PWUsdGhpcy5fYml0c0F2YWlsYWJsZS09ZTtlbHNle2UtPXRoaXMuX2JpdHNBdmFpbGFibGU7dmFyIHQ9TWF0aC5mbG9vcihlLzgpO2UtPTgqdCx0aGlzLl9ieXRlc0F2YWlsYWJsZS09dCx0aGlzLl9sb2FkV29yZCgpLHRoaXMuX3dvcmQ8PD1lLHRoaXMuX2JpdHNBdmFpbGFibGUtPWV9fX0se2tleToicmVhZEJpdHMiLHZhbHVlOmZ1bmN0aW9uKGUpe2lmKGU+MzIpdGhyb3cgbmV3IEVycm9yKCJDYW5ub3QgcmVhZCBtb3JlIHRoYW4gMzIgYml0cyIpO3ZhciB0PU1hdGgubWluKHRoaXMuX2JpdHNBdmFpbGFibGUsZSkscj10aGlzLl93b3JkPj4+MzItdDtyZXR1cm4gdGhpcy5fYml0c0F2YWlsYWJsZS09dCx0aGlzLl9iaXRzQXZhaWxhYmxlPjA/dGhpcy5fd29yZDw8PXQ6dGhpcy5fYnl0ZXNBdmFpbGFibGU+MCYmdGhpcy5fbG9hZFdvcmQoKSwodD1lLXQpPjAmJnRoaXMuX2JpdHNBdmFpbGFibGU/cjw8dHx0aGlzLnJlYWRCaXRzKHQpOnJ9fSx7a2V5OiJza2lwTFoiLHZhbHVlOmZ1bmN0aW9uKCl7dmFyIGU7Zm9yKGU9MDtlPHRoaXMuX2JpdHNBdmFpbGFibGU7KytlKWlmKDAhPSh0aGlzLl93b3JkJjIxNDc0ODM2NDg+Pj5lKSlyZXR1cm4gdGhpcy5fd29yZDw8PWUsdGhpcy5fYml0c0F2YWlsYWJsZS09ZSxlO3JldHVybiB0aGlzLl9sb2FkV29yZCgpLGUrdGhpcy5za2lwTFooKX19LHtrZXk6InNraXBVRUciLHZhbHVlOmZ1bmN0aW9uKCl7dGhpcy5za2lwQml0cygxK3RoaXMuc2tpcExaKCkpfX0se2tleToicmVhZFVFRyIsdmFsdWU6ZnVuY3Rpb24oKXt2YXIgZT10aGlzLnNraXBMWigpO3JldHVybiB0aGlzLnJlYWRCaXRzKGUrMSktMX19LHtrZXk6InJlYWRFRyIsdmFsdWU6ZnVuY3Rpb24oKXt2YXIgZT10aGlzLnJlYWRVRUcoKTtyZXR1cm4gMSZlPzErZT4+PjE6LTEqKGU+Pj4xKX19LHtrZXk6InJlYWRCb29sIix2YWx1ZTpmdW5jdGlvbigpe3JldHVybiAxPT09dGhpcy5yZWFkQml0cygxKX19LHtrZXk6InJlYWRVQnl0ZSIsdmFsdWU6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5yZWFkQml0cyg4KX19LHtrZXk6InNraXBTY2FsaW5nTGlzdCIsdmFsdWU6ZnVuY3Rpb24oZSl7Zm9yKHZhciB0PTgscj04LGE9MDthPGU7YSsrKTAhPT1yJiYocj0odCt0aGlzLnJlYWRFRygpKzI1NiklMjU2KSx0PTA9PT1yP3Q6cn19XSksZX0oKSxHPWZ1bmN0aW9uKCl7ZnVuY3Rpb24gZSh0KXtyKHRoaXMsZSksdGhpcy5uYW1lPXR8fCIiLHRoaXMuX3ByZWZpeD0iWyIuY29uY2F0KHRoaXMubmFtZSwiXSIpfXJldHVybiBuKGUsW3trZXk6Indhcm4iLHZhbHVlOmZ1bmN0aW9uKCl7dmFyIHQ7aWYoIWUuZGlzYWJsZWQpe2Zvcih2YXIgcj1hcmd1bWVudHMubGVuZ3RoLGE9bmV3IEFycmF5KHIpLG49MDtuPHI7bisrKWFbbl09YXJndW1lbnRzW25dOyh0PWNvbnNvbGUpLndhcm4uYXBwbHkodCxbdGhpcy5fcHJlZml4XS5jb25jYXQoYSkpfX19XSxbe2tleToiZW5hYmxlIix2YWx1ZTpmdW5jdGlvbigpe2UuZGlzYWJsZWQ9ITF9fSx7a2V5OiJkaXNhYmxlIix2YWx1ZTpmdW5jdGlvbigpe2UuZGlzYWJsZWQ9ITB9fV0pLGV9KCk7aShHLCJkaXNhYmxlZCIsITApO3ZhciBIPWZ1bmN0aW9uKCl7ZnVuY3Rpb24gZSgpe3IodGhpcyxlKX1yZXR1cm4gbihlLG51bGwsW3trZXk6ImRlY29kZSIsdmFsdWU6ZnVuY3Rpb24odCl7Zm9yKHZhciByPVtdLGE9dCxuPTAsaT10Lmxlbmd0aDtuPGk7KWlmKGFbbl08MTI4KXIucHVzaChTdHJpbmcuZnJvbUNoYXJDb2RlKGFbbl0pKSwrK247ZWxzZXtpZihhW25dPDE5Mik7ZWxzZSBpZihhW25dPDIyNCl7aWYoZS5fY2hlY2tDb250aW51YXRpb24oYSxuLDEpKXt2YXIgcz0oMzEmYVtuXSk8PDZ8NjMmYVtuKzFdO2lmKHM+PTEyOCl7ci5wdXNoKFN0cmluZy5mcm9tQ2hhckNvZGUoNjU1MzUmcykpLG4rPTI7Y29udGludWV9fX1lbHNlIGlmKGFbbl08MjQwKXtpZihlLl9jaGVja0NvbnRpbnVhdGlvbihhLG4sMikpe3ZhciBvPSgxNSZhW25dKTw8MTJ8KDYzJmFbbisxXSk8PDZ8NjMmYVtuKzJdO2lmKG8+PTIwNDgmJjU1Mjk2IT0oNjM0ODgmbykpe3IucHVzaChTdHJpbmcuZnJvbUNoYXJDb2RlKDY1NTM1Jm8pKSxuKz0zO2NvbnRpbnVlfX19ZWxzZSBpZihhW25dPDI0OCYmZS5fY2hlY2tDb250aW51YXRpb24oYSxuLDMpKXt2YXIgdT0oNyZhW25dKTw8MTh8KDYzJmFbbisxXSk8PDEyfCg2MyZhW24rMl0pPDw2fDYzJmFbbiszXTtpZih1PjY1NTM2JiZ1PDExMTQxMTIpe3UtPTY1NTM2LHIucHVzaChTdHJpbmcuZnJvbUNoYXJDb2RlKHU+Pj4xMHw1NTI5NikpLHIucHVzaChTdHJpbmcuZnJvbUNoYXJDb2RlKDEwMjMmdXw1NjMyMCkpLG4rPTQ7Y29udGludWV9fXIucHVzaChTdHJpbmcuZnJvbUNoYXJDb2RlKDY1NTMzKSksKytufXJldHVybiByLmpvaW4oIiIpfX0se2tleToiX2NoZWNrQ29udGludWF0aW9uIix2YWx1ZTpmdW5jdGlvbihlLHQscil7dmFyIGE9ZTtpZih0K3I8YS5sZW5ndGgpe2Zvcig7ci0tOylpZigxMjghPSgxOTImYVsrK3RdKSlyZXR1cm4hMTtyZXR1cm4hMH1yZXR1cm4hMX19XSksZX0oKSxLPSJ1bmRlZmluZWQiIT10eXBlb2Ygd2luZG93LHE9SyYmbmF2aWdhdG9yLnVzZXJBZ2VudC50b0xvY2FsZUxvd2VyQ2FzZSgpLFc9SyYmL14oKD8hY2hyb21lfGFuZHJvaWQpLikqc2FmYXJpLy50ZXN0KHEpLFg9SyYmcS5pbmNsdWRlcygiZmlyZWZveCIpLFk9SyYmcS5pbmNsdWRlcygiYW5kcm9pZCIpO2Z1bmN0aW9uIFooKXtmb3IodmFyIGU9YXJndW1lbnRzLmxlbmd0aCx0PW5ldyBBcnJheShlKSxyPTA7cjxlO3IrKyl0W3JdPWFyZ3VtZW50c1tyXTt0PXQuZmlsdGVyKEJvb2xlYW4pO3ZhciBhPW5ldyBVaW50OEFycmF5KHQucmVkdWNlKChmdW5jdGlvbihlLHQpe3JldHVybiBlK3QuYnl0ZUxlbmd0aH0pLDApKSxuPTA7cmV0dXJuIHQuZm9yRWFjaCgoZnVuY3Rpb24oZSl7YS5zZXQoZSxuKSxuKz1lLmJ5dGVMZW5ndGh9KSksYX12YXIgUT1NYXRoLnBvdygyLDMyKTtmdW5jdGlvbiBKKGUpe3ZhciB0PWFyZ3VtZW50cy5sZW5ndGg+MSYmdm9pZCAwIT09YXJndW1lbnRzWzFdP2FyZ3VtZW50c1sxXTowO3JldHVybihlW3RdPDw4KSsoZVt0KzFdfHwwKX1mdW5jdGlvbiAkKGUpe3ZhciB0PWFyZ3VtZW50cy5sZW5ndGg+MSYmdm9pZCAwIT09YXJndW1lbnRzWzFdP2FyZ3VtZW50c1sxXTowO3JldHVybihlW3RdPDwyND4+PjApKyhlW3QrMV08PDE2KSsoZVt0KzJdPDw4KSsoZVt0KzNdfHwwKX1mdW5jdGlvbiBlZShlKXt2YXIgdD1hcmd1bWVudHMubGVuZ3RoPjEmJnZvaWQgMCE9PWFyZ3VtZW50c1sxXT9hcmd1bWVudHNbMV06MDtyZXR1cm4gJChlLHQpKlErJChlLHQrNCl9ZnVuY3Rpb24gdGUoZSl7Zm9yKHZhciB0LHI9ImF2YzEuIixhPTA7YTwzO2ErKykodD1lW2FdLnRvU3RyaW5nKDE2KSkubGVuZ3RoPDImJih0PSIwIi5jb25jYXQodCkpLHIrPXQ7cmV0dXJuIHJ9ZnVuY3Rpb24gcmUoZSl7dmFyIHQ9IiI7aWYoZS5mb3JFYWNoKChmdW5jdGlvbihlKXt0Kz1mdW5jdGlvbihlKXtyZXR1cm4oIjAiK051bWJlcihlKS50b1N0cmluZygxNikpLnNsaWNlKC0yKS50b1VwcGVyQ2FzZSgpfShlKX0pKSx0Lmxlbmd0aDw9MzIpZm9yKHZhciByPTMyLXQubGVuZ3RoLGE9MDthPHI7YSsrKXQrPSIwIjtyZXR1cm4gdH1mdW5jdGlvbiBhZShlKXtpZighQXJyYXkuaXNBcnJheShlKSl7Zm9yKHZhciB0PVtdLHI9IiIsYT0wO2E8ZS5sZW5ndGg7YSsrKWElMiYmKHI9ZVthLTFdK2VbYV0sdC5wdXNoKHBhcnNlSW50KHIsMTYpKSxyPSIiKTtyZXR1cm4gdH1yZXR1cm4gZS5tYXAoKGZ1bmN0aW9uKGUpe3JldHVybiBwYXJzZUludChlLDE2KX0pKX12YXIgbmU9ZnVuY3Rpb24oKXtmdW5jdGlvbiBlKCl7cih0aGlzLGUpfXJldHVybiBuKGUsbnVsbCxbe2tleToicGFyc2VBbm5leEIiLHZhbHVlOmZ1bmN0aW9uKGUpe2Zvcih2YXIgdD1lLmxlbmd0aCxyPTIsYT0wO251bGwhPT1lW3JdJiZ2b2lkIDAhPT1lW3JdJiYxIT09ZVtyXTspcisrO2lmKChhPSsrcisyKT49dClyZXR1cm5bXTtmb3IodmFyIG49W107YTx0Oylzd2l0Y2goZVthXSl7Y2FzZSAwOmlmKDAhPT1lW2EtMV0pe2ErPTI7YnJlYWt9aWYoMCE9PWVbYS0yXSl7YSsrO2JyZWFrfXIhPT1hLTImJm4ucHVzaChlLnN1YmFycmF5KHIsYS0yKSk7ZG97YSsrfXdoaWxlKDEhPT1lW2FdJiZhPHQpO2E9KHI9YSsxKSsyO2JyZWFrO2Nhc2UgMTppZigwIT09ZVthLTFdfHwwIT09ZVthLTJdKXthKz0zO2JyZWFrfXIhPT1hLTImJm4ucHVzaChlLnN1YmFycmF5KHIsYS0yKSksYT0ocj1hKzEpKzI7YnJlYWs7ZGVmYXVsdDphKz0zfXJldHVybiByPHQmJm4ucHVzaChlLnN1YmFycmF5KHIpKSxufX0se2tleToicGFyc2VBdmNDIix2YWx1ZTpmdW5jdGlvbihlKXt2YXIgdD1hcmd1bWVudHMubGVuZ3RoPjEmJnZvaWQgMCE9PWFyZ3VtZW50c1sxXT9hcmd1bWVudHNbMV06NDtpZighKGUubGVuZ3RoPDQpKXtmb3IodmFyIHIsYT1lLmxlbmd0aCxuPVtdLGk9MDtpK3Q8YTspaWYocj0kKGUsaSksMz09PXQmJihyPj4+PTgpLGkrPXQscil7aWYoaStyPmEpYnJlYWs7bi5wdXNoKGUuc3ViYXJyYXkoaSxpK3IpKSxpKz1yfXJldHVybiBufX19LHtrZXk6InBhcnNlU0VJIix2YWx1ZTpmdW5jdGlvbihlLHQpe2Zvcih2YXIgcj1lLmxlbmd0aCxhPXQ/MjoxLG49MCxpPTAscz0iIjsyNTU9PT1lW2FdOyluKz0yNTUsYSsrO2ZvcihuKz1lW2ErK107MjU1PT09ZVthXTspaSs9MjU1LGErKztpZihpKz1lW2ErK10sNT09PW4mJnI+YSsxNilmb3IodmFyIG89MDtvPDE2O28rKylzKz1lW2FdLnRvU3RyaW5nKDE2KSxhKys7cmV0dXJue3BheWxvYWQ6ZS5zdWJhcnJheShhLGEraSksdHlwZTpuLHNpemU6aSx1dWlkOnN9fX0se2tleToicmVtb3ZlRVBCIix2YWx1ZTpmdW5jdGlvbihlKXtmb3IodmFyIHQ9ZS5ieXRlTGVuZ3RoLHI9W10sYT0xO2E8dC0yOykwPT09ZVthXSYmMD09PWVbYSsxXSYmMz09PWVbYSsyXT8oci5wdXNoKGErMiksYSs9Mik6YSsrO2lmKCFyLmxlbmd0aClyZXR1cm4gZTt2YXIgbj10LXIubGVuZ3RoLGk9bmV3IFVpbnQ4QXJyYXkobikscz0wO2ZvcihhPTA7YTxuO3MrKyxhKyspcz09PXJbMF0mJihzKyssci5zaGlmdCgpKSxpW2FdPWVbc107cmV0dXJuIGl9fV0pLGV9KCksaWU9ZnVuY3Rpb24oKXtmdW5jdGlvbiBlKCl7cih0aGlzLGUpfXJldHVybiBuKGUsbnVsbCxbe2tleToicGFyc2VBVkNEZWNvZGVyQ29uZmlndXJhdGlvblJlY29yZCIsdmFsdWU6ZnVuY3Rpb24odCl7aWYoISh0Lmxlbmd0aDw3KSl7Zm9yKHZhciByLGEsbj0xKygzJnRbNF0pLGk9W10scz1bXSxvPTYsdT0zMSZ0WzVdLGM9MDtjPHU7YysrKWlmKGE9dFtvXTw8OHx0W28rMV0sbys9MixhKXt2YXIgbD10LnN1YmFycmF5KG8sbythKTtvKz1hLGkucHVzaChsKSxyfHwocj1lLnBhcnNlU1BTKG5lLnJlbW92ZUVQQihsKSkpfXZhciBmLGQ9dFtvXTtvKys7Zm9yKHZhciBoPTA7aDxkO2grKylmPXRbb108PDh8dFtvKzFdLG8rPTIsZiYmKHMucHVzaCh0LnN1YmFycmF5KG8sbytmKSksbys9Zik7cmV0dXJue3NwczpyLHNwc0FycjppLHBwc0FycjpzLG5hbFVuaXRTaXplOm59fX19LHtrZXk6InBhcnNlU1BTIix2YWx1ZTpmdW5jdGlvbihlKXt2YXIgdD1uZXcgaihlKTt0LnJlYWRVQnl0ZSgpO3ZhciByPXQucmVhZFVCeXRlKCksYT10LnJlYWRVQnl0ZSgpLG49dC5yZWFkVUJ5dGUoKTt0LnNraXBVRUcoKTt2YXIgaT00MjA7aWYoMTAwPT09cnx8MTEwPT09cnx8MTIyPT09cnx8MjQ0PT09cnx8NDQ9PT1yfHw4Mz09PXJ8fDg2PT09cnx8MTE4PT09cnx8MTI4PT09cnx8MTM4PT09cnx8MTQ0PT09cil7dmFyIHM9dC5yZWFkVUVHKCk7aWYoczw9MyYmKGk9WzAsNDIwLDQyMiw0NDRdW3NdKSwzPT09cyYmdC5za2lwQml0cygxKSx0LnNraXBVRUcoKSx0LnNraXBVRUcoKSx0LnNraXBCaXRzKDEpLHQucmVhZEJvb2woKSlmb3IodmFyIG89MyE9PXM/ODoxMix1PTA7dTxvO3UrKyl0LnJlYWRCb29sKCkmJih1PDY/dC5za2lwU2NhbGluZ0xpc3QoMTYpOnQuc2tpcFNjYWxpbmdMaXN0KDY0KSl9dC5za2lwVUVHKCk7dmFyIGM9dC5yZWFkVUVHKCk7aWYoMD09PWMpdC5yZWFkVUVHKCk7ZWxzZSBpZigxPT09Yyl7dC5za2lwQml0cygxKSx0LnNraXBVRUcoKSx0LnNraXBVRUcoKTtmb3IodmFyIGw9dC5yZWFkVUVHKCksZj0wO2Y8bDtmKyspdC5za2lwVUVHKCl9dC5za2lwVUVHKCksdC5za2lwQml0cygxKTt2YXIgZD10LnJlYWRVRUcoKSxoPXQucmVhZFVFRygpLHA9dC5yZWFkQml0cygxKTswPT09cCYmdC5za2lwQml0cygxKSx0LnNraXBCaXRzKDEpO3ZhciB2LHksbSxnLGssYj0wLF89MCx3PTAseD0wO2lmKHQucmVhZEJvb2woKSYmKGI9dC5yZWFkVUVHKCksXz10LnJlYWRVRUcoKSx3PXQucmVhZFVFRygpLHg9dC5yZWFkVUVHKCkpLHQucmVhZEJvb2woKSl7aWYodC5yZWFkQm9vbCgpKXN3aXRjaCh0LnJlYWRVQnl0ZSgpKXtjYXNlIDE6dj1bMSwxXTticmVhaztjYXNlIDI6dj1bMTIsMTFdO2JyZWFrO2Nhc2UgMzp2PVsxMCwxMV07YnJlYWs7Y2FzZSA0OnY9WzE2LDExXTticmVhaztjYXNlIDU6dj1bNDAsMzNdO2JyZWFrO2Nhc2UgNjp2PVsyNCwxMV07YnJlYWs7Y2FzZSA3OnY9WzIwLDExXTticmVhaztjYXNlIDg6dj1bMzIsMTFdO2JyZWFrO2Nhc2UgOTp2PVs4MCwzM107YnJlYWs7Y2FzZSAxMDp2PVsxOCwxMV07YnJlYWs7Y2FzZSAxMTp2PVsxNSwxMV07YnJlYWs7Y2FzZSAxMjp2PVs2NCwzM107YnJlYWs7Y2FzZSAxMzp2PVsxNjAsOTldO2JyZWFrO2Nhc2UgMTQ6dj1bNCwzXTticmVhaztjYXNlIDE1OnY9WzMsMl07YnJlYWs7Y2FzZSAxNjp2PVsyLDFdO2JyZWFrO2Nhc2UgMjU1OnY9W3QucmVhZFVCeXRlKCk8PDh8dC5yZWFkVUJ5dGUoKSx0LnJlYWRVQnl0ZSgpPDw4fHQucmVhZFVCeXRlKCldfWlmKHQucmVhZEJvb2woKSYmdC5yZWFkQm9vbCgpLHQucmVhZEJvb2woKSYmKHQucmVhZEJpdHMoNCksdC5yZWFkQm9vbCgpJiZ0LnJlYWRCaXRzKDI0KSksdC5yZWFkQm9vbCgpJiYodC5yZWFkVUVHKCksdC5yZWFkVUVHKCkpLHQucmVhZEJvb2woKSl7dmFyIFM9dC5yZWFkQml0cygzMiksQT10LnJlYWRCaXRzKDMyKTt5PXQucmVhZEJvb2woKSxrPShtPUEpLyhnPTIqUyl9fXJldHVybntjb2RlYzp0ZShlLnN1YmFycmF5KDEsNCkpLHByb2ZpbGVJZGM6cixwcm9maWxlQ29tcGF0aWJpbGl0eTphLGxldmVsSWRjOm4sY2hyb21hRm9ybWF0Omksd2lkdGg6TWF0aC5jZWlsKDE2KihkKzEpLTIqKGIrXykpLGhlaWdodDooMi1wKSooaCsxKSoxNi0ocD8yOjQpKih3K3gpLHNhclJhdGlvOnYsZnBzTnVtOm0sZnBzRGVuOmcsZnBzOmssZml4ZWRGcmFtZTp5fX19XSksZX0oKSxzZT1mdW5jdGlvbigpe2Z1bmN0aW9uIGUoKXtyKHRoaXMsZSl9cmV0dXJuIG4oZSxudWxsLFt7a2V5OiJnZXRSYXRlSW5kZXhCeVJhdGUiLHZhbHVlOmZ1bmN0aW9uKHQpe3JldHVybiBlLkZSRVEuaW5kZXhPZih0KX19LHtrZXk6InBhcnNlQURUUyIsdmFsdWU6ZnVuY3Rpb24odCxyKXtmb3IodmFyIGE9dC5sZW5ndGgsbj0wO24rMjxhJiYoMjU1IT09dFtuXXx8MjQwIT0oMjQ2JnRbbisxXSkpOyluKys7aWYoIShuPj1hKSl7dmFyIGk9bixzPVtdLG89KDYwJnRbbisyXSk+Pj4yLHU9ZS5GUkVRW29dO2lmKCF1KXRocm93IG5ldyBFcnJvcigiSW52YWxpZCBzYW1wbGluZyBpbmRleDogIi5jb25jYXQobykpO2Zvcih2YXIgYyxsLGY9MSsoKDE5MiZ0W24rMl0pPj4+NiksZD0oMSZ0W24rMl0pPDwyfCgxOTImdFtuKzNdKT4+PjYsaD1lLl9nZXRDb25maWcobyxkLGYpLHA9aC5jb25maWcsdj1oLmNvZGVjLHk9MCxtPWUuZ2V0RnJhbWVEdXJhdGlvbih1KTtuKzc8YTspaWYoMjU1PT09dFtuXSYmMjQwPT0oMjQ2JnRbbisxXSkpe2lmKGEtbjwobD0oMyZ0W24rM10pPDwxMXx0W24rNF08PDN8KDIyNCZ0W24rNV0pPj41KSlicmVhaztjPTIqKDEmfnRbbisxXSkscy5wdXNoKHtwdHM6cit5Km0sZGF0YTp0LnN1YmFycmF5KG4rNytjLG4rbCl9KSx5Kyssbis9bH1lbHNlIG4rKztyZXR1cm57c2tpcDppLHJlbWFpbmluZzpuPj1hP3ZvaWQgMDp0LnN1YmFycmF5KG4pLGZyYW1lczpzLHNhbXBsaW5nRnJlcXVlbmN5SW5kZXg6byxzYW1wbGVSYXRlOnUsb2JqZWN0VHlwZTpmLGNoYW5uZWxDb3VudDpkLGNvZGVjOnYsY29uZmlnOnAsb3JpZ2luQ29kZWM6Im1wNGEuNDAuIi5jb25jYXQoZil9fX19LHtrZXk6InBhcnNlQXVkaW9TcGVjaWZpY0NvbmZpZyIsdmFsdWU6ZnVuY3Rpb24odCl7aWYodC5sZW5ndGgpe3ZhciByPXRbMF0+Pj4zLGE9KDcmdFswXSk8PDF8dFsxXT4+Pjcsbj0oMTIwJnRbMV0pPj4+MyxpPWUuRlJFUVthXTtpZihpKXt2YXIgcz1lLl9nZXRDb25maWcoYSxuLHIpO3JldHVybntzYW1wbGluZ0ZyZXF1ZW5jeUluZGV4OmEsc2FtcGxlUmF0ZTppLG9iamVjdFR5cGU6cixjaGFubmVsQ291bnQ6bixjb25maWc6cy5jb25maWcsY29kZWM6cy5jb2RlYyxvcmlnaW5Db2RlYzoibXA0YS40MC4iLmNvbmNhdChyKX19fX19LHtrZXk6ImdldEZyYW1lRHVyYXRpb24iLHZhbHVlOmZ1bmN0aW9uKGUpe3ZhciB0PWFyZ3VtZW50cy5sZW5ndGg+MSYmdm9pZCAwIT09YXJndW1lbnRzWzFdP2FyZ3VtZW50c1sxXTo5ZTQ7cmV0dXJuIDEwMjQqdC9lfX0se2tleToiX2dldENvbmZpZyIsdmFsdWU6ZnVuY3Rpb24oZSx0LHIpe3ZhciBhLG4saT1bXTtyZXR1cm4gWD9lPj02PyhhPTUsbj1lLTMpOihhPTIsbj1lKTpZPyhhPTIsbj1lKTooYT0yPT09cnx8NT09PXI/cjo1LG49ZSxlPj02P249ZS0zOjE9PT10JiYoYT0yLG49ZSkpLGlbMF09YTw8MyxpWzBdfD0oMTQmZSk+PjEsaVsxXT0oMSZlKTw8NyxpWzFdfD10PDwzLDU9PT1hJiYoaVsxXXw9KDE0Jm4pPj4xLGlbMl09KDEmbik8PDcsaVsyXXw9OCxpWzNdPTApLHtjb25maWc6aSxjb2RlYzoibXA0YS40MC4iLmNvbmNhdChhKX19fSx7a2V5OiJnZXRTaWxlbnRGcmFtZSIsdmFsdWU6ZnVuY3Rpb24oZSx0KXtpZigibXA0YS40MC4yIj09PWUpe2lmKDE9PT10KXJldHVybiBuZXcgVWludDhBcnJheShbMCwyMDAsMCwxMjgsMzUsMTI4XSk7aWYoMj09PXQpcmV0dXJuIG5ldyBVaW50OEFycmF5KFszMywwLDczLDE0NCwyLDI1LDAsMzUsMTI4XSk7aWYoMz09PXQpcmV0dXJuIG5ldyBVaW50OEFycmF5KFswLDIwMCwwLDEyOCwzMiwxMzIsMSwzOCw2NCw4LDEwMCwwLDE0Ml0pO2lmKDQ9PT10KXJldHVybiBuZXcgVWludDhBcnJheShbMCwyMDAsMCwxMjgsMzIsMTMyLDEsMzgsNjQsOCwxMDAsMCwxMjgsNDQsMTI4LDgsMiw1Nl0pO2lmKDU9PT10KXJldHVybiBuZXcgVWludDhBcnJheShbMCwyMDAsMCwxMjgsMzIsMTMyLDEsMzgsNjQsOCwxMDAsMCwxMzAsNDgsNCwxNTMsMCwzMywxNDQsMiw1Nl0pO2lmKDY9PT10KXJldHVybiBuZXcgVWludDhBcnJheShbMCwyMDAsMCwxMjgsMzIsMTMyLDEsMzgsNjQsOCwxMDAsMCwxMzAsNDgsNCwxNTMsMCwzMywxNDQsMiwwLDE3OCwwLDMyLDgsMjI0XSl9ZWxzZXtpZigxPT09dClyZXR1cm4gbmV3IFVpbnQ4QXJyYXkoWzEsNjQsMzQsMTI4LDE2Myw3OCwyMzAsMTI4LDE4Niw4LDAsMCwwLDI4LDYsMjQxLDE5MywxMCw5MCw5MCw5MCw5MCw5MCw5MCw5MCw5MCw5MCw5MCw5MCw5MCw5MCw5MCw5MCw5MCw5MCw5MCw5MCw5MCw5MCw5MCw5MCw5MCw5MCw5MCw5MCw5MCw5MCw5MCw5MCw5MCw5MCw5MCw5MCw5MCw5MCw5MCw5MCw5MCw5NF0pO2lmKDI9PT10KXJldHVybiBuZXcgVWludDhBcnJheShbMSw2NCwzNCwxMjgsMTYzLDk0LDIzMCwxMjgsMTg2LDgsMCwwLDAsMCwxNDksMCw2LDI0MSwxNjEsMTAsOTAsOTAsOTAsOTAsOTAsOTAsOTAsOTAsOTAsOTAsOTAsOTAsOTAsOTAsOTAsOTAsOTAsOTAsOTAsOTAsOTAsOTAsOTAsOTAsOTAsOTAsOTAsOTAsOTAsOTAsOTAsOTAsOTAsOTAsOTAsOTAsOTAsOTAsOTRdKTtpZigzPT09dClyZXR1cm4gbmV3IFVpbnQ4QXJyYXkoWzEsNjQsMzQsMTI4LDE2Myw5NCwyMzAsMTI4LDE4Niw4LDAsMCwwLDAsMTQ5LDAsNiwyNDEsMTYxLDEwLDkwLDkwLDkwLDkwLDkwLDkwLDkwLDkwLDkwLDkwLDkwLDkwLDkwLDkwLDkwLDkwLDkwLDkwLDkwLDkwLDkwLDkwLDkwLDkwLDkwLDkwLDkwLDkwLDkwLDkwLDkwLDkwLDkwLDkwLDkwLDkwLDkwLDkwLDk0XSl9fX1dKSxlfSgpO2koc2UsIkZSRVEiLFs5NmUzLDg4MjAwLDY0ZTMsNDhlMyw0NDEwMCwzMmUzLDI0ZTMsMjIwNTAsMTZlMywxMmUzLDExMDI1LDhlMyw3MzUwXSk7dmFyIG9lPWZ1bmN0aW9uKCl7ZnVuY3Rpb24gZSgpe3IodGhpcyxlKX1yZXR1cm4gbihlLG51bGwsW3trZXk6InBhcnNlSEVWQ0RlY29kZXJDb25maWd1cmF0aW9uUmVjb3JkIix2YWx1ZTpmdW5jdGlvbih0KXt2YXIgcj1hcmd1bWVudHMubGVuZ3RoPjEmJnZvaWQgMCE9PWFyZ3VtZW50c1sxXT9hcmd1bWVudHNbMV06e307aWYoISh0Lmxlbmd0aDwyMykpe3I9cnx8e307Zm9yKHZhciBhLG4saSxzLG8sdT0xKygzJnRbMjFdKSxjPVtdLGw9W10sZj1bXSxkPTIzLGg9dFsyMl0scD0wO3A8aDtwKyspe2k9NjMmdFtkXSxzPXRbZCsxXTw8OHx0W2QrMl0sZCs9Mztmb3IodmFyIHY9MDt2PHM7disrKWlmKG89dFtkXTw8OHx0W2QrMV0sZCs9MixvKXtzd2l0Y2goaSl7Y2FzZSAzMjp2YXIgeT10LnN1YmFycmF5KGQsZCtvKTthfHwoYT1lLnBhcnNlVlBTKG5lLnJlbW92ZUVQQih5KSxyKSksZi5wdXNoKHkpO2JyZWFrO2Nhc2UgMzM6dmFyIG09dC5zdWJhcnJheShkLGQrbyk7bnx8KG49ZS5wYXJzZVNQUyhuZS5yZW1vdmVFUEIobSkscikpLGMucHVzaChtKTticmVhaztjYXNlIDM0OmwucHVzaCh0LnN1YmFycmF5KGQsZCtvKSl9ZCs9b319cmV0dXJue2h2Y0M6cixzcHM6bixzcHNBcnI6YyxwcHNBcnI6bCx2cHNBcnI6ZixuYWxVbml0U2l6ZTp1fX19fSx7a2V5OiJwYXJzZVZQUyIsdmFsdWU6ZnVuY3Rpb24odCxyKXtyPXJ8fHt9O3ZhciBhPW5ldyBqKHQpO2EucmVhZFVCeXRlKCksYS5yZWFkVUJ5dGUoKSxhLnJlYWRCaXRzKDEyKTt2YXIgbj1hLnJlYWRCaXRzKDMpO3JldHVybiByLm51bVRlbXBvcmFsTGF5ZXJzPU1hdGgubWF4KHIubnVtVGVtcG9yYWxMYXllcnN8fDAsbisxKSxhLnJlYWRCaXRzKDE3KSxlLl9wYXJzZVByb2ZpbGVUaWVyTGV2ZWwoYSxuLHIpLHJ9fSx7a2V5OiJwYXJzZVNQUyIsdmFsdWU6ZnVuY3Rpb24odCl7dmFyIHI9YXJndW1lbnRzLmxlbmd0aD4xJiZ2b2lkIDAhPT1hcmd1bWVudHNbMV0/YXJndW1lbnRzWzFdOnt9O3I9cnx8e307dmFyIGE9bmV3IGoodCk7YS5yZWFkVUJ5dGUoKSxhLnJlYWRVQnl0ZSgpLGEucmVhZEJpdHMoNCk7dmFyIG49YS5yZWFkQml0cygzKTtyLm51bVRlbXBvcmFsTGF5ZXJzPU1hdGgubWF4KG4rMSxyLm51bVRlbXBvcmFsTGF5ZXJzfHwwKSxyLnRlbXBvcmFsSWROZXN0ZWQ9YS5yZWFkQml0cygxKSxlLl9wYXJzZVByb2ZpbGVUaWVyTGV2ZWwoYSxuLHIpLGEucmVhZFVFRygpO3ZhciBpPXIuY2hyb21hRm9ybWF0SWRjPWEucmVhZFVFRygpLHM9NDIwO2k8PTMmJihzPVswLDQyMCw0MjIsNDQ0XVtpXSk7dmFyIG89MDszPT09aSYmKG89YS5yZWFkQml0cygxKSk7dmFyIHUsYyxsLGYsZD1hLnJlYWRVRUcoKSxoPWEucmVhZFVFRygpLHA9YS5yZWFkQml0cygxKTtpZigxPT09cCYmKHU9YS5yZWFkVUVHKCksYz1hLnJlYWRVRUcoKSxsPWEucmVhZFVFRygpLGY9YS5yZWFkVUVHKCkpLHIuYml0RGVwdGhMdW1hTWludXM4PWEucmVhZFVFRygpLHIuYml0RGVwdGhDaHJvbWFNaW51czg9YS5yZWFkVUVHKCksMT09PXApe3ZhciB2PTEhPT1pJiYyIT09aXx8MCE9PW8/MToyLHk9MT09PWkmJjA9PT1vPzI6MTtkLT12KihjK3UpLGgtPXkqKGYrbCl9cmV0dXJue2NvZGVjOiJoZXYxLjEuNi5MOTMuQjAiLHdpZHRoOmQsaGVpZ2h0OmgsY2hyb21hRm9ybWF0OnMsaHZjQzpyfX19LHtrZXk6Il9wYXJzZVByb2ZpbGVUaWVyTGV2ZWwiLHZhbHVlOmZ1bmN0aW9uKGUsdCxyKXt2YXIgYT1yLmdlbmVyYWxUaWVyRmxhZ3x8MDtyLmdlbmVyYWxQcm9maWxlU3BhY2U9ZS5yZWFkQml0cygyKSxyLmdlbmVyYWxUaWVyRmxhZz1NYXRoLm1heChlLnJlYWRCaXRzKDEpLGEpLHIuZ2VuZXJhbFByb2ZpbGVJZGM9TWF0aC5tYXgoZS5yZWFkQml0cyg1KSxyLmdlbmVyYWxQcm9maWxlSWRjfHwwKSxyLmdlbmVyYWxQcm9maWxlQ29tcGF0aWJpbGl0eUZsYWdzPWUucmVhZEJpdHMoMzIpLHIuZ2VuZXJhbENvbnN0cmFpbnRJbmRpY2F0b3JGbGFncz1bZS5yZWFkQml0cyg4KSxlLnJlYWRCaXRzKDgpLGUucmVhZEJpdHMoOCksZS5yZWFkQml0cyg4KSxlLnJlYWRCaXRzKDgpLGUucmVhZEJpdHMoOCldO3ZhciBuPWUucmVhZEJpdHMoOCk7YTxyLmdlbmVyYWxUaWVyRmxhZz9yLmdlbmVyYWxMZXZlbElkYz1uOnIuZ2VuZXJhbExldmVsSWRjPU1hdGgubWF4KG4sci5nZW5lcmFsTGV2ZWxJZGN8fDApO3ZhciBpPVtdLHM9W107aWYodD5lLmJpdHNBdmFpbGFibGUpdGhyb3cgbmV3IEVycm9yKCJtYXhTdWJMYXllcnNNaW51cyBpbmF2bGlkIHNpemUgIi5jb25jYXQodCkpO2Zvcih2YXIgbz0wO288dDtvKyspaVtvXT1lLnJlYWRCaXRzKDEpLHNbb109ZS5yZWFkQml0cygxKTt0PjAmJmUucmVhZEJpdHMoMiooOC10KSk7Zm9yKHZhciB1PTA7dTx0O3UrKykwIT09aVt1XSYmKGUucmVhZEJpdHMoMiksZS5yZWFkQml0cygxKSxlLnJlYWRCaXRzKDUpLGUucmVhZEJpdHMoMTYpLGUucmVhZEJpdHMoMTYpLGUucmVhZEJpdHMoNCksZS5yZWFkQml0cygxNiksZS5yZWFkQml0cygxNiksZS5yZWFkQml0cygxMikpLDAhPT1zW3VdJiZlLnJlYWRCaXRzKDgpfX1dKSxlfSgpLHVlPTFlMyxjZT01ZTMsbGU9ZnVuY3Rpb24oKXtmdW5jdGlvbiBlKHQsYSxuKXtyKHRoaXMsZSksdGhpcy52aWRlb1RyYWNrPXQsdGhpcy5hdWRpb1RyYWNrPWEsdGhpcy5tZXRhZGF0YVRyYWNrPW4sdGhpcy5fYmFzZUR0cz0tMSx0aGlzLl9iYXNlRHRzSW5pdGVkPSExLHRoaXMuX2F1ZGlvTmV4dFB0cz12b2lkIDAsdGhpcy5fdmlkZW9OZXh0RHRzPXZvaWQgMCx0aGlzLl9hdWRpb1RpbWVzdGFtcEJyZWFrPTAsdGhpcy5fdmlkZW9UaW1lc3RhbXBCcmVhaz0wLHRoaXMuX2xhc3RWaWRlb0R1cmF0aW9uPTAsdGhpcy5fa2V5RnJhbWVJbk5leHRDaHVuaz0hMSx0aGlzLl9sYXN0QXVkaW9FeGNlcHRpb25HYXBEb3Q9LTEvMCx0aGlzLl9sYXN0QXVkaW9FeGNlcHRpb25PdmVybGFwRG90PS0xLzAsdGhpcy5fbGFzdEF1ZGlvRXhjZXB0aW9uTGFyZ2VHYXBEb3Q9LTEvMCx0aGlzLl9sYXN0VmlkZW9FeGNlcHRpb25MYXJnZUdhcERvdD0tMS8wLHRoaXMuX2xhc3RWaWRlb0V4Y2VwdGlvbkNodW5rRmlyc3REdHNEb3Q9LTEvMH1yZXR1cm4gbihlLFt7a2V5OiJmaXgiLHZhbHVlOmZ1bmN0aW9uKCl7dmFyIGU9dGhpcyx0PWFyZ3VtZW50cy5sZW5ndGg+MCYmdm9pZCAwIT09YXJndW1lbnRzWzBdP2FyZ3VtZW50c1swXTowLHI9YXJndW1lbnRzLmxlbmd0aD4xJiZ2b2lkIDAhPT1hcmd1bWVudHNbMV0mJmFyZ3VtZW50c1sxXSxhPSEoYXJndW1lbnRzLmxlbmd0aD4yJiZ2b2lkIDAhPT1hcmd1bWVudHNbMl0pfHxhcmd1bWVudHNbMl07dD1NYXRoLnJvdW5kKDFlMyp0KTt2YXIgbj10aGlzLnZpZGVvVHJhY2ssaT10aGlzLmF1ZGlvVHJhY2s7IXImJmF8fCh0aGlzLl92aWRlb0xhc3RTYW1wbGU9bnVsbCx0aGlzLl9hdWRpb05leHRQdHM9dm9pZCAwLHRoaXMuX3ZpZGVvTmV4dER0cz12b2lkIDAsdGhpcy5fYXVkaW9UaW1lc3RhbXBCcmVhaz0wLHRoaXMuX3ZpZGVvVGltZXN0YW1wQnJlYWs9MCx0aGlzLl9sYXN0QXVkaW9FeGNlcHRpb25HYXBEb3Q9LTEvMCx0aGlzLl9sYXN0QXVkaW9FeGNlcHRpb25PdmVybGFwRG90PS0xLzAsdGhpcy5fbGFzdEF1ZGlvRXhjZXB0aW9uTGFyZ2VHYXBEb3Q9LTEvMCx0aGlzLl9sYXN0VmlkZW9FeGNlcHRpb25MYXJnZUdhcERvdD0tMS8wLHRoaXMuX2xhc3RWaWRlb0V4Y2VwdGlvbkNodW5rRmlyc3REdHNEb3Q9LTEvMCksciYmIWEmJih0aGlzLl9iYXNlRHRzSW5pdGVkPSExKSx0aGlzLl9iYXNlRHRzSW5pdGVkfHx0aGlzLl9jYWxjdWxhdGVCYXNlRHRzKGksbiksIWEmJnQmJih0aGlzLl9hdWRpb05leHRQdHM9dGhpcy5fdmlkZW9OZXh0RHRzPXQpO3ZhciBzPXRoaXMuX2Jhc2VEdHNJbml0ZWQmJih0aGlzLl92aWRlb1RpbWVzdGFtcEJyZWFrfHwhdGhpcy52aWRlb1RyYWNrLmV4aXN0KCkpJiYodGhpcy5fYXVkaW9UaW1lc3RhbXBCcmVha3x8IXRoaXMuYXVkaW9UcmFjay5leGlzdCgpKTtpZihzJiZ0aGlzLl9yZXNldEJhc2VEdHNXaGVuU3RyZWFtQnJlYWtlZCgpLHRoaXMuX2ZpeEF1ZGlvKGkpLHRoaXMuX2tleUZyYW1lSW5OZXh0Q2h1bms9ITEsdGhpcy5fZml4VmlkZW8obiksdGhpcy5tZXRhZGF0YVRyYWNrLmV4aXN0KCkpe3ZhciBvPXRoaXMubWV0YWRhdGFUcmFjay50aW1lc2NhbGU7dGhpcy5tZXRhZGF0YVRyYWNrLnNlaVNhbXBsZXMuZm9yRWFjaCgoZnVuY3Rpb24odCl7dC5wdHM9dC5vcmlnaW5QdHMtZS5fYmFzZUR0cyx0LnRpbWU9TWF0aC5tYXgoMCx0LnB0cykvb30pKSx0aGlzLm1ldGFkYXRhVHJhY2suZmx2U2NyaXB0U2FtcGxlcy5mb3JFYWNoKChmdW5jdGlvbih0KXt0LnB0cz10Lm9yaWdpblB0cy1lLl9iYXNlRHRzLHQudGltZT1NYXRoLm1heCgwLHQucHRzKS9vfSkpfW4uc2FtcGxlcy5sZW5ndGgmJihuLmJhc2VNZWRpYURlY29kZVRpbWU9bi5zYW1wbGVzWzBdLmR0cyksaS5zYW1wbGVzLmxlbmd0aCYmKGkuYmFzZU1lZGlhRGVjb2RlVGltZT1pLnNhbXBsZXNbMF0ucHRzKmkudGltZXNjYWxlLzFlMyl9fSx7a2V5OiJfZml4VmlkZW8iLHZhbHVlOmZ1bmN0aW9uKGUpe3ZhciB0PXRoaXMscj1lLnNhbXBsZXM7aWYoci5sZW5ndGgpe3ZhciBhO2lmKHIuZm9yRWFjaCgoZnVuY3Rpb24oZSl7ZS5kdHMtPXQuX2Jhc2VEdHMsZS5wdHMtPXQuX2Jhc2VEdHMsZS5rZXlmcmFtZSYmKHQuX2tleUZyYW1lSW5OZXh0Q2h1bms9ITApfSkpLGUuZnBzTnVtJiZlLmZwc0RlbilhPWUudGltZXNjYWxlKihlLmZwc0Rlbi9lLmZwc051bSk7ZWxzZSBpZihlLmxlbmd0aD4xKXt2YXIgbj1lLnNhbXBsZXNbMF0saT1lLnNhbXBsZXNbci5sZW5ndGgtMV07YT1NYXRoLmZsb29yKChpLmR0cy1uLmR0cykvKHIubGVuZ3RoLTEpKX1lbHNlIGE9dGhpcy5fbGFzdFZpZGVvRHVyYXRpb258fDQwO3ZhciBzPXIucG9wKCk7aWYodGhpcy5fdmlkZW9MYXN0U2FtcGxlJiZyLnVuc2hpZnQodGhpcy5fdmlkZW9MYXN0U2FtcGxlKSx0aGlzLl92aWRlb0xhc3RTYW1wbGU9cyxyLmxlbmd0aCl7aWYodm9pZCAwPT09dGhpcy5fdmlkZW9OZXh0RHRzKXt2YXIgbz1yWzBdO3RoaXMuX3ZpZGVvTmV4dER0cz1vLmR0c312YXIgdT1yLmxlbmd0aCxjPTAsbD1yWzBdLGY9dGhpcy5fdmlkZW9OZXh0RHRzLWwuZHRzO2lmKE1hdGguYWJzKGYpPjIwMCl7dmFyIGQ7aWYoTWF0aC5hYnMobC5kdHMtdGhpcy5fbGFzdFZpZGVvRXhjZXB0aW9uQ2h1bmtGaXJzdER0c0RvdCk+NWUzKXRoaXMuX2xhc3RWaWRlb0V4Y2VwdGlvbkNodW5rRmlyc3REdHNEb3Q9bC5kdHMsZS53YXJuaW5ncy5wdXNoKHt0eXBlOkMsbmV4dER0czp0aGlzLl92aWRlb05leHREdHMsZmlyc3RTYW1wbGVEdHM6bC5kdHMsbmV4dFNhbXBsZUR0czpudWxsPT09KGQ9clsxXSl8fHZvaWQgMD09PWQ/dm9pZCAwOmQuZHRzLHNhbXBsZUR1cmF0aW9uOmZ9KTt0aGlzLl92aWRlb1RpbWVzdGFtcEJyZWFrPj01Pyh0aGlzLl92aWRlb05leHREdHM9bC5kdHMsdGhpcy5fdmlkZW9UaW1lc3RhbXBCcmVhaz0wKToobC5kdHMrPWYsbC5wdHMrPWYsdGhpcy5hdWRpb1RyYWNrLmV4aXN0KCl8fCh0aGlzLl92aWRlb1RpbWVzdGFtcEJyZWFrPTEpKX1mb3IodmFyIGg9MDtoPHU7aCsrKXt2YXIgcD1yW2hdLmR0cyx2PXJbaCsxXTsoKGM9aDx1LTE/di5kdHMtcDpzP3MuZHRzLXA6YSk+MWUzfHxjPDApJiYodGhpcy5fdmlkZW9UaW1lc3RhbXBCcmVhaysrLE1hdGguYWJzKHAtdGhpcy5fbGFzdFZpZGVvRXhjZXB0aW9uTGFyZ2VHYXBEb3QpPjVlMyYmKHRoaXMuX2xhc3RWaWRlb0V4Y2VwdGlvbkxhcmdlR2FwRG90PXAsZS53YXJuaW5ncy5wdXNoKHt0eXBlOlQsdGltZTpwL2UudGltZXNjYWxlLGR0czpwLG9yaWdpbkR0czpyW2hdLm9yaWdpbkR0cyxuZXh0RHRzOnRoaXMuX3ZpZGVvTmV4dER0cyxzYW1wbGVEdXJhdGlvbjpjLHJlZlNhbXBsZUR1cmF0aW9uOmF9KSksYz1hKSxyW2hdLmR1cmF0aW9uPWMsdGhpcy5fdmlkZW9OZXh0RHRzKz1jLHRoaXMuX2xhc3RWaWRlb0R1cmF0aW9uPWN9fX19fSx7a2V5OiJfZml4QXVkaW8iLHZhbHVlOmZ1bmN0aW9uKGUpe3ZhciB0PXRoaXMscj1lLnNhbXBsZXM7ci5sZW5ndGgmJihyLmZvckVhY2goKGZ1bmN0aW9uKGUpe2UuZHRzPWUucHRzLT10Ll9iYXNlRHRzfSkpLHRoaXMuX2RvRml4QXVkaW9JbnRlcm5hbChlLHIsMWUzKSl9fSx7a2V5OiJfY2FsY3VsYXRlQmFzZUR0cyIsdmFsdWU6ZnVuY3Rpb24oZSx0KXt2YXIgcj1lLnNhbXBsZXMsYT10LnNhbXBsZXM7aWYoIXIubGVuZ3RoJiYhYS5sZW5ndGgpcmV0dXJuITE7dmFyIG49MS8wLGk9MS8wO3IubGVuZ3RoJiYoZS5iYXNlRHRzPW49clswXS5wdHMpLGEubGVuZ3RoJiYodC5iYXNlRHRzPWk9YVswXS5kdHMpLHRoaXMuX2Jhc2VEdHM9TWF0aC5taW4obixpKTt2YXIgcz1pLW47cmV0dXJuIE51bWJlci5pc0Zpbml0ZShzKSYmTWF0aC5hYnMocyk+NTAwJiZ0Lndhcm5pbmdzLnB1c2goe3R5cGU6Qix2aWRlb0Jhc2VEdHM6aSxhdWRpb0Jhc2VQdHM6bixiYXNlRHRzOnRoaXMuX2Jhc2VEdHMsZGVsdGE6c30pLHRoaXMuX2Jhc2VEdHNJbml0ZWQ9ITAsITB9fSx7a2V5OiJfcmVzZXRCYXNlRHRzV2hlblN0cmVhbUJyZWFrZWQiLHZhbHVlOmZ1bmN0aW9uKCl7dGhpcy5fY2FsY3VsYXRlQmFzZUR0cyh0aGlzLmF1ZGlvVHJhY2ssdGhpcy52aWRlb1RyYWNrKSYmKHRoaXMuYXVkaW9UcmFjay5leGlzdCgpP3RoaXMudmlkZW9UcmFjay5leGlzdCgpP3RoaXMuX2Jhc2VEdHMtPU1hdGgubWluKHRoaXMuX2F1ZGlvTmV4dFB0cyx0aGlzLl92aWRlb05leHREdHMpOnRoaXMuX2Jhc2VEdHMtPXRoaXMuX2F1ZGlvTmV4dFB0czp0aGlzLl9iYXNlRHRzLT10aGlzLl92aWRlb05leHREdHMsdGhpcy5fdmlkZW9UaW1lc3RhbXBCcmVhaz0wLHRoaXMuX2F1ZGlvVGltZXN0YW1wQnJlYWs9MCl9fSx7a2V5OiJfZG9GaXhBdWRpb0ludGVybmFsIix2YWx1ZTpmdW5jdGlvbihlLHQscil7ZS5zYW1wbGVEdXJhdGlvbnx8KGUuc2FtcGxlRHVyYXRpb249ZS5jb2RlY1R5cGU9PT1BP3NlLmdldEZyYW1lRHVyYXRpb24oZS50aW1lc2NhbGUscik6dGhpcy5fZ2V0RzcxMUR1cmF0aW9uKGUpKTt2YXIgYT1lLnNhbXBsZUR1cmF0aW9uLG49ZS5jb2RlY1R5cGU9PT1BPzEwMjQ6YSplLnRpbWVzY2FsZS8xZTM7aWYodm9pZCAwPT09dGhpcy5fYXVkaW9OZXh0UHRzKXt2YXIgaT10WzBdO3RoaXMuX2F1ZGlvTmV4dFB0cz1pLnB0c31mb3IodmFyIHM9MDtzPHQubGVuZ3RoO3MrKyl7dmFyIG89dGhpcy5fYXVkaW9OZXh0UHRzLHU9dFtzXSxjPXUucHRzLW87aWYoMD09PXMmJnRoaXMuX2F1ZGlvVGltZXN0YW1wQnJlYWs+PTUmJnRoaXMuX2tleUZyYW1lSW5OZXh0Q2h1bmsmJihvPXRoaXMuX2F1ZGlvTmV4dFB0cz11LmR0cyxjPTAsdGhpcy5fYXVkaW9UaW1lc3RhbXBCcmVhaz0wKSwhdGhpcy5fYXVkaW9UaW1lc3RhbXBCcmVhayYmYz49MyphJiZjPD11ZSYmIVcpe3ZhciBsPXRoaXMuX2dldFNpbGVudEZyYW1lKGUpfHx0WzBdLmRhdGEuc3ViYXJyYXkoKSxmPU1hdGguZmxvb3IoYy9hKTtNYXRoLmFicyh1LnB0cy10aGlzLl9sYXN0QXVkaW9FeGNlcHRpb25HYXBEb3QpPmNlJiYodGhpcy5fbGFzdEF1ZGlvRXhjZXB0aW9uR2FwRG90PXUucHRzLGUud2FybmluZ3MucHVzaCh7dHlwZTpQLHB0czp1LnB0cyxvcmlnaW5QdHM6dS5vcmlnaW5QdHMsY291bnQ6ZixuZXh0UHRzOm8scmVmU2FtcGxlRHVyYXRpb246YX0pKTtmb3IodmFyIGQ9MDtkPGY7ZCsrKXt2YXIgaD1uZXcgTyhNYXRoLmZsb29yKHRoaXMuX2F1ZGlvTmV4dFB0cythKS1NYXRoLmZsb29yKHRoaXMuX2F1ZGlvTmV4dFB0cyksbCxuKTtoLm9yaWdpblB0cz1NYXRoLmZsb29yKHRoaXMuX2Jhc2VEdHMrbyksdC5zcGxpY2UocywwLGgpLHRoaXMuX2F1ZGlvTmV4dFB0cys9YSxzKyt9cy0tfWVsc2UgYzw9LTMqYSYmYz49LTFlMz8oTWF0aC5hYnModS5wdHMtdGhpcy5fbGFzdEF1ZGlvRXhjZXB0aW9uT3ZlcmxhcERvdCk+Y2UmJih0aGlzLl9sYXN0QXVkaW9FeGNlcHRpb25PdmVybGFwRG90PXUucHRzLGUud2FybmluZ3MucHVzaCh7dHlwZTpJLHB0czp1LnB0cyxvcmlnaW5QdHM6dS5vcmlnaW5QdHMsbmV4dFB0czpvLHJlZlNhbXBsZUR1cmF0aW9uOmF9KSksdC5zcGxpY2UocywxKSxzLS0pOihNYXRoLmFicyhjKT51ZSYmKHRoaXMuX2F1ZGlvVGltZXN0YW1wQnJlYWsrKyxNYXRoLmFicyh1LnB0cy10aGlzLl9sYXN0QXVkaW9FeGNlcHRpb25MYXJnZUdhcERvdCk+Y2UmJih0aGlzLl9sYXN0QXVkaW9FeGNlcHRpb25MYXJnZUdhcERvdD11LnB0cyxlLndhcm5pbmdzLnB1c2goe3R5cGU6VSx0aW1lOnUucHRzLzFlMyxwdHM6dS5wdHMsb3JpZ2luUHRzOnUub3JpZ2luUHRzLG5leHRQdHM6byxzYW1wbGVEdXJhdGlvbjpjLHJlZlNhbXBsZUR1cmF0aW9uOmF9KSkpLHUuZHRzPXUucHRzPW8sdS5kdXJhdGlvbj1uLHRoaXMuX2F1ZGlvTmV4dFB0cys9YSl9fX0se2tleToiX2dldEc3MTFEdXJhdGlvbiIsdmFsdWU6ZnVuY3Rpb24oZSl7dmFyIHQ9ZS5zYW1wbGVTaXplLHI9ZS5jaGFubmVsQ291bnQsYT1lLnNhbXBsZVJhdGUsbj1lLnNhbXBsZXNbMF07aWYobilyZXR1cm4gMipuLmRhdGEuYnl0ZUxlbmd0aC9yLyh0LzgpL2EqMWUzfX0se2tleToiX2dldFNpbGVudEZyYW1lIix2YWx1ZTpmdW5jdGlvbihlKXtyZXR1cm4gZS5jb2RlY1R5cGU9PT1BP3NlLmdldFNpbGVudEZyYW1lKGUuY29kZWMsZS5jaGFubmVsQ291bnQpOm5ldyBVaW50OEFycmF5KDgqZS5zYW1wbGVEdXJhdGlvbiplLmNoYW5uZWxDb3VudCl9fV0pLGV9KCksZmU9ZnVuY3Rpb24oKXtmdW5jdGlvbiBlKCl7cih0aGlzLGUpfXJldHVybiBuKGUsbnVsbCxbe2tleToicGFyc2UiLHZhbHVlOmZ1bmN0aW9uKHQpe2lmKCEodC5sZW5ndGg8Mykpe3ZhciByPXt9LGE9ZS5fcGFyc2VWYWx1ZShuZXcgRGF0YVZpZXcodC5idWZmZXIsdC5ieXRlT2Zmc2V0LHQuYnl0ZUxlbmd0aCkpLG49ZS5fcGFyc2VWYWx1ZShuZXcgRGF0YVZpZXcodC5idWZmZXIsdC5ieXRlT2Zmc2V0K2Euc2l6ZSx0LmJ5dGVMZW5ndGgtYS5zaXplKSk7cmV0dXJuIHJbYS5kYXRhXT1uLmRhdGEscn19fSx7a2V5OiJfcGFyc2VWYWx1ZSIsdmFsdWU6ZnVuY3Rpb24odCl7dmFyIHIsYT10LmJ5dGVMZW5ndGgsbj0xLGk9ITE7c3dpdGNoKHQuZ2V0VWludDgoMCkpe2Nhc2UgMDpyPXQuZ2V0RmxvYXQ2NCgxKSxuKz04O2JyZWFrO2Nhc2UgMTpyPSEhdC5nZXRVaW50OCgxKSxuKz0xO2JyZWFrO2Nhc2UgMjp2YXIgcz1lLl9wYXJzZVN0cmluZyhuZXcgRGF0YVZpZXcodC5idWZmZXIsdC5ieXRlT2Zmc2V0K24sdC5ieXRlTGVuZ3RoLW4pKTtyPXMuZGF0YSxuKz1zLnNpemU7YnJlYWs7Y2FzZSAzOnI9e307dmFyIG89MDtmb3IoOT09KDE2Nzc3MjE1JnQuZ2V0VWludDMyKGEtNCkpJiYobz0zKTtuPGEtNDspe3ZhciB1PWUuX3BhcnNlT2JqZWN0KG5ldyBEYXRhVmlldyh0LmJ1ZmZlcix0LmJ5dGVPZmZzZXQrbix0LmJ5dGVMZW5ndGgtbi1vKSksYz11LnNpemUsbD11LmRhdGE7aWYodS5pc0VuZClicmVhaztyW2wubmFtZV09bC52YWx1ZSxuKz1jfWlmKG48PWEtMyk5PT09KDE2Nzc3MjE1JnQuZ2V0VWludDMyKG4tMSkpJiYobis9Myk7YnJlYWs7Y2FzZSA4OnI9e30sbis9NDt2YXIgZj0wO2Zvcig5PT0oMTY3NzcyMTUmdC5nZXRVaW50MzIoYS00KSkmJihmPTMpO248YS04Oyl7dmFyIGQ9ZS5fcGFyc2VPYmplY3QobmV3IERhdGFWaWV3KHQuYnVmZmVyLHQuYnl0ZU9mZnNldCtuLHQuYnl0ZUxlbmd0aC1uLWYpKSxoPWQuc2l6ZSxwPWQuZGF0YTtpZihkLmlzRW5kKWJyZWFrO3JbcC5uYW1lXT1wLnZhbHVlLG4rPWh9aWYobjw9YS0zKTk9PT0oMTY3NzcyMTUmdC5nZXRVaW50MzIobi0xKSkmJihuKz0zKTticmVhaztjYXNlIDk6cj12b2lkIDAsbj0xLGk9ITA7YnJlYWs7Y2FzZSAxMDpyPVtdO3ZhciB2PXQuZ2V0VWludDMyKDEpO24rPTQ7Zm9yKHZhciB5PTA7eTx2O3krKyl7dmFyIG09ZS5fcGFyc2VWYWx1ZShuZXcgRGF0YVZpZXcodC5idWZmZXIsdC5ieXRlT2Zmc2V0K24sdC5ieXRlTGVuZ3RoLW4pKSxnPW0uZGF0YSxrPW0uc2l6ZTtyLnB1c2goZyksbis9a31icmVhaztjYXNlIDExOnZhciBiPXQuZ2V0RmxvYXQ2NChuKSs2ZTQqdC5nZXRJbnQxNihuKzgpO3I9bmV3IERhdGUoYiksbis9MTA7YnJlYWs7Y2FzZSAxMjp2YXIgXz10LmdldFVpbnQzMigxKTtuKz00LHI9IiIsXz4wJiYocj1ILmRlY29kZShuZXcgVWludDhBcnJheSh0LmJ1ZmZlcix0LmJ5dGVPZmZzZXQrbixfKSkpLG4rPV87YnJlYWs7ZGVmYXVsdDpuPWF9cmV0dXJue2RhdGE6cixzaXplOm4saXNFbmQ6aX19fSx7a2V5OiJfcGFyc2VTdHJpbmciLHZhbHVlOmZ1bmN0aW9uKGUpe3ZhciB0PWUuZ2V0VWludDE2KDApLHI9IiI7cmV0dXJuIHQ+MCYmKHI9SC5kZWNvZGUobmV3IFVpbnQ4QXJyYXkoZS5idWZmZXIsZS5ieXRlT2Zmc2V0KzIsdCkpKSx7ZGF0YTpyLHNpemU6Mit0fX19LHtrZXk6Il9wYXJzZU9iamVjdCIsdmFsdWU6ZnVuY3Rpb24odCl7aWYoISh0LmJ5dGVMZW5ndGg8Mykpe3ZhciByPWUuX3BhcnNlU3RyaW5nKHQpLGE9ZS5fcGFyc2VWYWx1ZShuZXcgRGF0YVZpZXcodC5idWZmZXIsdC5ieXRlT2Zmc2V0K3Iuc2l6ZSx0LmJ5dGVMZW5ndGgtci5zaXplKSk7cmV0dXJue2RhdGE6e25hbWU6ci5kYXRhLHZhbHVlOmEuZGF0YX0sc2l6ZTpyLnNpemUrYS5zaXplLGlzRW5kOmEuaXNFbmR9fX19XSksZX0oKSxkZT1uZXcgRygiRmx2RGVtdXhlciIpLGhlPWZ1bmN0aW9uKCl7ZnVuY3Rpb24gZSh0LGEsbil7cih0aGlzLGUpLGkodGhpcywiX2hlYWRlclBhcnNlZCIsITEpLGkodGhpcywiX3JlbWFpbmluZ0RhdGEiLG51bGwpLGkodGhpcywiX2dvcElkIiwwKSxpKHRoaXMsIl9uZWVkQWRkTWV0YUJlZm9yZUtleUZyYW1lTmFsIiwhMCksdGhpcy52aWRlb1RyYWNrPXR8fG5ldyB6LHRoaXMuYXVkaW9UcmFjaz1hfHxuZXcgTSx0aGlzLm1ldGFkYXRhVHJhY2s9bnx8bmV3IE4sdGhpcy5fZml4ZXI9bmV3IGxlKHRoaXMudmlkZW9UcmFjayx0aGlzLmF1ZGlvVHJhY2ssdGhpcy5tZXRhZGF0YVRyYWNrKX1yZXR1cm4gbihlLFt7a2V5OiJkZW11eCIsdmFsdWU6ZnVuY3Rpb24odCl7dmFyIHI9YXJndW1lbnRzLmxlbmd0aD4xJiZ2b2lkIDAhPT1hcmd1bWVudHNbMV0mJmFyZ3VtZW50c1sxXSxhPSEoYXJndW1lbnRzLmxlbmd0aD4yJiZ2b2lkIDAhPT1hcmd1bWVudHNbMl0pfHxhcmd1bWVudHNbMl0sbj10aGlzLmF1ZGlvVHJhY2ssaT10aGlzLnZpZGVvVHJhY2sscz10aGlzLm1ldGFkYXRhVHJhY2s7aWYoIXImJmF8fCh0aGlzLl9yZW1haW5pbmdEYXRhPW51bGwpLHImJih0aGlzLl9oZWFkZXJQYXJzZWQ9ITEpLHI/KGkucmVzZXQoKSxuLnJlc2V0KCkscy5yZXNldCgpKTooaS5zYW1wbGVzPVtdLG4uc2FtcGxlcz1bXSxzLnNlaVNhbXBsZXM9W10scy5mbHZTY3JpcHRTYW1wbGVzPVtdLGkud2FybmluZ3M9W10sbi53YXJuaW5ncz1bXSx0aGlzLl9yZW1haW5pbmdEYXRhJiYodD1aKHRoaXMuX3JlbWFpbmluZ0RhdGEsdCksdGhpcy5fcmVtYWluaW5nRGF0YT1udWxsKSksIXQubGVuZ3RoKXJldHVybnt2aWRlb1RyYWNrOmksYXVkaW9UcmFjazpuLG1ldGFkYXRhVHJhY2s6c307dmFyIG89MDtpZighdGhpcy5faGVhZGVyUGFyc2VkKXtpZighZS5wcm9iZSh0KSl0aHJvdyBuZXcgRXJyb3IoIkludmFsaWQgZmx2IGZpbGUiKTtuLnByZXNlbnQ9KDQmdFs0XSk+Pj4yIT0wLGkucHJlc2VudD0wIT0oMSZ0WzRdKSx0aGlzLl9oZWFkZXJQYXJzZWQ9ITAsbz0kKHQsNSkrNH1mb3IodmFyIHUsYyxsLGYsZCxoPXQubGVuZ3RoO28rMTU8aCYmKHU9dFtvXSwhKG8rMTUrKGM9dFtvKzFdPDwxNnx0W28rMl08PDh8dFtvKzNdKT5oKSk7KWw9KHRbbys3XTw8MjQ+Pj4wKSsodFtvKzRdPDwxNikrKHRbbys1XTw8OCkrdFtvKzZdLG8rPTExLGY9dC5zdWJhcnJheShvLG8rYyksOD09PXU/dGhpcy5fcGFyc2VBdWRpbyhmLGwpOjk9PT11P3RoaXMuX3BhcnNlVmlkZW8oZixsKToxOD09PXU/dGhpcy5fcGFyc2VTY3JpcHQoZixsKTpkZS53YXJuKCJJbnZhbGlkIHRhZyB0eXBlOiAiLmNvbmNhdCh1KSksKGQ9JCh0LG8rPWMpKSE9PTExK2MmJmRlLndhcm4oIkludmFsaWQgUHJldlRhZ1NpemUgIi5jb25jYXQoZCwiICgiKS5jb25jYXQoMTErYywiKSIpKSxvKz00O3JldHVybiBvPGgmJih0aGlzLl9yZW1haW5pbmdEYXRhPXQuc3ViYXJyYXkobykpLG4uZm9ybWF0VGltZXNjYWxlPWkuZm9ybWF0VGltZXNjYWxlPWkudGltZXNjYWxlPXMudGltZXNjYWxlPTFlMyxuLnRpbWVzY2FsZT1uLnNhbXBsZVJhdGV8fDAsIW4uZXhpc3QoKSYmbi5oYXNTYW1wbGUoKSYmbi5yZXNldCgpLCFpLmV4aXN0KCkmJmkuaGFzU2FtcGxlKCkmJmkucmVzZXQoKSx7dmlkZW9UcmFjazppLGF1ZGlvVHJhY2s6bixtZXRhZGF0YVRyYWNrOnN9fX0se2tleToiZml4Iix2YWx1ZTpmdW5jdGlvbihlLHQscil7cmV0dXJuIHRoaXMuX2ZpeGVyLmZpeChlLHQscikse3ZpZGVvVHJhY2s6dGhpcy52aWRlb1RyYWNrLGF1ZGlvVHJhY2s6dGhpcy5hdWRpb1RyYWNrLG1ldGFkYXRhVHJhY2s6dGhpcy5tZXRhZGF0YVRyYWNrfX19LHtrZXk6ImRlbXV4QW5kRml4Iix2YWx1ZTpmdW5jdGlvbihlLHQscixhKXtyZXR1cm4gdGhpcy5kZW11eChlLHQsciksdGhpcy5maXgoYSx0LHIpfX0se2tleToiX3BhcnNlQXVkaW8iLHZhbHVlOmZ1bmN0aW9uKHQscil7aWYodC5sZW5ndGgpe3ZhciBhPSgyNDAmdFswXSk+Pj40LG49dGhpcy5hdWRpb1RyYWNrO2lmKDEwIT09YSYmNyE9PWEmJjghPT1hKXJldHVybiBkZS53YXJuKCJVbnN1cHBvcnRlZCBzb3VuZCBmb3JtYXQ6ICIuY29uY2F0KGEpKSx2b2lkIG4ucmVzZXQoKTtpZigxMCE9PWEpe3ZhciBpPSgxMiZ0WzBdKT4+MixzPSgyJnRbMF0pPj4xLG89MSZ0WzBdO24uc2FtcGxlUmF0ZT1lLkFVRElPX1JBVEVbaV0sbi5zYW1wbGVTaXplPXM/MTY6OCxuLmNoYW5uZWxDb3VudD1vKzF9MTA9PT1hP3RoaXMuX3BhcnNlQWFjKHQscik6dGhpcy5fcGFyc2VHNzExKHQscixhKX19fSx7a2V5OiJfcGFyc2VHNzExIix2YWx1ZTpmdW5jdGlvbihlLHQscil7dmFyIGE9dGhpcy5hdWRpb1RyYWNrO2EuY29kZWNUeXBlPTc9PT1yP0Q6RSxhLnNhbXBsZVJhdGU9OGUzLGEuY29kZWM9YS5jb2RlY1R5cGUsYS5zYW1wbGVzLnB1c2gobmV3IE8odCxlLnN1YmFycmF5KDEpKSl9fSx7a2V5OiJfcGFyc2VBYWMiLHZhbHVlOmZ1bmN0aW9uKGUsdCl7dmFyIHI9dGhpcy5hdWRpb1RyYWNrO2lmKHIuY29kZWNUeXBlPUEsMD09PWVbMV0pe3ZhciBhPXNlLnBhcnNlQXVkaW9TcGVjaWZpY0NvbmZpZyhlLnN1YmFycmF5KDIpKTthPyhyLmNvZGVjPWEuY29kZWMsci5jaGFubmVsQ291bnQ9YS5jaGFubmVsQ291bnQsci5zYW1wbGVSYXRlPWEuc2FtcGxlUmF0ZSxyLmNvbmZpZz1hLmNvbmZpZyxyLm9iamVjdFR5cGU9YS5vYmplY3RUeXBlLHIuc2FtcGxlUmF0ZUluZGV4PWEuc2FtcGxpbmdGcmVxdWVuY3lJbmRleCk6KHIucmVzZXQoKSxkZS53YXJuKCJDYW5ub3QgcGFyc2UgQXVkaW9TcGVjaWZpY0NvbmZpZyIsZSkpfWVsc2UgaWYoMT09PWVbMV0pe2lmKG51bGw9PXQpcmV0dXJuO3Iuc2FtcGxlcy5wdXNoKG5ldyBPKHQsZS5zdWJhcnJheSgyKSkpfWVsc2UgZGUud2FybigiVW5rbm93biBBQUNQYWNrZXRUeXBlOiAiLmNvbmNhdChlWzFdKSl9fSx7a2V5OiJfcGFyc2VWaWRlbyIsdmFsdWU6ZnVuY3Rpb24oZSx0KXt2YXIgcj10aGlzO2lmKCEoZS5sZW5ndGg8Nikpe3ZhciBhPSgyNDAmZVswXSk+Pj40LG49MTUmZVswXSxpPXRoaXMudmlkZW9UcmFjaztpZig3IT09biYmMTIhPT1uKXJldHVybiBpLnJlc2V0KCksdm9pZCBkZS53YXJuKCJVbnN1cHBvcnRlZCBjb2RlY0lkOiAiLmNvbmNhdChuKSk7dmFyIHM9MTI9PT1uO2kuY29kZWNUeXBlPXM/Uzp4O3ZhciBvPWVbMV0sdT0oZVsyXTw8MTZ8ZVszXTw8OHxlWzRdKTw8OD4+ODtpZigwPT09byl7dmFyIGM9ZS5zdWJhcnJheSg1KSxsPXM/b2UucGFyc2VIRVZDRGVjb2RlckNvbmZpZ3VyYXRpb25SZWNvcmQoYyk6aWUucGFyc2VBVkNEZWNvZGVyQ29uZmlndXJhdGlvblJlY29yZChjKTtpZihsKXt2YXIgZj1sLmh2Y0MsZD1sLnNwcyxoPWwucHBzQXJyLHA9bC5zcHNBcnIsdj1sLnZwc0Fycix5PWwubmFsVW5pdFNpemU7ZiYmKGkuaHZjQz1pLmh2Y0N8fGYpLGQmJihpLmNvZGVjPWQuY29kZWMsaS53aWR0aD1kLndpZHRoLGkuaGVpZ2h0PWQuaGVpZ2h0LGkuc2FyUmF0aW89ZC5zYXJSYXRpbyxpLmZwc051bT1kLmZwc051bSxpLmZwc0Rlbj1kLmZwc0RlbikscC5sZW5ndGgmJihpLnNwcz1wKSxoLmxlbmd0aCYmKGkucHBzPWgpLHYmJnYubGVuZ3RoJiYoaS52cHM9dikseSYmKGkubmFsVW5pdFNpemU9eSl9ZWxzZSBkZS53YXJuKCJDYW5ub3QgcGFyc2UgIi5jb25jYXQocz8iSEVWQyI6IkFWQyIsIkRlY29kZXJDb25maWd1cmF0aW9uUmVjb3JkIiksZSl9ZWxzZSBpZigxPT09byl7dmFyIG09bmUucGFyc2VBdmNDKGUuc3ViYXJyYXkoNSksaS5uYWxVbml0U2l6ZSk7aWYoKG09dGhpcy5fY2hlY2tBZGRNZXRhTmFsVG9Vbml0cyhzLG0saSkpJiZtLmxlbmd0aCl7dmFyIGc9bmV3IFIodCt1LHQsbSk7MT09PWEmJmcuc2V0VG9LZXlmcmFtZSgpLGkuc2FtcGxlcy5wdXNoKGcpLG0uZm9yRWFjaCgoZnVuY3Rpb24oZSl7dmFyIGE9cz9lWzBdPj4+MSY2MzozMSZlWzBdO3N3aXRjaChhKXtjYXNlIDU6Y2FzZSAxNjpjYXNlIDE3OmNhc2UgMTg6Y2FzZSAxOTpjYXNlIDIwOmNhc2UgMjE6Y2FzZSAyMjpjYXNlIDIzOmlmKCFzJiY1IT09YXx8cyYmNT09PWEpYnJlYWs7Zy5zZXRUb0tleWZyYW1lKCk7YnJlYWs7Y2FzZSA2OmNhc2UgMzk6Y2FzZSA0MDppZighcyYmNiE9PWF8fHMmJjY9PT1hKWJyZWFrO3IubWV0YWRhdGFUcmFjay5zZWlTYW1wbGVzLnB1c2gobmV3IEYobmUucGFyc2VTRUkobmUucmVtb3ZlRVBCKGUpLHMpLHQrdSkpfX0pKSxnLmtleWZyYW1lJiZ0aGlzLl9nb3BJZCsrLGcuZ29wSWQ9dGhpcy5fZ29wSWR9ZWxzZSBkZS53YXJuKCJDYW5ub3QgcGFyc2UgTkFMVXMiLGUpfWVsc2UgMj09PW98fGRlLndhcm4oIlVua25vd24gQVZDUGFja2V0VHlwZTogIi5jb25jYXQobykpfX19LHtrZXk6Il9jaGVja0FkZE1ldGFOYWxUb1VuaXRzIix2YWx1ZTpmdW5jdGlvbihlLHQscil7cmV0dXJuIGUmJnRoaXMuX25lZWRBZGRNZXRhQmVmb3JlS2V5RnJhbWVOYWw/dC5tYXAoKGZ1bmN0aW9uKGUpe3JldHVybiBlWzBdPj4+MSY2M30pKS5pbmNsdWRlcygzMik/KHRoaXMuX25lZWRBZGRNZXRhQmVmb3JlS2V5RnJhbWVOYWw9ITEsdCk6KHQudW5zaGlmdChyLnBwc1swXSksdC51bnNoaWZ0KHIuc3BzWzBdKSx0LnVuc2hpZnQoci52cHNbMF0pLHQuZmlsdGVyKEJvb2xlYW4pKToodGhpcy5fbmVlZEFkZE1ldGFCZWZvcmVLZXlGcmFtZU5hbD0hMSx0KX19LHtrZXk6Il9wYXJzZVNjcmlwdCIsdmFsdWU6ZnVuY3Rpb24oZSx0KXt0aGlzLm1ldGFkYXRhVHJhY2suZmx2U2NyaXB0U2FtcGxlcy5wdXNoKG5ldyBWKGZlLnBhcnNlKGUpLHQpKX19XSxbe2tleToicHJvYmUiLHZhbHVlOmZ1bmN0aW9uKGUpe3JldHVybiA3MD09PWVbMF0mJjc2PT09ZVsxXSYmODY9PT1lWzJdJiYxPT09ZVszXSYmJChlLDUpPj05fX1dKSxlfSgpO2koaGUsIkFVRElPX1JBVEUiLFs1NTAwLDExZTMsMjJlMyw0NGUzXSksbmV3IEcoIlRzRGVtdXhlciIpO3ZhciBwZT1mdW5jdGlvbigpe2Z1bmN0aW9uIGUoKXtyKHRoaXMsZSl9cmV0dXJuIG4oZSxudWxsLFt7a2V5OiJmaW5kQm94Iix2YWx1ZTpmdW5jdGlvbih0LHIpe3ZhciBhPWFyZ3VtZW50cy5sZW5ndGg+MiYmdm9pZCAwIT09YXJndW1lbnRzWzJdP2FyZ3VtZW50c1syXTowLG49W107aWYoIXQpcmV0dXJuIG47Zm9yKHZhciBpPTAscz0iIixvPTA7dC5sZW5ndGg+Nzspe2lmKGk9JCh0KSxzPVN0cmluZy5mcm9tQ2hhckNvZGUuYXBwbHkobnVsbCx0LnN1YmFycmF5KDQsOCkpLG89OCwxPT09aT8oaT1lZSh0LDgpLG8rPTgpOml8fChpPXQubGVuZ3RoKSwhclswXXx8cz09PXJbMF0pe3ZhciB1PXQuc3ViYXJyYXkoMCxpKTtpZighKHIubGVuZ3RoPDIpKXJldHVybiBlLmZpbmRCb3godS5zdWJhcnJheShvKSxyLnNsaWNlKDEpLGErbyk7bi5wdXNoKHtzdGFydDphLHNpemU6aSxoZWFkZXJTaXplOm8sdHlwZTpzLGRhdGE6dX0pfWErPWksdD10LnN1YmFycmF5KGkpfXJldHVybiBufX0se2tleToidGZoZCIsdmFsdWU6ZnVuY3Rpb24oZSl7cmV0dXJuIGdlKGUsITAsKGZ1bmN0aW9uKGUsdCl7ZS50cmFja0lkPSQodCk7dmFyIHI9NCxhPTEmZS5mbGFncyxuPTImZS5mbGFncyxpPTgmZS5mbGFncyxzPTE2JmUuZmxhZ3Msbz0zMiZlLmZsYWdzO2EmJihyKz00LGUuYmFzZURhdGFPZmZzZXQ9JCh0LHIpLHIrPTQpLG4mJihlLnNhbXBsZURlc2NyaXB0aW9uSW5kZXg9JCh0LHIpLHIrPTQpLGkmJihlLmRlZmF1bHRTYW1wbGVEdXJhdGlvbj0kKHQscikscis9NCkscyYmKGUuZGVmYXVsdFNhbXBsZVNpemU9JCh0LHIpLHIrPTQpLG8mJihlLmRlZmF1bHRTYW1wbGVGbGFncz0kKHQscikpfSkpfX0se2tleToic2lkeCIsdmFsdWU6ZnVuY3Rpb24oZSl7cmV0dXJuIGdlKGUsITAsKGZ1bmN0aW9uKGUsdCl7dmFyIHI9MDtlLnJlZmVyZW5jZV9JRD0kKHQscikscis9NCxlLnRpbWVzY2FsZT0kKHQscikscis9NCwwPT09ZS52ZXJzaW9uPyhlLmVhcmxpZXN0X3ByZXNlbnRhdGlvbl90aW1lPSQodCxyKSxyKz00LGUuZmlyc3Rfb2Zmc2V0PSQodCxyKSxyKz00KTooZS5lYXJsaWVzdF9wcmVzZW50YXRpb25fdGltZT1lZSh0LHIpLHIrPTgsZS5maXJzdF9vZmZzZXQ9ZWUodCxyKSxyKz04KSxyKz0yLGUucmVmZXJlbmNlcz1bXTt2YXIgYT1KKHQscik7cis9Mjtmb3IodmFyIG49MDtuPGE7bisrKXt2YXIgaT17fTtlLnJlZmVyZW5jZXMucHVzaChpKTt2YXIgcz0kKHQscik7cis9NCxpLnJlZmVyZW5jZV90eXBlPXM+PjMxJjEsaS5yZWZlcmVuY2VkX3NpemU9MjE0NzQ4MzY0NyZzLGkuc3Vic2VnbWVudF9kdXJhdGlvbj0kKHQscikscz0kKHQscis9NCkscis9NCxpLnN0YXJ0c193aXRoX1NBUD1zPj4zMSYxLGkuU0FQX3R5cGU9cz4+MjgmNyxpLlNBUF9kZWx0YV90aW1lPTI2ODQzNTQ1NSZzfX0pKX19LHtrZXk6Im1vb3YiLHZhbHVlOmZ1bmN0aW9uKHQpe3JldHVybiBnZSh0LCExLChmdW5jdGlvbih0LHIsYSl7dC5tdmhkPWUubXZoZChlLmZpbmRCb3gocixbIm12aGQiXSxhKVswXSksdC50cmFrPWUuZmluZEJveChyLFsidHJhayJdLGEpLm1hcCgoZnVuY3Rpb24odCl7cmV0dXJuIGUudHJhayh0KX0pKSx0LnBzc2g9ZS5wc3NoKGUuZmluZEJveChyLFsicHNzaCJdLGEpWzBdKX0pKX19LHtrZXk6Im12aGQiLHZhbHVlOmZ1bmN0aW9uKGUpe3JldHVybiBnZShlLCEwLChmdW5jdGlvbihlLHQpe3ZhciByPTA7MT09PWUudmVyc2lvbj8oZS50aW1lc2NhbGU9JCh0LDE2KSxlLmR1cmF0aW9uPWVlKHQsMjApLHIrPTI4KTooZS50aW1lc2NhbGU9JCh0LDgpLGUuZHVyYXRpb249JCh0LDEyKSxyKz0xNiksZS5uZXh0VHJhY2tJZD0kKHQscis3Nil9KSl9fSx7a2V5OiJ0cmFrIix2YWx1ZTpmdW5jdGlvbih0KXtyZXR1cm4gZ2UodCwhMSwoZnVuY3Rpb24odCxyLGEpe3QudGtoZD1lLnRraGQoZS5maW5kQm94KHIsWyJ0a2hkIl0sYSlbMF0pLHQubWRpYT1lLm1kaWEoZS5maW5kQm94KHIsWyJtZGlhIl0sYSlbMF0pfSkpfX0se2tleToidGtoZCIsdmFsdWU6ZnVuY3Rpb24oZSl7cmV0dXJuIGdlKGUsITAsKGZ1bmN0aW9uKGUsdCl7dmFyIHI9MDsxPT09ZS52ZXJzaW9uPyhlLnRyYWNrSWQ9JCh0LDE2KSxlLmR1cmF0aW9uPWVlKHQsMjQpLHIrPTMyKTooZS50cmFja0lkPSQodCw4KSxlLmR1cmF0aW9uPSQodCwxNikscis9MjApLGUud2lkdGg9JCh0LHIrNTIpLGUuaGVpZ2h0PSQodCxyKzU2KX0pKX19LHtrZXk6Im1kaWEiLHZhbHVlOmZ1bmN0aW9uKHQpe3JldHVybiBnZSh0LCExLChmdW5jdGlvbih0LHIsYSl7dC5tZGhkPWUubWRoZChlLmZpbmRCb3gocixbIm1kaGQiXSxhKVswXSksdC5oZGxyPWUuaGRscihlLmZpbmRCb3gocixbImhkbHIiXSxhKVswXSksdC5taW5mPWUubWluZihlLmZpbmRCb3gocixbIm1pbmYiXSxhKVswXSl9KSl9fSx7a2V5OiJtZGhkIix2YWx1ZTpmdW5jdGlvbihlKXtyZXR1cm4gZ2UoZSwhMCwoZnVuY3Rpb24oZSx0KXt2YXIgcj0wOzE9PT1lLnZlcnNpb24/KGUudGltZXNjYWxlPSQodCwxNiksZS5kdXJhdGlvbj1lZSh0LDIwKSxyKz0yOCk6KGUudGltZXNjYWxlPSQodCw4KSxlLmR1cmF0aW9uPSQodCwxMikscis9MTYpO3ZhciBhPUoodCxyKTtlLmxhbmd1YWdlPVN0cmluZy5mcm9tQ2hhckNvZGUoOTYrKGE+PjEwJjMxKSw5NisoYT4+NSYzMSksOTYrKDMxJmEpKX0pKX19LHtrZXk6ImhkbHIiLHZhbHVlOmZ1bmN0aW9uKGUpe3JldHVybiBnZShlLCEwLChmdW5jdGlvbihlLHQpezA9PT1lLnZlcnNpb24mJihlLmhhbmRsZXJUeXBlPVN0cmluZy5mcm9tQ2hhckNvZGUuYXBwbHkobnVsbCx0LnN1YmFycmF5KDQsOCkpKX0pKX19LHtrZXk6Im1pbmYiLHZhbHVlOmZ1bmN0aW9uKHQpe3JldHVybiBnZSh0LCExLChmdW5jdGlvbih0LHIsYSl7dC52bWhkPWUudm1oZChlLmZpbmRCb3gocixbInZtaGQiXSxhKVswXSksdC5zbWhkPWUuc21oZChlLmZpbmRCb3gocixbInNtaGQiXSxhKVswXSksdC5zdGJsPWUuc3RibChlLmZpbmRCb3gocixbInN0YmwiXSxhKVswXSl9KSl9fSx7a2V5OiJ2bWhkIix2YWx1ZTpmdW5jdGlvbihlKXtyZXR1cm4gZ2UoZSwhMCwoZnVuY3Rpb24oZSx0KXtlLmdyYXBoaWNzbW9kZT1KKHQpLGUub3Bjb2xvcj1bSih0LDIpLEoodCw0KSxKKHQsNildfSkpfX0se2tleToic21oZCIsdmFsdWU6ZnVuY3Rpb24oZSl7cmV0dXJuIGdlKGUsITAsKGZ1bmN0aW9uKGUsdCl7ZS5iYWxhbmNlPUoodCl9KSl9fSx7a2V5OiJzdGJsIix2YWx1ZTpmdW5jdGlvbih0KXtyZXR1cm4gZ2UodCwhMSwoZnVuY3Rpb24odCxyLGEpe3ZhciBuLGksczt0LnN0c2Q9ZS5zdHNkKGUuZmluZEJveChyLFsic3RzZCJdLGEpWzBdKSx0LnN0dHM9ZS5zdHRzKGUuZmluZEJveChyLFsic3R0cyJdLGEpWzBdKSx0LmN0dHM9ZS5jdHRzKGUuZmluZEJveChyLFsiY3R0cyJdLGEpWzBdKSx0LnN0c2M9ZS5zdHNjKGUuZmluZEJveChyLFsic3RzYyJdLGEpWzBdKSx0LnN0c3o9ZS5zdHN6KGUuZmluZEJveChyLFsic3RzeiJdLGEpWzBdKSx0LnN0Y289ZS5zdGNvKGUuZmluZEJveChyLFsic3RjbyJdLGEpWzBdKSx0LnN0Y298fCh0LmNvNjQ9ZS5jbzY0KGUuZmluZEJveChyLFsiY282NCJdLGEpWzBdKSx0LnN0Y289dC5jbzY0KTt2YXIgbz1udWxsPT09KG49dC5zdHNkLmVudHJpZXNbMF0pfHx2b2lkIDA9PT1ufHxudWxsPT09KGk9bi5zaW5mKXx8dm9pZCAwPT09aXx8bnVsbD09PShzPWkuc2NoaSl8fHZvaWQgMD09PXM/dm9pZCAwOnMudGVuYy5kZWZhdWx0X0lWX3NpemU7dC5zdHNzPWUuc3RzcyhlLmZpbmRCb3gocixbInN0c3MiXSxhKVswXSksdC5zZW5jPWUuc2VuYyhlLmZpbmRCb3gocixbInNlbmMiXSxhKVswXSxvKX0pKX19LHtrZXk6InNlbmMiLHZhbHVlOmZ1bmN0aW9uKGUpe3ZhciB0PWFyZ3VtZW50cy5sZW5ndGg+MSYmdm9pZCAwIT09YXJndW1lbnRzWzFdP2FyZ3VtZW50c1sxXTo4O3JldHVybiBnZShlLCEwLChmdW5jdGlvbihlLHIpe3ZhciBhPTAsbj0kKHIsYSk7YSs9NCxlLnNhbXBsZXM9W107Zm9yKHZhciBpPTA7aTxuO2krKyl7Zm9yKHZhciBzPXtJbml0aWFsaXphdGlvblZlY3RvcjpbXX0sbz0wO288dDtvKyspcy5Jbml0aWFsaXphdGlvblZlY3RvcltvXT1yW2Erb107aWYoYSs9dCwyJmUuZmxhZ3Mpe3Muc3Vic2FtcGxlcz1bXTt2YXIgdT1KKHIsYSk7YSs9Mjtmb3IodmFyIGM9MDtjPHU7YysrKXt2YXIgbD17fTtsLkJ5dGVzT2ZDbGVhckRhdGE9SihyLGEpLGErPTIsbC5CeXRlc09mUHJvdGVjdGVkRGF0YT0kKHIsYSksYSs9NCxzLnN1YnNhbXBsZXMucHVzaChsKX19ZS5zYW1wbGVzLnB1c2gocyl9fSkpfX0se2tleToicHNzaCIsdmFsdWU6ZnVuY3Rpb24oZSl7cmV0dXJuIGdlKGUsITAsKGZ1bmN0aW9uKGUsdCl7Zm9yKHZhciByPVtdLGE9W10sbj0wLGk9MDtpPDE2O2krKylhLnB1c2goYmUodFtuK2ldKSk7aWYobis9MTYsZS52ZXJzaW9uPjApe3ZhciBzPSQodCxuKTtuKz00O2Zvcih2YXIgbz0wO288KCIiK3MpLmxlbmd0aDtvKyspZm9yKHZhciB1PTA7dTwxNjt1Kyspe3ZhciBjPXRbbl07bis9MSxyLnB1c2goYmUoYykpfX12YXIgbD0kKHQsbik7ZS5kYXRhX3NpemU9bCxuKz00LGUua2lkPXIsZS5zeXN0ZW1faWQ9YSxlLmJ1ZmZlcj10fSkpfX0se2tleToic3RzZCIsdmFsdWU6ZnVuY3Rpb24odCl7cmV0dXJuIGdlKHQsITAsKGZ1bmN0aW9uKHQscixhKXt0LmVudHJ5Q291bnQ9JChyKSx0LmVudHJpZXM9ZS5maW5kQm94KHIuc3ViYXJyYXkoNCksW10sYSs0KS5tYXAoKGZ1bmN0aW9uKHQpe3N3aXRjaCh0LnR5cGUpe2Nhc2UiYXZjMSI6Y2FzZSJhdmMyIjpjYXNlImF2YzMiOmNhc2UiYXZjNCI6cmV0dXJuIGUuYXZjMSh0KTtjYXNlImh2YzEiOmNhc2UiaGV2MSI6cmV0dXJuIGUuaHZjMSh0KTtjYXNlIm1wNGEiOnJldHVybiBlLm1wNGEodCk7Y2FzZSJhbGF3IjpjYXNlInVsYXciOnJldHVybiBlLmFsYXcodCk7Y2FzZSJlbmNhIjpyZXR1cm4gZ2UodCwhMSwoZnVuY3Rpb24odCxyLGEpe3QuY2hhbm5lbENvdW50PUoociwxNiksdC5zYW1wbGVzaXplPUoociwxOCksdC5zYW1wbGVSYXRlPSQociwyNCkvNjU1MzYscj1yLnN1YmFycmF5KDI4KSx0LnNpbmY9ZS5zaW5mKGUuZmluZEJveChyLFsic2luZiJdLGEpWzBdKSx0LmVzZHM9ZS5lc2RzKGUuZmluZEJveChyLFsiZXNkcyJdLGEpWzBdKX0pKTtjYXNlImVuY3YiOnJldHVybiBnZSh0LCExLChmdW5jdGlvbih0LHIsYSl7dC53aWR0aD1KKHIsMjQpLHQuaGVpZ2h0PUoociwyNiksdC5ob3JpenJlc29sdXRpb249JChyLDI4KSx0LnZlcnRyZXNvbHV0aW9uPSQociwzMikscj1yLnN1YmFycmF5KDc4KSx0LnNpbmY9ZS5zaW5mKGUuZmluZEJveChyLFsic2luZiJdLGEpWzBdKSx0LmF2Y0M9ZS5hdmNDKGUuZmluZEJveChyLFsiYXZjQyJdLGEpWzBdKSx0Lmh2Y0M9ZS5odmNDKGUuZmluZEJveChyLFsiaHZjQyJdLGEpWzBdKSx0LnBhc3A9ZS5wYXNwKGUuZmluZEJveChyLFsicGFzcCJdLGEpWzBdKX0pKX19KSkuZmlsdGVyKEJvb2xlYW4pfSkpfX0se2tleToidGVuYyIsdmFsdWU6ZnVuY3Rpb24oZSl7cmV0dXJuIGdlKGUsITEsKGZ1bmN0aW9uKGUsdCl7dmFyIHI9NjtlLmRlZmF1bHRfSXNFbmNyeXB0ZWQ9dFtyXSxyKz0xLGUuZGVmYXVsdF9JVl9zaXplPXRbcl0scis9MSxlLmRlZmF1bHRfS0lEPVtdO2Zvcih2YXIgYT0wO2E8MTY7YSsrKWUuZGVmYXVsdF9LSUQucHVzaChiZSh0W3JdKSkscis9MX0pKX19LHtrZXk6InNjaGkiLHZhbHVlOmZ1bmN0aW9uKHQpe3JldHVybiBnZSh0LCExLChmdW5jdGlvbih0LHIsYSl7dC50ZW5jPWUudGVuYyhlLmZpbmRCb3gocixbInRlbmMiXSxhKVswXSl9KSl9fSx7a2V5OiJzaW5mIix2YWx1ZTpmdW5jdGlvbih0KXtyZXR1cm4gZ2UodCwhMSwoZnVuY3Rpb24odCxyLGEpe3Quc2NoaT1lLnNjaGkoZS5maW5kQm94KHIsWyJzY2hpIl0sYSlbMF0pLHQuZnJtYT1lLmZybWEoZS5maW5kQm94KHIsWyJmcm1hIl0sYSlbMF0pfSkpfX0se2tleToiZnJtYSIsdmFsdWU6ZnVuY3Rpb24oZSl7cmV0dXJuIGdlKGUsITEsKGZ1bmN0aW9uKGUsdCl7ZS5kYXRhX2Zvcm1hdD0iIjtmb3IodmFyIHI9MDtyPDQ7cisrKWUuZGF0YV9mb3JtYXQrPVN0cmluZy5mcm9tQ2hhckNvZGUodFtyXSl9KSl9fSx7a2V5OiJhdmMxIix2YWx1ZTpmdW5jdGlvbih0KXtyZXR1cm4gZ2UodCwhMSwoZnVuY3Rpb24odCxyLGEpe3ZhciBuPXllKHQsciksaT1yLnN1YmFycmF5KG4pO2ErPW4sdC5hdmNDPWUuYXZjQyhlLmZpbmRCb3goaSxbImF2Y0MiXSxhKVswXSksdC5wYXNwPWUucGFzcChlLmZpbmRCb3goaSxbInBhc3AiXSxhKVswXSl9KSl9fSx7a2V5OiJhdmNDIix2YWx1ZTpmdW5jdGlvbihlKXtyZXR1cm4gZ2UoZSwhMSwoZnVuY3Rpb24odCxyKXt0LmRhdGE9ZS5kYXRhLHQuY29uZmlndXJhdGlvblZlcnNpb249clswXSx0LkFWQ1Byb2ZpbGVJbmRpY2F0aW9uPXJbMV0sdC5wcm9maWxlQ29tcGF0aWJpbGl0eT1yWzJdLHQuQVZDTGV2ZWxJbmRpY2F0aW9uPXJbM10sdC5jb2RlYz10ZShbclsxXSxyWzJdLHJbM11dKSx0Lmxlbmd0aFNpemVNaW51c09uZT0zJnJbNF0sdC5zcHNMZW5ndGg9MzEmcls1XSx0LnNwcz1bXTtmb3IodmFyIGE9NixuPTA7bjx0LnNwc0xlbmd0aDtuKyspe3ZhciBpPUoocixhKTthKz0yLHQuc3BzLnB1c2goci5zdWJhcnJheShhLGEraSkpLGErPWl9dC5wcHNMZW5ndGg9clthXSxhKz0xLHQucHBzPVtdO2Zvcih2YXIgcz0wO3M8dC5wcHNMZW5ndGg7cysrKXt2YXIgbz1KKHIsYSk7YSs9Mix0LnBwcy5wdXNoKHIuc3ViYXJyYXkoYSxhKz1vKSksYSs9b319KSl9fSx7a2V5OiJodmMxIix2YWx1ZTpmdW5jdGlvbih0KXtyZXR1cm4gZ2UodCwhMSwoZnVuY3Rpb24odCxyLGEpe3ZhciBuPXllKHQsciksaT1yLnN1YmFycmF5KG4pO2ErPW4sdC5odmNDPWUuaHZjQyhlLmZpbmRCb3goaSxbImh2Y0MiXSxhKVswXSksdC5wYXNwPWUucGFzcChlLmZpbmRCb3goaSxbInBhc3AiXSxhKVswXSl9KSl9fSx7a2V5OiJodmNDIix2YWx1ZTpmdW5jdGlvbihlKXtyZXR1cm4gZ2UoZSwhMSwoZnVuY3Rpb24odCxyKXt0LmRhdGE9ZS5kYXRhLHQuY29kZWM9ImhldjEuMS42Lkw5My5CMCIsdC5jb25maWd1cmF0aW9uVmVyc2lvbj1yWzBdO3ZhciBhPXJbMV07dC5nZW5lcmFsUHJvZmlsZVNwYWNlPWE+PjYsdC5nZW5lcmFsVGllckZsYWc9KDMyJmEpPj41LHQuZ2VuZXJhbFByb2ZpbGVJZGM9MzEmYSx0LmdlbmVyYWxQcm9maWxlQ29tcGF0aWJpbGl0eT0kKHIsMiksdC5nZW5lcmFsQ29uc3RyYWludEluZGljYXRvckZsYWdzPXIuc3ViYXJyYXkoNiwxMiksdC5nZW5lcmFsTGV2ZWxJZGM9clsxMl0sdC5hdmdGcmFtZVJhdGU9SihyLDE5KSx0Lm51bU9mQXJyYXlzPXJbMjJdLHQudnBzPVtdLHQuc3BzPVtdLHQucHBzPVtdO2Zvcih2YXIgbj0yMyxpPTAscz0wLG89MCx1PTA7dTx0Lm51bU9mQXJyYXlzO3UrKyl7aT02MyZyW25dLHM9SihyLG4rMSksbis9Mztmb3IodmFyIGMsbD1bXSxmPTA7ZjxzO2YrKylvPUoocixuKSxuKz0yLGwucHVzaChyLnN1YmFycmF5KG4sbitvKSksbis9bztpZigzMj09PWkpKGM9dC52cHMpLnB1c2guYXBwbHkoYyxsKTtlbHNlIGlmKDMzPT09aSl7dmFyIGQ7KGQ9dC5zcHMpLnB1c2guYXBwbHkoZCxsKX1lbHNlIGlmKDM0PT09aSl7dmFyIGg7KGg9dC5wcHMpLnB1c2guYXBwbHkoaCxsKX19fSkpfX0se2tleToicGFzcCIsdmFsdWU6ZnVuY3Rpb24oZSl7cmV0dXJuIGdlKGUsITEsKGZ1bmN0aW9uKGUsdCl7ZS5oU3BhY2luZz0kKHQpLGUudlNwYWNpbmc9JCh0LDQpfSkpfX0se2tleToibXA0YSIsdmFsdWU6ZnVuY3Rpb24odCl7cmV0dXJuIGdlKHQsITEsKGZ1bmN0aW9uKHQscixhKXt2YXIgbj1tZSh0LHIpO3QuZXNkcz1lLmVzZHMoZS5maW5kQm94KHIuc3ViYXJyYXkobiksWyJlc2RzIl0sYStuKVswXSl9KSl9fSx7a2V5OiJlc2RzIix2YWx1ZTpmdW5jdGlvbihlKXtyZXR1cm4gZ2UoZSwhMCwoZnVuY3Rpb24oZSx0KXtlLmNvZGVjPSJtcDRhLiI7Zm9yKHZhciByPTAsYT0wLG49MCxpPTA7dC5sZW5ndGg7KXtmb3IoaT10W3I9MF0sYT10W3IrMV0scis9MjsxMjgmYTspbj0oMTI3JmEpPDw3LGE9dFtyXSxyKz0xO2lmKG4rPTEyNyZhLDM9PT1pKXQ9dC5zdWJhcnJheShyKzMpO2Vsc2V7aWYoNCE9PWkpe2lmKDU9PT1pKXt2YXIgcz1lLmNvbmZpZz10LnN1YmFycmF5KHIscituKSxvPSgyNDgmc1swXSk+PjM7cmV0dXJuIDMxPT09byYmcy5sZW5ndGg+PTImJihvPTMyKygoNyZzWzBdKTw8MykrKCgyMjQmc1sxXSk+PjUpKSxlLm9iamVjdFR5cGU9byxlLmNvZGVjKz1vLnRvU3RyaW5nKDE2KSx2b2lkKCIuIj09PWUuY29kZWNbZS5jb2RlYy5sZW5ndGgtMV0mJihlLmNvZGVjPWUuY29kZWMuc3Vic3RyaW5nKDAsZS5jb2RlYy5sZW5ndGgtMSkpKX1yZXR1cm4gdm9pZCgiLiI9PT1lLmNvZGVjW2UuY29kZWMubGVuZ3RoLTFdJiYoZS5jb2RlYz1lLmNvZGVjLnN1YnN0cmluZygwLGUuY29kZWMubGVuZ3RoLTEpKSl9ZS5jb2RlYys9KHRbcl0udG9TdHJpbmcoMTYpKyIuIikucGFkU3RhcnQoMywiMCIpLHQ9dC5zdWJhcnJheShyKzEzKX19fSkpfX0se2tleToiYWxhdyIsdmFsdWU6ZnVuY3Rpb24oZSl7cmV0dXJuIGdlKGUsITEsKGZ1bmN0aW9uKGUsdCl7bWUoZSx0KX0pKX19LHtrZXk6InN0dHMiLHZhbHVlOmZ1bmN0aW9uKGUpe3JldHVybiBnZShlLCEwLChmdW5jdGlvbihlLHQpe2Zvcih2YXIgcj0kKHQpLGE9W10sbj00LGk9MDtpPHI7aSsrKWEucHVzaCh7Y291bnQ6JCh0LG4pLGRlbHRhOiQodCxuKzQpfSksbis9ODtlLmVudHJ5Q291bnQ9cixlLmVudHJpZXM9YX0pKX19LHtrZXk6ImN0dHMiLHZhbHVlOmZ1bmN0aW9uKGUpe3JldHVybiBnZShlLCEwLChmdW5jdGlvbihlLHQpe3ZhciByPSQodCksYT1bXSxuPTQ7aWYoMT09PWUudmVyc2lvbilmb3IodmFyIGk9MDtpPHI7aSsrKWEucHVzaCh7Y291bnQ6JCh0LG4pLG9mZnNldDokKHQsbis0KX0pLG4rPTg7ZWxzZSBmb3IodmFyIHM9MDtzPHI7cysrKWEucHVzaCh7Y291bnQ6JCh0LG4pLG9mZnNldDotKDErfiQodCxuKzQpKX0pLG4rPTg7ZS5lbnRyeUNvdW50PXIsZS5lbnRyaWVzPWF9KSl9fSx7a2V5OiJzdHNjIix2YWx1ZTpmdW5jdGlvbihlKXtyZXR1cm4gZ2UoZSwhMCwoZnVuY3Rpb24oZSx0KXtmb3IodmFyIHI9JCh0KSxhPVtdLG49NCxpPTA7aTxyO2krKylhLnB1c2goe2ZpcnN0Q2h1bms6JCh0LG4pLHNhbXBsZXNQZXJDaHVuazokKHQsbis0KSxzYW1wbGVEZXNjcmlwdGlvbkluZGV4OiQodCxuKzgpfSksbis9MTI7ZS5lbnRyeUNvdW50PXIsZS5lbnRyaWVzPWF9KSl9fSx7a2V5OiJzdHN6Iix2YWx1ZTpmdW5jdGlvbihlKXtyZXR1cm4gZ2UoZSwhMCwoZnVuY3Rpb24oZSx0KXt2YXIgcj0kKHQpLGE9JCh0LDQpLG49W107aWYoIXIpZm9yKHZhciBpPTgscz0wO3M8YTtzKyspbi5wdXNoKCQodCxpKSksaSs9NDtlLnNhbXBsZVNpemU9cixlLnNhbXBsZUNvdW50PWEsZS5lbnRyeVNpemVzPW59KSl9fSx7a2V5OiJzdGNvIix2YWx1ZTpmdW5jdGlvbihlKXtyZXR1cm4gZ2UoZSwhMCwoZnVuY3Rpb24oZSx0KXtmb3IodmFyIHI9JCh0KSxhPVtdLG49NCxpPTA7aTxyO2krKylhLnB1c2goJCh0LG4pKSxuKz00O2UuZW50cnlDb3VudD1yLGUuZW50cmllcz1hfSkpfX0se2tleToiY282NCIsdmFsdWU6ZnVuY3Rpb24oZSl7cmV0dXJuIGdlKGUsITAsKGZ1bmN0aW9uKGUsdCl7Zm9yKHZhciByPSQodCksYT1bXSxuPTQsaT0wO2k8cjtpKyspYS5wdXNoKGVlKHQsbikpLG4rPTg7ZS5lbnRyeUNvdW50PXIsZS5lbnRyaWVzPWF9KSl9fSx7a2V5OiJzdHNzIix2YWx1ZTpmdW5jdGlvbihlKXtyZXR1cm4gZ2UoZSwhMCwoZnVuY3Rpb24oZSx0KXtmb3IodmFyIHI9JCh0KSxhPVtdLG49NCxpPTA7aTxyO2krKylhLnB1c2goJCh0LG4pKSxuKz00O2UuZW50cnlDb3VudD1yLGUuZW50cmllcz1hfSkpfX0se2tleToibW9vZiIsdmFsdWU6ZnVuY3Rpb24odCl7cmV0dXJuIGdlKHQsITEsKGZ1bmN0aW9uKHQscixhKXt0Lm1maGQ9ZS5tZmhkKGUuZmluZEJveChyLFsibWZoZCJdLGEpWzBdKSx0LnRyYWY9ZS5maW5kQm94KHIsWyJ0cmFmIl0sYSkubWFwKChmdW5jdGlvbih0KXtyZXR1cm4gZS50cmFmKHQpfSkpfSkpfX0se2tleToibWZoZCIsdmFsdWU6ZnVuY3Rpb24oZSl7cmV0dXJuIGdlKGUsITAsKGZ1bmN0aW9uKGUsdCl7ZS5zZXF1ZW5jZU51bWJlcj0kKHQpfSkpfX0se2tleToidHJhZiIsdmFsdWU6ZnVuY3Rpb24odCl7cmV0dXJuIGdlKHQsITEsKGZ1bmN0aW9uKHQscixhKXt0LnRmaGQ9ZS50ZmhkKGUuZmluZEJveChyLFsidGZoZCJdLGEpWzBdKSx0LnRmZHQ9ZS50ZmR0KGUuZmluZEJveChyLFsidGZkdCJdLGEpWzBdKSx0LnRydW49ZS50cnVuKGUuZmluZEJveChyLFsidHJ1biJdLGEpWzBdKX0pKX19LHtrZXk6InRydW4iLHZhbHVlOmZ1bmN0aW9uKGUpe3JldHVybiBnZShlLCEwLChmdW5jdGlvbihlLHQpe3ZhciByPWUudmVyc2lvbixhPWUuZmxhZ3Msbj10Lmxlbmd0aCxpPWUuc2FtcGxlQ291bnQ9JCh0KSxzPTQ7aWYobj5zJiYxJmEmJihlLmRhdGFPZmZzZXQ9LSgxK34kKHQscykpLHMrPTQpLG4+cyYmNCZhJiYoZS5maXJzdFNhbXBsZUZsYWdzPSQodCxzKSxzKz00KSxlLnNhbXBsZXM9W10sbj5zKWZvcih2YXIgbyx1PTA7dTxpO3UrKylvPXt9LDI1NiZhJiYoby5kdXJhdGlvbj0kKHQscykscys9NCksNTEyJmEmJihvLnNpemU9JCh0LHMpLHMrPTQpLDEwMjQmYSYmKG8uZmxhZ3M9JCh0LHMpLHMrPTQpLDIwNDgmYSYmKG8uY3RzPXI/LSgxK34kKHQscys0KSk6JCh0LHMpLHMrPTQpLGUuc2FtcGxlcy5wdXNoKG8pfSkpfX0se2tleToidGZkdCIsdmFsdWU6ZnVuY3Rpb24oZSl7cmV0dXJuIGdlKGUsITAsKGZ1bmN0aW9uKGUsdCl7MT09PWUudmVyc2lvbj9lLmJhc2VNZWRpYURlY29kZVRpbWU9ZWUodCk6ZS5iYXNlTWVkaWFEZWNvZGVUaW1lPSQodCl9KSl9fSx7a2V5OiJwcm9iZSIsdmFsdWU6ZnVuY3Rpb24odCl7cmV0dXJuISFlLmZpbmRCb3godCxbImZ0eXAiXSl9fSx7a2V5OiJwYXJzZVNhbXBsZUZsYWdzIix2YWx1ZTpmdW5jdGlvbihlKXtyZXR1cm57aXNMZWFkaW5nOigxMiZlWzBdKT4+PjIsZGVwZW5kc09uOjMmZVswXSxpc0RlcGVuZGVkT246KDE5MiZlWzFdKT4+PjYsaGFzUmVkdW5kYW5jeTooNDgmZVsxXSk+Pj40LHBhZGRpbmdWYWx1ZTooMTQmZVsxXSk+Pj4xLGlzTm9uU3luY1NhbXBsZToxJmVbMV0sZGVncmFkYXRpb25Qcmlvcml0eTplWzJdPDw4fGVbM119fX0se2tleToibW9vdlRvVHJhY2siLHZhbHVlOmZ1bmN0aW9uKGUsdCxyKXt2YXIgYSxuLGk9ZS50cmFrO2lmKGkmJmkubGVuZ3RoKXt2YXIgcz1pLmZpbmQoKGZ1bmN0aW9uKGUpe3ZhciB0LHI7cmV0dXJuInZpZGUiPT09KG51bGw9PT0odD1lLm1kaWEpfHx2b2lkIDA9PT10fHxudWxsPT09KHI9dC5oZGxyKXx8dm9pZCAwPT09cj92b2lkIDA6ci5oYW5kbGVyVHlwZSl9KSksbz1pLmZpbmQoKGZ1bmN0aW9uKGUpe3ZhciB0LHI7cmV0dXJuInNvdW4iPT09KG51bGw9PT0odD1lLm1kaWEpfHx2b2lkIDA9PT10fHxudWxsPT09KHI9dC5oZGxyKXx8dm9pZCAwPT09cj92b2lkIDA6ci5oYW5kbGVyVHlwZSl9KSk7aWYocyYmdCl7dmFyIHUsYyxsLGYsZCxoLHAsdj10LHk9bnVsbD09PSh1PXMudGtoZCl8fHZvaWQgMD09PXU/dm9pZCAwOnUudHJhY2tJZDtudWxsIT15JiYodi5pZD1zLnRraGQudHJhY2tJZCksdi50a2hkRHVyYXRpb249cy50a2hkLmR1cmF0aW9uLHYubXZoZER1cnRpb249ZS5tdmhkLmR1cmF0aW9uLHYubXZoZFRpbWVjYWxlPWUubXZoZC50aW1lc2NhbGUsdi50aW1lc2NhbGU9di5mb3JtYXRUaW1lc2NhbGU9cy5tZGlhLm1kaGQudGltZXNjYWxlLHYuZHVyYXRpb249cy5tZGlhLm1kaGQuZHVyYXRpb258fHYubXZoZER1cnRpb24vdi5tdmhkVGltZWNhbGUqdi50aW1lc2NhbGU7dmFyIG0sZyxrLGIsXyx3LHgsQSxCPXMubWRpYS5taW5mLnN0Ymwuc3RzZC5lbnRyaWVzWzBdO2lmKHYud2lkdGg9Qi53aWR0aCx2LmhlaWdodD1CLmhlaWdodCxCLnBhc3AmJih2LnNhclJhdGlvPVtCLnBhc3AuaFNwYWNpbmcsQi5wYXNwLnZTcGFjaW5nXSksQi5odmNDKXYuY29kZWNUeXBlPVMsdi5jb2RlYz1CLmh2Y0MuY29kZWMsdi52cHM9Qi5odmNDLnZwcyx2LnNwcz1CLmh2Y0Muc3BzLHYucHBzPUIuaHZjQy5wcHMsdi5odmNDPUIuaHZjQy5kYXRhO2Vsc2V7aWYoIUIuYXZjQyl0aHJvdyBuZXcgRXJyb3IoInVua25vd24gdmlkZW8gc3RzZCBlbnRyeSIpO3YuY29kZWM9Qi5hdmNDLmNvZGVjLHYuc3BzPUIuYXZjQy5zcHMsdi5wcHM9Qi5hdmNDLnBwc31pZih2LnByZXNlbnQ9ITAsdi5leHQ9e30sdi5leHQuc3Rzcz1udWxsPT09KGM9cy5tZGlhKXx8dm9pZCAwPT09Y3x8bnVsbD09PShsPWMubWluZil8fHZvaWQgMD09PWx8fG51bGw9PT0oZj1sLnN0YmwpfHx2b2lkIDA9PT1mP3ZvaWQgMDpmLnN0c3Msdi5leHQuY3R0cz1udWxsPT09KGQ9cy5tZGlhKXx8dm9pZCAwPT09ZHx8bnVsbD09PShoPWQubWluZil8fHZvaWQgMD09PWh8fG51bGw9PT0ocD1oLnN0YmwpfHx2b2lkIDA9PT1wP3ZvaWQgMDpwLmN0dHMsQiYmImVuY3YiPT09Qi50eXBlKXYuaXNWaWRlb0VuY3J5cHRpb249ITAsQi5kZWZhdWx0X0tJRD1udWxsPT09KG09Qi5zaW5mKXx8dm9pZCAwPT09bXx8bnVsbD09PShnPW0uc2NoaSl8fHZvaWQgMD09PWc/dm9pZCAwOmcudGVuYy5kZWZhdWx0X0tJRCxCLmRlZmF1bHRfSXNFbmNyeXB0ZWQ9bnVsbD09PShrPUIuc2luZil8fHZvaWQgMD09PWt8fG51bGw9PT0oYj1rLnNjaGkpfHx2b2lkIDA9PT1iP3ZvaWQgMDpiLnRlbmMuZGVmYXVsdF9Jc0VuY3J5cHRlZCxCLmRlZmF1bHRfSVZfc2l6ZT1udWxsPT09KF89Qi5zaW5mKXx8dm9pZCAwPT09X3x8bnVsbD09PSh3PV8uc2NoaSl8fHZvaWQgMD09PXc/dm9pZCAwOncudGVuYy5kZWZhdWx0X0lWX3NpemUsdi52aWRlb1NlbmM9cy5tZGlhLm1pbmYuc3RibC5zZW5jJiZzLm1kaWEubWluZi5zdGJsLnNlbmMuc2FtcGxlcyxCLmRhdGFfZm9ybWF0PW51bGw9PT0oeD1CLnNpbmYpfHx2b2lkIDA9PT14fHxudWxsPT09KEE9eC5mcm1hKXx8dm9pZCAwPT09QT92b2lkIDA6QS5kYXRhX2Zvcm1hdCx2LnVzZUVNRT1lLnVzZUVNRSx2LmtpZFZhbHVlPWUua2lkVmFsdWUsdi5wc3NoPWUucHNzaCx2LmVuY3Y9Qn1pZihvJiZyKXt2YXIgVCxDLFUsUCxJLHosTSxSLE8sTD1yLFY9bnVsbD09PShUPW8udGtoZCl8fHZvaWQgMD09PVQ/dm9pZCAwOlQudHJhY2tJZDtudWxsIT1WJiYoTC5pZD1vLnRraGQudHJhY2tJZCksTC50a2hkRHVyYXRpb249by50a2hkLmR1cmF0aW9uLEwubXZoZER1cnRpb249ZS5tdmhkLmR1cmF0aW9uLEwubXZoZFRpbWVjYWxlPWUubXZoZC50aW1lc2NhbGUsTC50aW1lc2NhbGU9TC5mb3JtYXRUaW1lc2NhbGU9by5tZGlhLm1kaGQudGltZXNjYWxlLEwuZHVyYXRpb249by5tZGlhLm1kaGQuZHVyYXRpb258fEwubXZoZER1cnRpb24vTC5tdmhkVGltZWNhbGUqTC50aW1lc2NhbGU7dmFyIEYsTixqLEcsSCxLLHEsVyxYPW8ubWRpYS5taW5mLnN0Ymwuc3RzZC5lbnRyaWVzWzBdO3N3aXRjaChMLnNhbXBsZVNpemU9WC5zYW1wbGVTaXplLEwuc2FtcGxlUmF0ZT1YLnNhbXBsZVJhdGUsTC5jaGFubmVsQ291bnQ9WC5jaGFubmVsQ291bnQsTC5wcmVzZW50PSEwLFgudHlwZSl7Y2FzZSJhbGF3IjpMLmNvZGVjVHlwZT1MLmNvZGVjPUQsTC5zYW1wbGVSYXRlPThlMzticmVhaztjYXNlInVsYXciOkwuY29kZWNUeXBlPUwuY29kZWM9RSxMLnNhbXBsZVJhdGU9OGUzO2JyZWFrO2RlZmF1bHQ6TC5zYW1wbGVEdXJhdGlvbj1zZS5nZXRGcmFtZUR1cmF0aW9uKEwuc2FtcGxlUmF0ZSxMLnRpbWVzY2FsZSksTC5zYW1wbGVSYXRlSW5kZXg9c2UuZ2V0UmF0ZUluZGV4QnlSYXRlKEwuc2FtcGxlUmF0ZSksTC5vYmplY3RUeXBlPShudWxsPT09KGE9WC5lc2RzKXx8dm9pZCAwPT09YT92b2lkIDA6YS5vYmplY3RUeXBlKXx8MixYLmVzZHMmJihMLmNvbmZpZz1BcnJheS5mcm9tKFguZXNkcy5jb25maWcpKSxMLmNvZGVjPShudWxsPT09KG49WC5lc2RzKXx8dm9pZCAwPT09bj92b2lkIDA6bi5jb2RlYyl8fCJtcDRhLjQwLjIifWlmKEwuc2FtcGxlRHVyYXRpb249c2UuZ2V0RnJhbWVEdXJhdGlvbihMLnNhbXBsZVJhdGUsTC50aW1lc2NhbGUpLEwub2JqZWN0VHlwZT0obnVsbD09PShDPVguZXNkcyl8fHZvaWQgMD09PUM/dm9pZCAwOkMub2JqZWN0VHlwZSl8fDIsWC5lc2RzJiYoWC5lc2RzLmNvbmZpZz9MLmNvbmZpZz1BcnJheS5mcm9tKFguZXNkcy5jb25maWcpOmNvbnNvbGUud2FybigiZXNkcyBjb25maWcgaXMgbnVsbCIpKSxMLmNvZGVjPShudWxsPT09KFU9WC5lc2RzKXx8dm9pZCAwPT09VT92b2lkIDA6VS5jb2RlYyl8fCJtcDRhLjQwLjIiLEwuc2FtcGxlUmF0ZUluZGV4PXNlLmdldFJhdGVJbmRleEJ5UmF0ZShMLnNhbXBsZVJhdGUpLEwuZXh0PXt9LEwuZXh0LnN0c3M9bnVsbD09PShQPW8ubWRpYSl8fHZvaWQgMD09PVB8fG51bGw9PT0oST1QLm1pbmYpfHx2b2lkIDA9PT1JfHxudWxsPT09KHo9SS5zdGJsKXx8dm9pZCAwPT09ej92b2lkIDA6ei5zdHNzLEwuZXh0LmN0dHM9bnVsbD09PShNPW8ubWRpYSl8fHZvaWQgMD09PU18fG51bGw9PT0oUj1NLm1pbmYpfHx2b2lkIDA9PT1SfHxudWxsPT09KE89Ui5zdGJsKXx8dm9pZCAwPT09Tz92b2lkIDA6Ty5jdHRzLEwucHJlc2VudD0hMCxYJiYiZW5jYSI9PT1YLnR5cGUpTC5pc0F1ZGlvRW5jcnlwdGlvbj0hMCxYLmRhdGFfZm9ybWF0PW51bGw9PT0oRj1YLnNpbmYpfHx2b2lkIDA9PT1GfHxudWxsPT09KE49Ri5mcm1hKXx8dm9pZCAwPT09Tj92b2lkIDA6Ti5kYXRhX2Zvcm1hdCxYLmRlZmF1bHRfS0lEPW51bGw9PT0oaj1YLnNpbmYpfHx2b2lkIDA9PT1qfHxudWxsPT09KEc9ai5zY2hpKXx8dm9pZCAwPT09Rz92b2lkIDA6Ry50ZW5jLmRlZmF1bHRfS0lELFguZGVmYXVsdF9Jc0VuY3J5cHRlZD1udWxsPT09KEg9WC5zaW5mKXx8dm9pZCAwPT09SHx8bnVsbD09PShLPUguc2NoaSl8fHZvaWQgMD09PUs/dm9pZCAwOksudGVuYy5kZWZhdWx0X0lzRW5jcnlwdGVkLFguZGVmYXVsdF9JVl9zaXplPW51bGw9PT0ocT1YLnNpbmYpfHx2b2lkIDA9PT1xfHxudWxsPT09KFc9cS5zY2hpKXx8dm9pZCAwPT09Vz92b2lkIDA6Vy50ZW5jLmRlZmF1bHRfSVZfc2l6ZSxMLmF1ZGlvU2VuYz1vLm1kaWEubWluZi5zdGJsLnNlbmMmJm8ubWRpYS5taW5mLnN0Ymwuc2VuYy5zYW1wbGVzLEwudXNlRU1FPWUudXNlRU1FLEwua2lkVmFsdWU9ZS5raWRWYWx1ZSxMLmVuY2E9WH1pZihyJiYoci5pc1ZpZGVvRW5jcnlwdGlvbj0hIXQmJnQuaXNWaWRlb0VuY3J5cHRpb24pLHQmJih0LmlzQXVkaW9FbmNyeXB0aW9uPSEhciYmci5pc0F1ZGlvRW5jcnlwdGlvbiksbnVsbCE9dCYmdC5lbmN2fHxudWxsIT1yJiZyLmVuY2Epe3ZhciBZLFosUT1udWxsPT10fHxudWxsPT09KFk9dC5lbmN2KXx8dm9pZCAwPT09WT92b2lkIDA6WS5kZWZhdWx0X0tJRCxKPW51bGw9PXJ8fG51bGw9PT0oWj1yLmVuY2EpfHx2b2lkIDA9PT1aP3ZvaWQgMDpaLmRlZmF1bHRfS0lELCQ9UXx8Sj8oUXx8Sikuam9pbigiIik6bnVsbDt0JiYodC5raWQ9JCksciYmKHIua2lkPSQpfXJldHVybiB0JiYodC5mbGFncz0zODQxKSxyJiYoci5mbGFncz0xNzkzKSx7dmlkZW9UcmFjazp0LGF1ZGlvVHJhY2s6cn19fX0se2tleToiZXZhbHVhdGVEZWZhdWx0RHVyYXRpb24iLHZhbHVlOmZ1bmN0aW9uKGUsdCxyKXt2YXIgYSxuPW51bGw9PXR8fG51bGw9PT0oYT10LnNhbXBsZXMpfHx2b2lkIDA9PT1hP3ZvaWQgMDphLmxlbmd0aDtyZXR1cm4gbj8xMDI0Km4vdC50aW1lc2NhbGUqZS50aW1lc2NhbGUvcjoxMDI0fX0se2tleToibW9vZlRvU2FtcGxlcyIsdmFsdWU6ZnVuY3Rpb24odCxyLGEpe3ZhciBuPXt9O3JldHVybiB0Lm1maGQmJihyJiYoci5zZXF1ZW5jZU51bWJlcj10Lm1maGQuc2VxdWVuY2VOdW1iZXIpLGEmJihhLnNlcXVlbmNlTnVtYmVyPXQubWZoZC5zZXF1ZW5jZU51bWJlcikpLHQudHJhZi5mb3JFYWNoKChmdW5jdGlvbih0KXt2YXIgaT10LnRmaGQscz10LnRmZHQsbz10LnRydW47aWYoaSYmbyl7cyYmKHImJnIuaWQ9PT1pLnRyYWNrSWQmJihyLmJhc2VNZWRpYURlY29kZVRpbWU9cy5iYXNlTWVkaWFEZWNvZGVUaW1lKSxhJiZhLmlkPT09aS50cmFja0lkJiYoYS5iYXNlTWVkaWFEZWNvZGVUaW1lPXMuYmFzZU1lZGlhRGVjb2RlVGltZSkpO3ZhciB1PWkuZGVmYXVsdFNhbXBsZVNpemV8fDAsYz1pLmRlZmF1bHRTYW1wbGVEdXJhdGlvbnx8ZS5ldmFsdWF0ZURlZmF1bHREdXJhdGlvbihyLGEsby5zYW1wbGVzLmxlbmd0aHx8by5zYW1wbGVDb3VudCksbD1vLmRhdGFPZmZzZXR8fDAsZj0wLGQ9LTE7aWYoIW8uc2FtcGxlcy5sZW5ndGgmJm8uc2FtcGxlQ291bnQpe25baS50cmFja0lkXT1bXTtmb3IodmFyIGg9MDtoPG8uc2FtcGxlQ291bnQ7aCsrKW5baS50cmFja0lkXS5wdXNoKHtvZmZzZXQ6bCxkdHM6ZixkdXJhdGlvbjpjLHNpemU6dX0pLGYrPWMsbCs9dX1lbHNlIG5baS50cmFja0lkXT1vLnNhbXBsZXMubWFwKChmdW5jdGlvbihlLHQpe3JldHVybihlPXtvZmZzZXQ6bCxkdHM6ZixwdHM6ZisoZS5jdHN8fDApLGR1cmF0aW9uOmUuZHVyYXRpb258fGMsc2l6ZTplLnNpemV8fHUsZ29wSWQ6ZCxrZXlmcmFtZTowPT09dHx8bnVsbCE9PWUuZmxhZ3MmJnZvaWQgMCE9PWUuZmxhZ3MmJig2NTUzNiZlLmZsYWdzKT4+PjAhPTY1NTM2fSkua2V5ZnJhbWUmJihkKyssZS5nb3BJZD1kKSxmKz1lLmR1cmF0aW9uLGwrPWUuc2l6ZSxlfSkpfX0pKSxufX0se2tleToibW9vdlRvU2FtcGxlcyIsdmFsdWU6ZnVuY3Rpb24oZSl7dmFyIHQ9ZS50cmFrO2lmKHQmJnQubGVuZ3RoKXt2YXIgcj10LmZpbmQoKGZ1bmN0aW9uKGUpe3ZhciB0LHI7cmV0dXJuInZpZGUiPT09KG51bGw9PT0odD1lLm1kaWEpfHx2b2lkIDA9PT10fHxudWxsPT09KHI9dC5oZGxyKXx8dm9pZCAwPT09cj92b2lkIDA6ci5oYW5kbGVyVHlwZSl9KSksYT10LmZpbmQoKGZ1bmN0aW9uKGUpe3ZhciB0LHI7cmV0dXJuInNvdW4iPT09KG51bGw9PT0odD1lLm1kaWEpfHx2b2lkIDA9PT10fHxudWxsPT09KHI9dC5oZGxyKXx8dm9pZCAwPT09cj92b2lkIDA6ci5oYW5kbGVyVHlwZSl9KSk7aWYocnx8YSl7dmFyIG4saTtpZihyKXt2YXIgcyxvLHU9bnVsbD09PShzPXIubWRpYSl8fHZvaWQgMD09PXN8fG51bGw9PT0obz1zLm1pbmYpfHx2b2lkIDA9PT1vP3ZvaWQgMDpvLnN0Ymw7aWYoIXUpcmV0dXJuO3ZhciBjPXUuc3R0cyxsPXUuc3RzYyxmPXUuc3RzeixkPXUuc3RjbyxoPXUuc3RzcyxwPXUuY3R0cztpZighKGMmJmwmJmYmJmQmJmgpKXJldHVybjtuPXZlKGMsbCxmLGQscCxoKX1pZihhKXt2YXIgdix5LG0sZz1udWxsPT09KHY9YS5tZGlhKXx8dm9pZCAwPT09dnx8bnVsbD09PSh5PXYubWluZil8fHZvaWQgMD09PXk/dm9pZCAwOnkuc3RibDtpZighZylyZXR1cm47dmFyIGs9bnVsbD09PShtPWEubWRpYS5tZGhkKXx8dm9pZCAwPT09bT92b2lkIDA6bS50aW1lc2NhbGUsYj1nLnN0dHMsXz1nLnN0c2Msdz1nLnN0c3oseD1nLnN0Y287aWYoIShrJiZiJiZfJiZ3JiZ4KSlyZXR1cm47aT12ZShiLF8sdyx4KX1yZXR1cm57dmlkZW9TYW1wbGVzOm4sYXVkaW9TYW1wbGVzOml9fX19fV0pLGV9KCk7ZnVuY3Rpb24gdmUoZSx0LHIsYSxuLGkpe3ZhciBzLG8sdSxjPVtdLGw9bnVsbD09bj92b2lkIDA6bi5lbnRyaWVzLGY9dC5lbnRyaWVzLGQ9YS5lbnRyaWVzLGg9ci5lbnRyeVNpemVzLHA9bnVsbD09aT92b2lkIDA6aS5lbnRyaWVzO3AmJihzPXt9LHAuZm9yRWFjaCgoZnVuY3Rpb24oZSl7c1tlLTFdPSEwfSkpKSxsJiYobz1bXSxsLmZvckVhY2goKGZ1bmN0aW9uKGUpe2Zvcih2YXIgdD1lLmNvdW50LHI9ZS5vZmZzZXQsYT0wO2E8dDthKyspby5wdXNoKHIpfSkpKTt2YXIgdj0tMSx5PTAsbT0wLGc9MCxrPTAsYj0wLF89ZlswXS5zYW1wbGVzUGVyQ2h1bmssdz1mWzFdP2ZbMV0uZmlyc3RDaHVuay0xOjEvMDtyZXR1cm4gZS5lbnRyaWVzLmZvckVhY2goKGZ1bmN0aW9uKGUpe2Zvcih2YXIgdD1lLmNvdW50LGE9ZS5kZWx0YSxuPTA7bjx0O24rKyl1PXtkdHM6eSxkdXJhdGlvbjphLHNpemU6aFttXXx8ci5zYW1wbGVTaXplLG9mZnNldDpkW2ddK2IsaW5kZXg6bX0scCYmKHUua2V5ZnJhbWU9c1ttXSx1LmtleWZyYW1lJiZ2KyssdS5nb3BJZD12KSxvJiZtPG8ubGVuZ3RoJiYodS5wdHM9dS5kdHMrb1ttXSksYy5wdXNoKHUpLHkrPWEsKyttPF8/Yis9dS5zaXplOihnKyssYj0wLGc+PXcmJihrKyssdz1mW2srMV0/ZltrKzFdLmZpcnN0Q2h1bmstMToxLzApLF8rPWZba10uc2FtcGxlc1BlckNodW5rKX0pKSxjfWZ1bmN0aW9uIHllKGUsdCl7cmV0dXJuIGUuZGF0YVJlZmVyZW5jZUluZGV4PUoodCw2KSxlLndpZHRoPUoodCwyNCksZS5oZWlnaHQ9Sih0LDI2KSxlLmhvcml6cmVzb2x1dGlvbj0kKHQsMjgpLGUudmVydHJlc29sdXRpb249JCh0LDMyKSxlLmZyYW1lQ291bnQ9Sih0LDQwKSxlLmRlcHRoPUoodCw3NCksNzh9ZnVuY3Rpb24gbWUoZSx0KXtyZXR1cm4gZS5kYXRhUmVmZXJlbmNlSW5kZXg9Sih0LDYpLGUuY2hhbm5lbENvdW50PUoodCwxNiksZS5zYW1wbGVTaXplPUoodCwxOCksZS5zYW1wbGVSYXRlPSQodCwyNCkvNjU1MzYsMjh9ZnVuY3Rpb24gZ2UoZSx0LHIpe2lmKGUpe2lmKGUuc2l6ZSE9PWUuZGF0YS5sZW5ndGgpdGhyb3cgbmV3IEVycm9yKCJib3ggIi5jb25jYXQoZS50eXBlLCIgc2l6ZSAhPT0gZGF0YS5sZW5ndGgiKSk7dmFyIGE9e3N0YXJ0OmUuc3RhcnQsc2l6ZTplLnNpemUsaGVhZGVyU2l6ZTplLmhlYWRlclNpemUsdHlwZTplLnR5cGV9O3JldHVybiB0JiYoYS52ZXJzaW9uPWUuZGF0YVtlLmhlYWRlclNpemVdLGEuZmxhZ3M9ZnVuY3Rpb24oZSl7dmFyIHQ9YXJndW1lbnRzLmxlbmd0aD4xJiZ2b2lkIDAhPT1hcmd1bWVudHNbMV0/YXJndW1lbnRzWzFdOjA7cmV0dXJuKGVbdF08PDE2KSsoZVt0KzFdPDw4KSsoZVt0KzJdfHwwKX0oZS5kYXRhLGUuaGVhZGVyU2l6ZSsxKSxhLmhlYWRlclNpemUrPTQpLHIoYSxlLmRhdGEuc3ViYXJyYXkoYS5oZWFkZXJTaXplKSxhLnN0YXJ0K2EuaGVhZGVyU2l6ZSksYX19dmFyIGtlPWZ1bmN0aW9uKGUsdCxyKXtmb3IodmFyIGE9U3RyaW5nKHIpLG49dD4+MCxpPU1hdGguY2VpbChuL2EubGVuZ3RoKSxzPVtdLG89U3RyaW5nKGUpO2ktLTspcy5wdXNoKGEpO3JldHVybiBzLmpvaW4oIiIpLnN1YnN0cmluZygwLG4tby5sZW5ndGgpK299LGJlPWZ1bmN0aW9uKCl7Zm9yKHZhciBlPVtdLHQ9YXJndW1lbnRzLmxlbmd0aCxyPW5ldyBBcnJheSh0KSxhPTA7YTx0O2ErKylyW2FdPWFyZ3VtZW50c1thXTtyZXR1cm4gci5mb3JFYWNoKChmdW5jdGlvbih0KXtlLnB1c2goa2UoTnVtYmVyKHQpLnRvU3RyaW5nKDE2KSwyLDApKX0pKSxlWzBdfTtmdW5jdGlvbiBfZShlKXtmb3IodmFyIHQ9MCxyPWFyZ3VtZW50cy5sZW5ndGgsYT1uZXcgQXJyYXkocj4xP3ItMTowKSxuPTE7bjxyO24rKylhW24tMV09YXJndW1lbnRzW25dO2EuZm9yRWFjaCgoZnVuY3Rpb24oZSl7dCs9ZS5sZW5ndGh9KSk7dmFyIGk9bmV3IGUodCkscz0wO3JldHVybiBhLmZvckVhY2goKGZ1bmN0aW9uKGUpe2kuc2V0KGUscykscys9ZS5sZW5ndGh9KSksaX12YXIgd2U9ZnVuY3Rpb24oKXtmdW5jdGlvbiBlKCl7cih0aGlzLGUpLHRoaXMuYnVmZmVyPW5ldyBVaW50OEFycmF5KDApfXJldHVybiBuKGUsW3trZXk6IndyaXRlIix2YWx1ZTpmdW5jdGlvbigpe2Zvcih2YXIgZT10aGlzLHQ9YXJndW1lbnRzLmxlbmd0aCxyPW5ldyBBcnJheSh0KSxhPTA7YTx0O2ErKylyW2FdPWFyZ3VtZW50c1thXTtyLmZvckVhY2goKGZ1bmN0aW9uKHQpe3Q/ZS5idWZmZXI9X2UoVWludDhBcnJheSxlLmJ1ZmZlcix0KTp3aW5kb3cuY29uc29sZS53YXJuKHQpfSkpfX1dLFt7a2V5OiJ3cml0ZVVpbnQxNiIsdmFsdWU6ZnVuY3Rpb24oZSl7cmV0dXJuIG5ldyBVaW50OEFycmF5KFtlPj44JjI1NSwyNTUmZV0pfX0se2tleToid3JpdGVVaW50MzIiLHZhbHVlOmZ1bmN0aW9uKGUpe3JldHVybiBuZXcgVWludDhBcnJheShbZT4+MjQsZT4+MTYmMjU1LGU+PjgmMjU1LDI1NSZlXSl9fV0pLGV9KCkseGU9TWF0aC5wb3coMiwzMiktMSxTZT1mdW5jdGlvbigpe2Z1bmN0aW9uIGUoKXtyKHRoaXMsZSl9cmV0dXJuIG4oZSxudWxsLFt7a2V5OiJib3giLHZhbHVlOmZ1bmN0aW9uKGUpe2Zvcih2YXIgdD1hcmd1bWVudHMubGVuZ3RoLHI9bmV3IEFycmF5KHQ+MT90LTE6MCksYT0xO2E8dDthKyspclthLTFdPWFyZ3VtZW50c1thXTt2YXIgbj04KyhyPXIuZmlsdGVyKEJvb2xlYW4pKS5yZWR1Y2UoKGZ1bmN0aW9uKGUsdCl7cmV0dXJuIGUrdC5ieXRlTGVuZ3RofSksMCksaT1uZXcgVWludDhBcnJheShuKTtpWzBdPW4+PjI0JjI1NSxpWzFdPW4+PjE2JjI1NSxpWzJdPW4+PjgmMjU1LGlbM109MjU1Jm4saS5zZXQoZSw0KTt2YXIgcz04O3JldHVybiByLmZvckVhY2goKGZ1bmN0aW9uKGUpe2kuc2V0KGUscykscys9ZS5ieXRlTGVuZ3RofSkpLGl9fSx7a2V5OiJmdHlwIix2YWx1ZTpmdW5jdGlvbih0KXtyZXR1cm4gdC5maW5kKChmdW5jdGlvbihlKXtyZXR1cm4gZS50eXBlPT09YiYmZS5jb2RlY1R5cGU9PT1TfSkpP2UuRlRZUEhFVjE6ZS5GVFlQQVZDMX19LHtrZXk6ImluaXRTZWdtZW50Iix2YWx1ZTpmdW5jdGlvbih0KXtyZXR1cm4gWihlLmZ0eXAodCksZS5tb292KHQpKX19LHtrZXk6InBzc2giLHZhbHVlOmZ1bmN0aW9uKHQpe3ZhciByPW5ldyBVaW50OEFycmF5KFsxLDAsMCwwXS5jb25jYXQoWzE2LDExOSwyMzksMjM2LDE5MiwxNzgsNzcsMiwxNzIsMjI3LDYwLDMwLDgyLDIyNiwyNTEsNzVdLFswLDAsMCwxXSxhZSh0LmtpZCksWzAsMCwwLDBdKSk7cmV0dXJuIGUuYm94KGUudHlwZXMucHNzaCxyKX19LHtrZXk6Im1vb3YiLHZhbHVlOmZ1bmN0aW9uKHQpe2lmKHRbMF0udXNlRU1FJiYodFswXS5lbmN2fHx0WzBdLmVuY2EpKXt0WzBdLnBzc2h8fCh0WzBdLnBzc2g9e2tpZDp0WzBdLmtpZH0pO3ZhciByPXRoaXMucHNzaCh0WzBdLnBzc2gpO3JldHVybiBlLmJveC5hcHBseShlLFtlLnR5cGVzLm1vb3YsZS5tdmhkKHRbMF0ubXZoZER1cnRpb258fHRbMF0uZHVyYXRpb24sdFswXS5tdmhkVGltZWNhbGV8fHRbMF0udGltZXNjYWxlKSxlLm12ZXgodCldLmNvbmNhdCh5KHQubWFwKChmdW5jdGlvbih0KXtyZXR1cm4gZS50cmFrKHQpfSkpKSxbcl0pKX1yZXR1cm4gZS5ib3guYXBwbHkoZSxbZS50eXBlcy5tb292LGUubXZoZCh0WzBdLm12aGREdXJ0aW9ufHx0WzBdLmR1cmF0aW9uLHRbMF0ubXZoZFRpbWVjYWxlfHx0WzBdLnRpbWVzY2FsZSldLmNvbmNhdCh5KHQubWFwKChmdW5jdGlvbih0KXtyZXR1cm4gZS50cmFrKHQpfSkpKSxbZS5tdmV4KHQpXSkpfX0se2tleToibXZoZCIsdmFsdWU6ZnVuY3Rpb24odCl7dmFyIHI9YXJndW1lbnRzLmxlbmd0aD4xJiZ2b2lkIDAhPT1hcmd1bWVudHNbMV0/YXJndW1lbnRzWzFdOjllNCxhPWUuYm94KGUudHlwZXMubXZoZCxuZXcgVWludDhBcnJheShbMCwwLDAsMCwwLDAsMCwwLDAsMCwwLDAscj4+MjQmMjU1LHI+PjE2JjI1NSxyPj44JjI1NSwyNTUmcix0Pj4yNCYyNTUsdD4+MTYmMjU1LHQ+PjgmMjU1LDI1NSZ0LDAsMSwwLDAsMSwwLDAsMCwwLDAsMCwwLDAsMCwwLDAsMCwxLDAsMCwwLDAsMCwwLDAsMCwwLDAsMCwwLDAsMCwwLDEsMCwwLDAsMCwwLDAsMCwwLDAsMCwwLDAsMCwwLDY0LDAsMCwwLDAsMCwwLDAsMCwwLDAsMCwwLDAsMCwwLDAsMCwwLDAsMCwwLDAsMCwwLDAsMCwwLDI1NSwyNTUsMjU1LDI1NV0pKTtyZXR1cm4gYX19LHtrZXk6InRyYWsiLHZhbHVlOmZ1bmN0aW9uKHQpe3JldHVybiBlLmJveChlLnR5cGVzLnRyYWssZS50a2hkKHQuaWQsdC50a2hkRHVyYXRpb258fDAsdC53aWR0aCx0LmhlaWdodCksZS5tZGlhKHQpKX19LHtrZXk6InRraGQiLHZhbHVlOmZ1bmN0aW9uKHQscil7dmFyIGE9YXJndW1lbnRzLmxlbmd0aD4yJiZ2b2lkIDAhPT1hcmd1bWVudHNbMl0/YXJndW1lbnRzWzJdOjAsbj1hcmd1bWVudHMubGVuZ3RoPjMmJnZvaWQgMCE9PWFyZ3VtZW50c1szXT9hcmd1bWVudHNbM106MCxpPWUuYm94KGUudHlwZXMudGtoZCxuZXcgVWludDhBcnJheShbMCwwLDAsNywwLDAsMCwwLDAsMCwwLDAsdD4+MjQmMjU1LHQ+PjE2JjI1NSx0Pj44JjI1NSwyNTUmdCwwLDAsMCwwLHI+PjI0JjI1NSxyPj4xNiYyNTUscj4+OCYyNTUsMjU1JnIsMCwwLDAsMCwwLDAsMCwwLDAsMCwwLDAsMSwwLDAsMCwwLDEsMCwwLDAsMCwwLDAsMCwwLDAsMCwwLDAsMCwwLDAsMSwwLDAsMCwwLDAsMCwwLDAsMCwwLDAsMCwwLDAsNjQsMCwwLDAsYT4+OCYyNTUsMjU1JmEsMCwwLG4+PjgmMjU1LDI1NSZuLDAsMF0pKTtyZXR1cm4gaX19LHtrZXk6Im1kaWEiLHZhbHVlOmZ1bmN0aW9uKHQpe3JldHVybiBlLmJveChlLnR5cGVzLm1kaWEsZS5tZGhkKHQuZHVyYXRpb24sdC50aW1lc2NhbGUpLGUuaGRscih0LnR5cGUpLGUubWluZih0KSl9fSx7a2V5OiJtZGhkIix2YWx1ZTpmdW5jdGlvbih0KXt2YXIgcj1hcmd1bWVudHMubGVuZ3RoPjEmJnZvaWQgMCE9PWFyZ3VtZW50c1sxXT9hcmd1bWVudHNbMV06OWU0LGE9ZS5ib3goZS50eXBlcy5tZGhkLG5ldyBVaW50OEFycmF5KFswLDAsMCwwLDAsMCwwLDAsMCwwLDAsMCxyPj4yNCYyNTUscj4+MTYmMjU1LHI+PjgmMjU1LDI1NSZyLHQ+PjI0JjI1NSx0Pj4xNiYyNTUsdD4+OCYyNTUsMjU1JnQsODUsMTk2LDAsMF0pKTtyZXR1cm4gYX19LHtrZXk6ImhkbHIiLHZhbHVlOmZ1bmN0aW9uKHQpe3JldHVybiBlLmJveChlLnR5cGVzLmhkbHIsZS5IRExSX1RZUEVTW3RdKX19LHtrZXk6Im1pbmYiLHZhbHVlOmZ1bmN0aW9uKHQpe3JldHVybiBlLmJveChlLnR5cGVzLm1pbmYsdC50eXBlPT09Yj9lLlZNSEQ6ZS5TTUhELGUuRElORixlLnN0YmwodCkpfX0se2tleToic3RibCIsdmFsdWU6ZnVuY3Rpb24odCl7dmFyIHI9W107cmV0dXJuIHQmJnQuZXh0JiZ0LmV4dC5zdHNzJiZyLnB1c2goZS5zdHNzKHQuZXh0LnN0c3MuZW50cmllcykpLGUuYm94KGUudHlwZXMuc3RibCxlLnN0c2QodCksZS5TVFRTLHJbMF0sZS5TVFNDLGUuU1RTWixlLlNUQ08pfX0se2tleToic3RzZCIsdmFsdWU6ZnVuY3Rpb24odCl7dmFyIHI7cmV0dXJuIHI9ImF1ZGlvIj09PXQudHlwZT90LnVzZUVNRSYmdC5lbmNhP2UuZW5jYSh0KTplLm1wNGEodCk6dC51c2VFTUUmJnQuZW5jdj9lLmVuY3YodCk6ZS5hdmMxaGV2MSh0KSxlLmJveChlLnR5cGVzLnN0c2QsbmV3IFVpbnQ4QXJyYXkoWzAsMCwwLDAsMCwwLDAsMV0pLHIpfX0se2tleToiZW5jYSIsdmFsdWU6ZnVuY3Rpb24odCl7dmFyIHI9dC5lbmNhLmNoYW5uZWxDb3VudCxhPXQuZW5jYS5zYW1wbGVSYXRlLG49bmV3IFVpbnQ4QXJyYXkoWzAsMCwwLDAsMCwwLDAsMSwwLDAsMCwwLDAsMCwwLDAsMCxyLDAsMTYsMCwwLDAsMCxhPj44JjI1NSwyNTUmYSwwLDBdKSxpPWUuZXNkcyh0LmNvbmZpZykscz1lLnNpbmYodC5lbmNhKTtyZXR1cm4gZS5ib3goZS50eXBlcy5lbmNhLG4saSxzKX19LHtrZXk6ImVuY3YiLHZhbHVlOmZ1bmN0aW9uKHQpe3ZhciByLGEsbj10LnNwcy5sZW5ndGg+MD90LnNwc1swXTpbXSxpPXQucHBzLmxlbmd0aD4wP3QucHBzWzBdOltdLHM9dC53aWR0aCxvPXQuaGVpZ2h0LHU9dC5zYXJSYXRpb1swXSxjPXQuc2FyUmF0aW9bMV0sbD1uZXcgVWludDhBcnJheShbMCwwLDAsMCwwLDAsMCwxLDAsMCwwLDAsMCwwLDAsMCwwLDAsMCwwLDAsMCwwLDAscz4+OCYyNTUsMjU1JnMsbz4+OCYyNTUsMjU1Jm8sMCw3MiwwLDAsMCw3MiwwLDAsMCwwLDAsMCwwLDEsMTgsMTAwLDk3LDEwNSwxMDgsMTIxLDEwOSwxMTEsMTE2LDEwNSwxMTEsMTEwLDQ3LDEwNCwxMDgsMTE1LDQ2LDEwNiwxMTUsMCwwLDAsMCwwLDAsMCwwLDAsMCwwLDAsMCwwLDI0LDE3LDE3XSksZj1uZXcgVWludDhBcnJheSgocj0oYT1bMSxuWzFdLG5bMl0sblszXSwyNTUsMjI1LG4ubGVuZ3RoPj4+OCYyNTUsMjU1Jm4ubGVuZ3RoXSkuY29uY2F0LmFwcGx5KGEseShuKSkuY29uY2F0KFsxLGkubGVuZ3RoPj4+OCYyNTUsMjU1JmkubGVuZ3RoXSkpLmNvbmNhdC5hcHBseShyLHkoaSkpKSxkPW5ldyBVaW50OEFycmF5KFswLDAsODgsNTcsMCwxNSwyMDAsMTkyLDAsNCw4Niw3Ml0pLGg9ZS5zaW5mKHQuZW5jdikscD1uZXcgVWludDhBcnJheShbdT4+MjQsdT4+MTYmMjU1LHU+PjgmMjU1LDI1NSZ1LGM+PjI0LGM+PjE2JjI1NSxjPj44JjI1NSwyNTUmY10pO3JldHVybiBlLmJveChlLnR5cGVzLmVuY3YsbCxlLmJveChlLnR5cGVzLmF2Y0MsZiksZS5ib3goZS50eXBlcy5idHJ0LGQpLGgsZS5ib3goZS50eXBlcy5wYXNwLHApKX19LHtrZXk6InNjaGkiLHZhbHVlOmZ1bmN0aW9uKHQpe3ZhciByPW5ldyBVaW50OEFycmF5KFtdKSxhPWUudGVuYyh0KTtyZXR1cm4gZS5ib3goZS50eXBlcy5zY2hpLHIsYSl9fSx7a2V5OiJ0ZW5jIix2YWx1ZTpmdW5jdGlvbih0KXt2YXIgcj1uZXcgVWludDhBcnJheShbMCwwLDAsMCwwLDAsMjU1JnQuZGVmYXVsdF9Jc0VuY3J5cHRlZCwyNTUmdC5kZWZhdWx0X0lWX3NpemVdLmNvbmNhdChhZSh0LmRlZmF1bHRfS0lEKSkpO3JldHVybiBlLmJveChlLnR5cGVzLnRlbmMscil9fSx7a2V5OiJzaW5mIix2YWx1ZTpmdW5jdGlvbih0KXt2YXIgcj1uZXcgVWludDhBcnJheShbXSksYT1uZXcgVWludDhBcnJheShbdC5kYXRhX2Zvcm1hdC5jaGFyQ29kZUF0KDApLHQuZGF0YV9mb3JtYXQuY2hhckNvZGVBdCgxKSx0LmRhdGFfZm9ybWF0LmNoYXJDb2RlQXQoMiksdC5kYXRhX2Zvcm1hdC5jaGFyQ29kZUF0KDMpXSksbj1uZXcgVWludDhBcnJheShbMCwwLDAsMCw5OSwxMDEsMTEwLDk5LDAsMSwwLDBdKSxpPWUuc2NoaSh0KTtyZXR1cm4gZS5ib3goZS50eXBlcy5zaW5mLHIsZS5ib3goZS50eXBlcy5mcm1hLGEpLGUuYm94KGUudHlwZXMuc2NobSxuKSxpKX19LHtrZXk6ImF2YzFoZXYxIix2YWx1ZTpmdW5jdGlvbih0KXt2YXIgcj10LmNvZGVjVHlwZT09PVMsYT1yP2UudHlwZXMuaHZjMTplLnR5cGVzLmF2YzEsbj1yP2UuaHZjQyh0KTplLmF2Y0ModCksaT1bbmV3IFVpbnQ4QXJyYXkoWzAsMCwwLDAsMCwwLDAsMSwwLDAsMCwwLDAsMCwwLDAsMCwwLDAsMCwwLDAsMCwwLHQud2lkdGg+PjgmMjU1LDI1NSZ0LndpZHRoLHQuaGVpZ2h0Pj44JjI1NSwyNTUmdC5oZWlnaHQsMCw3MiwwLDAsMCw3MiwwLDAsMCwwLDAsMCwwLDEsMCwwLDAsMCwwLDAsMCwwLDAsMCwwLDAsMCwwLDAsMCwwLDAsMCwwLDAsMCwwLDAsMCwwLDAsMCwwLDAsMCwwLDAsMjQsMTcsMTddKSxuXTtyZXR1cm4gcj9pLnB1c2goZS5ib3goZS50eXBlcy5maWVsLG5ldyBVaW50OEFycmF5KFsxLDBdKSkpOnQuc2FyUmF0aW8mJnQuc2FyUmF0aW8ubGVuZ3RoPjEmJmkucHVzaChlLnBhc3AodC5zYXJSYXRpbykpLGUuYm94LmFwcGx5KGUsW2FdLmNvbmNhdChpKSl9fSx7a2V5OiJhdmNDIix2YWx1ZTpmdW5jdGlvbih0KXt2YXIgcixhLG4saT1bXSxzPVtdO3JldHVybiB0LnNwcy5mb3JFYWNoKChmdW5jdGlvbihlKXtuPWUuYnl0ZUxlbmd0aCxpLnB1c2gobj4+PjgmMjU1KSxpLnB1c2goMjU1Jm4pLGkucHVzaC5hcHBseShpLHkoZSkpfSkpLHQucHBzLmZvckVhY2goKGZ1bmN0aW9uKGUpe249ZS5ieXRlTGVuZ3RoLHMucHVzaChuPj4+OCYyNTUpLHMucHVzaCgyNTUmbikscy5wdXNoLmFwcGx5KHMseShlKSl9KSksZS5ib3goZS50eXBlcy5hdmNDLG5ldyBVaW50OEFycmF5KChyPShhPVsxLGlbM10saVs0XSxpWzVdLDI1NSwyMjR8dC5zcHMubGVuZ3RoXSkuY29uY2F0LmFwcGx5KGEsaSkuY29uY2F0KFt0LnBwcy5sZW5ndGhdKSkuY29uY2F0LmFwcGx5KHIscykpKX19LHtrZXk6Imh2Y0MiLHZhbHVlOmZ1bmN0aW9uKHQpe3ZhciByPXQuaHZjQztpZihyIGluc3RhbmNlb2YgQXJyYXlCdWZmZXJ8fHIgaW5zdGFuY2VvZiBVaW50OEFycmF5KXJldHVybiByO3ZhciBhLG49dC52cHMsaT10LnNwcyxzPXQucHBzO2lmKHIpe3ZhciBvPXIuZ2VuZXJhbFByb2ZpbGVDb21wYXRpYmlsaXR5RmxhZ3MsdT1yLmdlbmVyYWxDb25zdHJhaW50SW5kaWNhdG9yRmxhZ3MsYz0obi5sZW5ndGgmJjEpKyhpLmxlbmd0aCYmMSkrKHMubGVuZ3RoJiYxKTthPVsxLHIuZ2VuZXJhbFByb2ZpbGVTcGFjZTw8NnxyLmdlbmVyYWxUaWVyRmxhZzw8NXxyLmdlbmVyYWxQcm9maWxlSWRjLG8+Pj4yNCxvPj4+MTYsbz4+Pjgsbyx1WzBdLHVbMV0sdVsyXSx1WzNdLHVbNF0sdVs1XSxyLmdlbmVyYWxMZXZlbElkYywyNDAsMCwyNTIsMjUyfHIuY2hyb21hRm9ybWF0SWRjLDI0OHxyLmJpdERlcHRoTHVtYU1pbnVzOCwyNDh8ci5iaXREZXB0aENocm9tYU1pbnVzOCwwLDAsci5udW1UZW1wb3JhbExheWVyczw8M3xyLnRlbXBvcmFsSWROZXN0ZWQ8PDJ8MyxjXTt2YXIgbD1mdW5jdGlvbihlKXt2YXIgdDthLnB1c2goZS5sZW5ndGg+PjgsZS5sZW5ndGgpLCh0PWEpLnB1c2guYXBwbHkodCx5KGUpKX07bi5sZW5ndGgmJihhLnB1c2goMTYwLDAsbi5sZW5ndGgpLG4uZm9yRWFjaChsKSksaS5sZW5ndGgmJihhLnB1c2goMTYxLDAsaS5sZW5ndGgpLGkuZm9yRWFjaChsKSkscy5sZW5ndGgmJihhLnB1c2goMTYyLDAscy5sZW5ndGgpLHMuZm9yRWFjaChsKSl9ZWxzZSBhPVsxLDEsOTYsMCwwLDAsMTQ0LDAsMCwwLDAsMCw5MywyNDAsMCwyNTIsMjUzLDI0OCwyNDgsMCwwLDE1LDMsMTYwLDAsMSwwLDI0LDY0LDEsMTIsMSwyNTUsMjU1LDEsOTYsMCwwLDMsMCwxNDQsMCwwLDMsMCwwLDMsMCw5MywxNTMsMTUyLDksMTYxLDAsMSwwLDQ1LDY2LDEsMSwxLDk2LDAsMCwzLDAsMTQ0LDAsMCwzLDAsMCwzLDAsOTMsMTYwLDIsMTI4LDEyOCw0NSwyMiw4OSwxNTMsMTY0LDE0Nyw0MywxNTQsMTI4LDEyOCwxMjgsMTMwLDAsMCwzLDAsMiwwLDAsMywwLDUwLDE2LDE2MiwwLDEsMCw3LDY4LDEsMTkzLDExNCwxODAsOTgsNjRdO3JldHVybiBlLmJveChlLnR5cGVzLmh2Y0MsbmV3IFVpbnQ4QXJyYXkoYSkpfX0se2tleToicGFzcCIsdmFsdWU6ZnVuY3Rpb24odCl7dmFyIHI9dih0LDIpLGE9clswXSxuPXJbMV07cmV0dXJuIGUuYm94KGUudHlwZXMucGFzcCxuZXcgVWludDhBcnJheShbYT4+MjQsYT4+MTYmMjU1LGE+PjgmMjU1LDI1NSZhLG4+PjI0LG4+PjE2JjI1NSxuPj44JjI1NSwyNTUmbl0pKX19LHtrZXk6Im1wNGEiLHZhbHVlOmZ1bmN0aW9uKHQpe3JldHVybiBlLmJveChlLnR5cGVzLm1wNGEsbmV3IFVpbnQ4QXJyYXkoWzAsMCwwLDAsMCwwLDAsMSwwLDAsMCwwLDAsMCwwLDAsMCx0LmNoYW5uZWxDb3VudCwwLDE2LDAsMCwwLDAsdC5zYW1wbGVSYXRlPj44JjI1NSwyNTUmdC5zYW1wbGVSYXRlLDAsMF0pLHQuY29uZmlnLmxlbmd0aD9lLmVzZHModC5jb25maWcpOnZvaWQgMCl9fSx7a2V5OiJlc2RzIix2YWx1ZTpmdW5jdGlvbih0KXt2YXIgcj10Lmxlbmd0aDtyZXR1cm4gZS5ib3goZS50eXBlcy5lc2RzLG5ldyBVaW50OEFycmF5KFswLDAsMCwwLDMsMjMrciwwLDAsMCw0LDE1K3IsNjQsMjEsMCw2LDAsMCwwLDIxOCwxOTIsMCwwLDIxOCwxOTIsNV0uY29uY2F0KFtyXSkuY29uY2F0KHQpLmNvbmNhdChbNiwxLDJdKSkpfX0se2tleToibXZleCIsdmFsdWU6ZnVuY3Rpb24odCl7cmV0dXJuIGUuYm94LmFwcGx5KGUsW2UudHlwZXMubXZleF0uY29uY2F0KHkodC5tYXAoKGZ1bmN0aW9uKHQpe3JldHVybiBlLnRyZXgodC5pZCl9KSkpKSl9fSx7a2V5OiJ0cmV4Iix2YWx1ZTpmdW5jdGlvbih0KXtyZXR1cm4gZS5ib3goZS50eXBlcy50cmV4LG5ldyBVaW50OEFycmF5KFswLDAsMCwwLHQ+PjI0LHQ+PjE2JjI1NSx0Pj44JjI1NSwyNTUmdCwwLDAsMCwxLDAsMCwwLDAsMCwwLDAsMCwwLDEsMCwxXSkpfX0se2tleToidHJleDEiLHZhbHVlOmZ1bmN0aW9uKHQpe3JldHVybiBlLmJveChlLnR5cGVzLnRyZXgsbmV3IFVpbnQ4QXJyYXkoWzAsMCwwLDAsdD4+MjQsdD4+MTYmMjU1LHQ+PjgmMjU1LDI1NSZ0LDAsMCwwLDEsMCwwLDIsMCwwLDAsMCwwLDAsMSwwLDBdKSl9fSx7a2V5OiJ0cmV4MiIsdmFsdWU6ZnVuY3Rpb24odCl7cmV0dXJuIGUuYm94KGUudHlwZXMudHJleCxuZXcgVWludDhBcnJheShbMCwwLDAsMCx0Pj4yNCx0Pj4xNiYyNTUsdD4+OCYyNTUsMjU1JnQsMCwwLDAsMSwwLDAsNCwwLDAsMCwwLDAsMiwwLDAsMF0pKX19LHtrZXk6Im1vb2YiLHZhbHVlOmZ1bmN0aW9uKHQpe3JldHVybiBlLmJveC5hcHBseShlLFtlLnR5cGVzLm1vb2YsZS5tZmhkKHRbMF0uc2FtcGxlcz90WzBdLnNhbXBsZXNbMF0uZ29wSWQ6MCldLmNvbmNhdCh5KHQubWFwKChmdW5jdGlvbih0KXtyZXR1cm4gZS50cmFmKHQpfSkpKSkpfX0se2tleToibWZoZCIsdmFsdWU6ZnVuY3Rpb24odCl7cmV0dXJuIGUuYm94KGUudHlwZXMubWZoZCxuZXcgVWludDhBcnJheShbMCwwLDAsMCx0Pj4yNCx0Pj4xNiYyNTUsdD4+OCYyNTUsMjU1JnRdKSl9fSx7a2V5OiJ0cmFmIix2YWx1ZTpmdW5jdGlvbih0KXt2YXIgcj1lLnRmaGQodC5pZCksYT1lLnRmZHQodCx0LmJhc2VNZWRpYURlY29kZVRpbWUpLG49MDtpZih0LmlzVmlkZW8mJnQudmlkZW9TZW5jJiZ0LnZpZGVvU2VuYy5mb3JFYWNoKChmdW5jdGlvbihlKXtuKz04LGUuc3Vic2FtcGxlcyYmZS5zdWJzYW1wbGVzLmxlbmd0aCYmKG4rPTIsbis9NiplLnN1YnNhbXBsZXMubGVuZ3RoKX0pKSx0LnZpZGVvU2VuY0xlbmd0aD1uLHQudXNlRU1FJiYodC5pc1ZpZGVvRW5jcnlwdGlvbnx8dC5pc0F1ZGlvRW5jcnlwdGlvbikpe2lmKHQuaXNWaWRlb0VuY3J5cHRpb24pe2lmKHQuaXNWaWRlbyl7dmFyIGk9ZS5zYWl6KHQpLHM9ZS5zYWlvKHQpLG89ZS50cnVuMSh0KSx1PWUuc2VuYyh0KTtyZXR1cm4gZS5ib3goZS50eXBlcy50cmFmLHIsYSxpLHMsbyx1KX1pZih0LmlzQXVkaW9FbmNyeXB0aW9uKXt2YXIgYz1lLnNiZ3AoKSxsPWUuc2Fpeih0KSxmPWUuc2Fpbyh0KSxkPWUuc2VuYyh0KSxoPWUudHJ1bjEodCk7cmV0dXJuIGUuYm94KGUudHlwZXMudHJhZixyLGEsYyxsLGYsZCxoKX12YXIgcD1lLnNiZ3AoKSx2PWUudHJ1bjEodCk7cmV0dXJuIGUuYm94KGUudHlwZXMudHJhZixyLGEscCx2KX1pZih0LmlzVmlkZW8pe3ZhciB5PWUudHJ1bjEodCk7cmV0dXJuIGUuYm94KGUudHlwZXMudHJhZixyLGEseSl9dmFyIG09ZS5zYmdwKCksZz1lLnNhaXoodCksaz1lLnNhaW8odCksYj1lLnNlbmModCksXz1lLnRydW4xKHQpO3JldHVybiBlLmJveChlLnR5cGVzLnRyYWYscixhLG0sZyxrLGIsXyl9dmFyIHc9ZS5zZHRwKHQpO3JldHVybiBlLmJveChlLnR5cGVzLnRyYWYscixhLHcsZS50cnVuKHQuc2FtcGxlcyx3LmJ5dGVMZW5ndGgrNzYpKX19LHtrZXk6InNkdHAiLHZhbHVlOmZ1bmN0aW9uKHQpe3ZhciByPW5ldyB3ZTtyZXR1cm4gdC5zYW1wbGVzLmZvckVhY2goKGZ1bmN0aW9uKGUpe3Iud3JpdGUobmV3IFVpbnQ4QXJyYXkodC5pc1ZpZGVvP1tlLmtleWZyYW1lPzMyOjE2XTpbMTZdKSl9KSksZS5ib3goZS50eXBlcy5zZHRwLHRoaXMuZXh0ZW5zaW9uKDAsMCksci5idWZmZXIpfX0se2tleToidHJ1bjEiLHZhbHVlOmZ1bmN0aW9uKHQpe3ZhciByPW5ldyB3ZSxhPXdlLndyaXRlVWludDMyKHQuc2FtcGxlcy5sZW5ndGgpLG49bnVsbDtpZih0LmlzVmlkZW8pe3ZhciBpPXQudmlkZW9TZW5jTGVuZ3RoO249d2Uud3JpdGVVaW50MzIoMTYqdC5zYW1wbGVzLmxlbmd0aCtpKzE0OSksIXQuaXNWaWRlb0VuY3J5cHRpb24mJnQuaXNBdWRpb0VuY3J5cHRpb24mJihuPXdlLndyaXRlVWludDMyKDE2KnQuc2FtcGxlcy5sZW5ndGgrOTIpKX1lbHNle3ZhciBzPTEyKnQuc2FtcGxlcy5sZW5ndGgrMTI0O3QuaXNBdWRpb0VuY3J5cHRpb24mJihzPTEyKnQuc2FtcGxlcy5sZW5ndGgrOCp0LmF1ZGlvU2VuYy5sZW5ndGgrMTc3KSxuPXdlLndyaXRlVWludDMyKHMpfXJldHVybiB0LnNhbXBsZXMuZm9yRWFjaCgoZnVuY3Rpb24oZSl7ci53cml0ZSh3ZS53cml0ZVVpbnQzMihlLmR1cmF0aW9uKSksci53cml0ZSh3ZS53cml0ZVVpbnQzMihlLnNpemUpKSxyLndyaXRlKHdlLndyaXRlVWludDMyKGUua2V5ZnJhbWU/MzM1NTQ0MzI6NjU1MzYpKSx0LmlzVmlkZW8mJnIud3JpdGUod2Uud3JpdGVVaW50MzIoZS5jdHM/ZS5jdHM6MCkpfSkpLGUuYm94KGUudHlwZXMudHJ1bix0aGlzLmV4dGVuc2lvbigwLHQuZmxhZ3MpLGEsbixyLmJ1ZmZlcil9fSx7a2V5OiJzZW5jIix2YWx1ZTpmdW5jdGlvbih0KXt2YXIgcj1uZXcgd2UsYT10LnNhbXBsZXMubGVuZ3RoLG49dC5pc1ZpZGVvPzE2OjgsaT10LmlzVmlkZW8/MjowLHM9W10sbz0wO3JldHVybiB0LmlzVmlkZW8/KHM9dC52aWRlb1NlbmMsbz10LnZpZGVvU2VuY0xlbmd0aCk6cz10LmF1ZGlvU2VuYyxvPW98fG4qYSxyLndyaXRlKHdlLndyaXRlVWludDMyKDE2K28pLGUudHlwZXMuc2VuYyx0aGlzLmV4dGVuc2lvbigwLGkpKSxyLndyaXRlKHdlLndyaXRlVWludDMyKGEpKSxzLmZvckVhY2goKGZ1bmN0aW9uKGUpe2Zvcih2YXIgdD0wO3Q8ZS5Jbml0aWFsaXphdGlvblZlY3Rvci5sZW5ndGg7dCsrKXIud3JpdGUobmV3IFVpbnQ4QXJyYXkoW2UuSW5pdGlhbGl6YXRpb25WZWN0b3JbdF1dKSk7ZS5zdWJzYW1wbGVzJiZlLnN1YnNhbXBsZXMubGVuZ3RoJiYoci53cml0ZSh3ZS53cml0ZVVpbnQxNihlLnN1YnNhbXBsZXMubGVuZ3RoKSksZS5zdWJzYW1wbGVzLmZvckVhY2goKGZ1bmN0aW9uKGUpe3Iud3JpdGUod2Uud3JpdGVVaW50MTYoZS5CeXRlc09mQ2xlYXJEYXRhKSksci53cml0ZSh3ZS53cml0ZVVpbnQzMihlLkJ5dGVzT2ZQcm90ZWN0ZWREYXRhKSl9KSkpfSkpLHIuYnVmZmVyfX0se2tleToic2FpbyIsdmFsdWU6ZnVuY3Rpb24odCl7dmFyIHI9MTIqdC5zYW1wbGVzLmxlbmd0aCsxNDE7IXQuaXNWaWRlbyYmdC5pc0F1ZGlvRW5jcnlwdGlvbiYmKHI9MTQ5KTt2YXIgYT1uZXcgVWludDhBcnJheShbMSwwLDAsMCwwLDAsMCwxLDAsMCwwLDAscj4+MjQmMjU1LHI+PjE2JjI1NSxyPj44JjI1NSwyNTUmcl0pO3JldHVybiBlLmJveChlLnR5cGVzLnNhaW8sYSl9fSx7a2V5OiJzYWl6Iix2YWx1ZTpmdW5jdGlvbih0KXt2YXIgcj10LnNhbXBsZXMubGVuZ3RoLGE9bmV3IFVpbnQ4QXJyYXkoWzAsMCwwLDAsMTYscj4+MjQmMjU1LHI+PjE2JjI1NSxyPj44JjI1NSwyNTUmcl0pO3JldHVybiBlLmJveChlLnR5cGVzLnNhaXosYSl9fSx7a2V5OiJzYmdwIix2YWx1ZTpmdW5jdGlvbigpe3ZhciB0PW5ldyBVaW50OEFycmF5KFsxMTQsMTExLDEwOCwxMDgsMCwwLDAsMSwwLDAsMSwyNSwwLDAsMCwxXSk7cmV0dXJuIGUuYm94KGUudHlwZXMuc2JncCx0aGlzLmV4dGVuc2lvbigwLDApLHQpfX0se2tleToiZXh0ZW5zaW9uIix2YWx1ZTpmdW5jdGlvbihlLHQpe3JldHVybiBuZXcgVWludDhBcnJheShbZSx0Pj4xNiYyNTUsdD4+OCYyNTUsMjU1JnRdKX19LHtrZXk6InRmaGQiLHZhbHVlOmZ1bmN0aW9uKHQpe3JldHVybiBlLmJveChlLnR5cGVzLnRmaGQsbmV3IFVpbnQ4QXJyYXkoWzAsMCwwLDAsdD4+MjQsdD4+MTYmMjU1LHQ+PjgmMjU1LDI1NSZ0XSkpfX0se2tleToidGZkdCIsdmFsdWU6ZnVuY3Rpb24odCxyKXt2YXIgYT1NYXRoLmZsb29yKHIvKHhlKzEpKSxuPU1hdGguZmxvb3IociUoeGUrMSkpO3JldHVybiB0LnVzZUVNRSYmKHQuaXNWaWRlb0VuY3J5cHRpb258fHQuaXNBdWRpb0VuY3J5cHRpb24pP2UuYm94KGUudHlwZXMudGZkdCxuZXcgVWludDhBcnJheShbMCwwLDAsMCxuPj4yNCxuPj4xNiYyNTUsbj4+OCYyNTUsMjU1Jm5dKSk6ZS5ib3goZS50eXBlcy50ZmR0LG5ldyBVaW50OEFycmF5KFsxLDAsMCwwLGE+PjI0LGE+PjE2JjI1NSxhPj44JjI1NSwyNTUmYSxuPj4yNCxuPj4xNiYyNTUsbj4+OCYyNTUsMjU1Jm5dKSl9fSx7a2V5OiJ0cnVuIix2YWx1ZTpmdW5jdGlvbih0LHIpe3ZhciBhPXQubGVuZ3RoLG49MTIrMTYqYTtyKz04K247dmFyIGk9bmV3IFVpbnQ4QXJyYXkobik7aS5zZXQoWzAsMCwxNSwxLGE+Pj4yNCYyNTUsYT4+PjE2JjI1NSxhPj4+OCYyNTUsMjU1JmEscj4+PjI0JjI1NSxyPj4+MTYmMjU1LHI+Pj44JjI1NSwyNTUmcl0sMCk7Zm9yKHZhciBzPTA7czxhO3MrKyl7dmFyIG89dFtzXSx1PW8uZHVyYXRpb24sYz1vLnNpemUsbD1vLmZsYWcsZj12b2lkIDA9PT1sP3t9OmwsZD1vLmN0cyxoPXZvaWQgMD09PWQ/MDpkO2kuc2V0KFt1Pj4+MjQmMjU1LHU+Pj4xNiYyNTUsdT4+PjgmMjU1LDI1NSZ1LGM+Pj4yNCYyNTUsYz4+PjE2JjI1NSxjPj4+OCYyNTUsMjU1JmMsZi5pc0xlYWRpbmc8PDJ8KG51bGw9PT1mLmRlcGVuZHNPbnx8dm9pZCAwPT09Zi5kZXBlbmRzT24/MTpmLmRlcGVuZHNPbiksZi5pc0RlcGVuZGVkT248PDZ8Zi5oYXNSZWR1bmRhbmN5PDw0fGYucGFkZGluZ1ZhbHVlPDwxfChudWxsPT09Zi5pc05vblN5bmNTYW1wbGV8fHZvaWQgMD09PWYuaXNOb25TeW5jU2FtcGxlPzE6Zi5pc05vblN5bmNTYW1wbGUpLDYxNDQwJmYuZGVncmFkYXRpb25Qcmlvcml0eSwxNSZmLmRlZ3JhZGF0aW9uUHJpb3JpdHksaD4+PjI0JjI1NSxoPj4+MTYmMjU1LGg+Pj44JjI1NSwyNTUmaF0sMTIrMTYqcyl9cmV0dXJuIGUuYm94KGUudHlwZXMudHJ1bixpKX19LHtrZXk6Im1vb3ZNUDQiLHZhbHVlOmZ1bmN0aW9uKHQpe3JldHVybiBlLmJveC5hcHBseShlLFtlLnR5cGVzLm1vb3YsZS5tdmhkKHRbMF0uZHVyYXRpb24sdFswXS50aW1lc2NhbGUpXS5jb25jYXQoeSh0Lm1hcCgoZnVuY3Rpb24odCl7cmV0dXJuIGUudHJhY2tNUDQodCl9KSkpKSl9fSx7a2V5OiJ0cmFja01QNCIsdmFsdWU6ZnVuY3Rpb24odCl7cmV0dXJuIGUuYm94KGUudHlwZXMudHJhayxlLnRraGQodC5pZCx0LmR1cmF0aW9uLHQud2lkdGgsdC5oZWlnaHQpLGUubWRpYU1QNCh0KSl9fSx7a2V5OiJtZGlhTVA0Iix2YWx1ZTpmdW5jdGlvbih0KXtyZXR1cm4gZS5ib3goZS50eXBlcy5tZGlhLGUubWRoZCh0LmR1cmF0aW9uLHQudGltZXNjYWxlKSxlLmhkbHIodC50eXBlKSxlLm1pbmZNUDQodCkpfX0se2tleToibWluZk1QNCIsdmFsdWU6ZnVuY3Rpb24odCl7cmV0dXJuIGUuYm94KGUudHlwZXMubWluZix0LnR5cGU9PT1iP2UuVk1IRDplLlNNSEQsZS5ESU5GLGUuc3RibE1QNCh0KSl9fSx7a2V5OiJzdGJsTVA0Iix2YWx1ZTpmdW5jdGlvbih0KXt2YXIgcj10LmV4dCxhPVtlLnN0c2QodCksZS5zdHRzKHIuc3R0cyksZS5zdHNjKHIuc3RzYyksZS5zdHN6KHIuc3RzeiksZS5zdGNvKHIuc3RjbyldO3JldHVybiByLnN0c3MubGVuZ3RoJiZhLnB1c2goZS5zdHNzKHIuc3RzcykpLHIuY3R0cy5sZW5ndGgmJmEucHVzaChlLmN0dHMoci5jdHRzKSksZS5ib3guYXBwbHkoZSxbZS50eXBlcy5zdGJsXS5jb25jYXQoYSkpfX0se2tleToic3R0cyIsdmFsdWU6ZnVuY3Rpb24odCl7dmFyIHI9dC5sZW5ndGgsYT1uZXcgVWludDhBcnJheSg4KnIpLG49MDtyZXR1cm4gdC5mb3JFYWNoKChmdW5jdGlvbihlKXt2YXIgdD1lLnZhbHVlLHI9ZS5jb3VudDthLnNldChbcj4+MjQscj4+MTYmMjU1LHI+PjgmMjU1LDI1NSZyLHQ+PjI0LHQ+PjE2JjI1NSx0Pj44JjI1NSwyNTUmdF0sbiksbis9OH0pKSxlLmJveChlLnR5cGVzLnN0dHMsWihuZXcgVWludDhBcnJheShbMCwwLDAsMCxyPj4yNCxyPj4xNiYyNTUscj4+OCYyNTUsMjU1JnJdKSxhKSl9fSx7a2V5OiJzdHNjIix2YWx1ZTpmdW5jdGlvbih0KXt2YXIgcj10Lmxlbmd0aCxhPW5ldyBVaW50OEFycmF5KDEyKnIpLG49MDtyZXR1cm4gdC5mb3JFYWNoKChmdW5jdGlvbihlKXt2YXIgdD1lLmZpcnN0Q2h1bmsscj1lLnNhbXBsZXNQZXJDaHVuayxpPWUuc2FtcGxlRGVzY0luZGV4O2Euc2V0KFt0Pj4yNCx0Pj4xNiYyNTUsdD4+OCYyNTUsMjU1JnQscj4+MjQscj4+MTYmMjU1LHI+PjgmMjU1LDI1NSZyLGk+PjI0LGk+PjE2JjI1NSxpPj44JjI1NSwyNTUmaV0sbiksbis9MTJ9KSksZS5ib3goZS50eXBlcy5zdHNjLFoobmV3IFVpbnQ4QXJyYXkoWzAsMCwwLDAscj4+MjQscj4+MTYmMjU1LHI+PjgmMjU1LDI1NSZyXSksYSkpfX0se2tleToic3RzeiIsdmFsdWU6ZnVuY3Rpb24odCl7dmFyIHI9dC5sZW5ndGgsYT1uZXcgVWludDhBcnJheSg0KnIpLG49MDtyZXR1cm4gdC5mb3JFYWNoKChmdW5jdGlvbihlKXthLnNldChbZT4+MjQsZT4+MTYmMjU1LGU+PjgmMjU1LDI1NSZlXSxuKSxuKz00fSkpLGUuYm94KGUudHlwZXMuc3RzeixaKG5ldyBVaW50OEFycmF5KFswLDAsMCwwLDAsMCwwLDAscj4+MjQscj4+MTYmMjU1LHI+PjgmMjU1LDI1NSZyXSksYSkpfX0se2tleToic3RjbyIsdmFsdWU6ZnVuY3Rpb24odCl7dmFyIHI9dC5sZW5ndGgsYT1uZXcgVWludDhBcnJheSg0KnIpLG49MDtyZXR1cm4gdC5mb3JFYWNoKChmdW5jdGlvbihlKXthLnNldChbZT4+MjQsZT4+MTYmMjU1LGU+PjgmMjU1LDI1NSZlXSxuKSxuKz00fSkpLGUuYm94KGUudHlwZXMuc3RjbyxaKG5ldyBVaW50OEFycmF5KFswLDAsMCwwLHI+PjI0LHI+PjE2JjI1NSxyPj44JjI1NSwyNTUmcl0pLGEpKX19LHtrZXk6InN0c3MiLHZhbHVlOmZ1bmN0aW9uKHQpe3ZhciByPXQubGVuZ3RoLGE9bmV3IFVpbnQ4QXJyYXkoNCpyKSxuPTA7cmV0dXJuIHQuZm9yRWFjaCgoZnVuY3Rpb24oZSl7YS5zZXQoW2U+PjI0LGU+PjE2JjI1NSxlPj44JjI1NSwyNTUmZV0sbiksbis9NH0pKSxlLmJveChlLnR5cGVzLnN0c3MsWihuZXcgVWludDhBcnJheShbMCwwLDAsMCxyPj4yNCxyPj4xNiYyNTUscj4+OCYyNTUsMjU1JnJdKSxhKSl9fSx7a2V5OiJjdHRzIix2YWx1ZTpmdW5jdGlvbih0KXt2YXIgcj10Lmxlbmd0aCxhPW5ldyBVaW50OEFycmF5KDgqciksbj0wO3JldHVybiB0LmZvckVhY2goKGZ1bmN0aW9uKGUpe3ZhciB0PWUudmFsdWUscj1lLmNvdW50O2Euc2V0KFtyPj4yNCxyPj4xNiYyNTUscj4+OCYyNTUsMjU1JnIsdD4+MjQsdD4+MTYmMjU1LHQ+PjgmMjU1LDI1NSZ0XSxuKSxuKz04fSkpLGUuYm94KGUudHlwZXMuY3R0cyxaKG5ldyBVaW50OEFycmF5KFswLDAsMCwwLHI+PjI0LHI+PjE2JjI1NSxyPj44JjI1NSwyNTUmcl0pLGEpKX19LHtrZXk6InN0eXAiLHZhbHVlOmZ1bmN0aW9uKCl7cmV0dXJuIGUuYm94KGUudHlwZXMuc3R5cCxuZXcgVWludDhBcnJheShbMTA5LDExNSwxMDAsMTA0LDAsMCwwLDAsMTA5LDExNSwxMDAsMTA0LDEwOSwxMTUsMTA1LDEyMF0pKX19LHtrZXk6InNpZHgiLHZhbHVlOmZ1bmN0aW9uKHQpe3ZhciByPXQudGltZXNjYWxlLGE9dC5zYW1wbGVzWzBdLmR1cmF0aW9uLG49YSp0LnNhbXBsZXMubGVuZ3RoLGk9dC5zYW1wbGVzWzBdLnNhbXBsZU9mZnNldCphLHM9ODt0LnNhbXBsZXMuZm9yRWFjaCgoZnVuY3Rpb24oZSl7cys9ZS5zaXplfSkpO3ZhciBvPTA7aWYodC5pc1ZpZGVvKXt2YXIgdSxjPTA7dC52aWRlb1NlbmMmJih1PXQudmlkZW9TZW5jKSx0LmlzVmlkZW8mJnUuZm9yRWFjaCgoZnVuY3Rpb24oZSl7Yys9OCxlLnN1YnNhbXBsZXMmJmUuc3Vic2FtcGxlcy5sZW5ndGgmJihjKz0yLGMrPTYqZS5zdWJzYW1wbGVzLmxlbmd0aCl9KSksdC52aWRlb1NlbmNMZW5ndGg9YyxvPXMrMTQxKzE2KnQuc2FtcGxlcy5sZW5ndGgrYyx0LnVzZUVNRSYmdC5pc0F1ZGlvRW5jcnlwdGlvbiYmIXQuaXNWaWRlb0VuY3J5cHRpb24mJihvPXMrMTYqdC5zYW1wbGVzLmxlbmd0aCs4NCl9ZWxzZSBvPXMrMTE2KzEyKnQuc2FtcGxlcy5sZW5ndGgsdC51c2VFTUUmJnQuaXNBdWRpb0VuY3J5cHRpb24mJihvPXMrMTY5KzEyKnQuc2FtcGxlcy5sZW5ndGgrOCp0LmF1ZGlvU2VuYy5sZW5ndGgpO3ZhciBsPW5ldyBVaW50OEFycmF5KFswLDAsMCwwLDAsMCwwLDI1NSZ0LmlkLHI+PjI0JjI1NSxyPj4xNiYyNTUscj4+OCYyNTUsMjU1JnIsaT4+MjQmMjU1LGk+PjE2JjI1NSxpPj44JjI1NSwyNTUmaSwwLDAsMCwwLDAsMCwwLDEsMCxvPj4xNiYyNTUsbz4+OCYyNTUsMjU1Jm8sbj4+MjQmMjU1LG4+PjE2JjI1NSxuPj44JjI1NSwyNTUmbiwxNDQsMCwwLDBdKTtyZXR1cm4gZS5ib3goZS50eXBlcy5zaWR4LGwpfX0se2tleToibWRhdCIsdmFsdWU6ZnVuY3Rpb24odCl7cmV0dXJuIGUuYm94KGUudHlwZXMubWRhdCx0KX19XSksZX0oKTtpKFNlLCJ0eXBlcyIsWyJhdmMxIiwiYXZjQyIsImh2YzEiLCJodmNDIiwiZGluZiIsImRyZWYiLCJlc2RzIiwiZnR5cCIsImhkbHIiLCJtZGF0IiwibWRoZCIsIm1kaWEiLCJtZmhkIiwibWluZiIsIm1vb2YiLCJtb292IiwibXA0YSIsIm12ZXgiLCJtdmhkIiwicGFzcCIsInN0YmwiLCJzdGNvIiwic3RzYyIsInN0c2QiLCJzdHN6Iiwic3R0cyIsInRmZHQiLCJ0ZmhkIiwidHJhZiIsInRyYWsiLCJ0cmV4IiwidGtoZCIsInZtaGQiLCJzbWhkIiwiY3R0cyIsInN0c3MiLCJzdHlwIiwicHNzaCIsInNpZHgiLCJzYmdwIiwic2FpeiIsInNhaW8iLCJzZW5jIiwidHJ1biIsImVuY3YiLCJlbmNhIiwic2luZiIsImJ0cnQiLCJmcm1hIiwidGVuYyIsInNjaG0iLCJzY2hpIiwibWVoZCIsImZpZWwiLCJzZHRwIl0ucmVkdWNlKChmdW5jdGlvbihlLHQpe3JldHVybiBlW3RdPVt0LmNoYXJDb2RlQXQoMCksdC5jaGFyQ29kZUF0KDEpLHQuY2hhckNvZGVBdCgyKSx0LmNoYXJDb2RlQXQoMyldLGV9KSxPYmplY3QuY3JlYXRlKG51bGwpKSksaShTZSwiSERMUl9UWVBFUyIse3ZpZGVvOm5ldyBVaW50OEFycmF5KFswLDAsMCwwLDAsMCwwLDAsMTE4LDEwNSwxMDAsMTAxLDAsMCwwLDAsMCwwLDAsMCwwLDAsMCwwLDg2LDEwNSwxMDAsMTAxLDExMSw3Miw5NywxMTAsMTAwLDEwOCwxMDEsMTE0LDBdKSxhdWRpbzpuZXcgVWludDhBcnJheShbMCwwLDAsMCwwLDAsMCwwLDExNSwxMTEsMTE3LDExMCwwLDAsMCwwLDAsMCwwLDAsMCwwLDAsMCw4MywxMTEsMTE3LDExMCwxMDAsNzIsOTcsMTEwLDEwMCwxMDgsMTAxLDExNCwwXSl9KSxpKFNlLCJGVFlQQVZDMSIsU2UuYm94KFNlLnR5cGVzLmZ0eXAsbmV3IFVpbnQ4QXJyYXkoWzEwNSwxMTUsMTExLDEwOSwwLDAsMCwxLDEwNSwxMTUsMTExLDEwOSw5NywxMTgsOTksNDldKSkpLGkoU2UsIkZUWVBIRVYxIixTZS5ib3goU2UudHlwZXMuZnR5cCxuZXcgVWludDhBcnJheShbMTA1LDExNSwxMTEsMTA5LDAsMCwwLDEsMTA1LDExNSwxMTEsMTA5LDEwNCwxMDEsMTE4LDQ5XSkpKSxpKFNlLCJESU5GIixTZS5ib3goU2UudHlwZXMuZGluZixTZS5ib3goU2UudHlwZXMuZHJlZixuZXcgVWludDhBcnJheShbMCwwLDAsMCwwLDAsMCwxLDAsMCwwLDEyLDExNywxMTQsMTA4LDMyLDAsMCwwLDFdKSkpKSxpKFNlLCJWTUhEIixTZS5ib3goU2UudHlwZXMudm1oZCxuZXcgVWludDhBcnJheShbMCwwLDAsMSwwLDAsMCwwLDAsMCwwLDBdKSkpLGkoU2UsIlNNSEQiLFNlLmJveChTZS50eXBlcy5zbWhkLG5ldyBVaW50OEFycmF5KFswLDAsMCwwLDAsMCwwLDBdKSkpLGkoU2UsIlN0YmxUYWJsZSIsbmV3IFVpbnQ4QXJyYXkoWzAsMCwwLDAsMCwwLDAsMF0pKSxpKFNlLCJTVFRTIixTZS5ib3goU2UudHlwZXMuc3R0cyxTZS5TdGJsVGFibGUpKSxpKFNlLCJTVFNDIixTZS5ib3goU2UudHlwZXMuc3RzYyxTZS5TdGJsVGFibGUpKSxpKFNlLCJTVFNaIixTZS5ib3goU2UudHlwZXMuc3RzeixuZXcgVWludDhBcnJheShbMCwwLDAsMCwwLDAsMCwwLDAsMCwwLDBdKSkpLGkoU2UsIlNUQ08iLFNlLmJveChTZS50eXBlcy5zdGNvLFNlLlN0YmxUYWJsZSkpO3ZhciBBZT1mdW5jdGlvbigpe2Z1bmN0aW9uIGUodCxhKXtyKHRoaXMsZSksdGhpcy5uYW1lPXR8fCIiLHRoaXMuX3ByZWZpeD0iWyIuY29uY2F0KHRoaXMubmFtZSwiXSIpLGUuZGlzYWJsZWQ9YX1yZXR1cm4gbihlLFt7a2V5OiJkZWJ1ZyIsdmFsdWU6ZnVuY3Rpb24oKXt2YXIgdDtpZighZS5kaXNhYmxlZCl7Zm9yKHZhciByPWFyZ3VtZW50cy5sZW5ndGgsYT1uZXcgQXJyYXkociksbj0wO248cjtuKyspYVtuXT1hcmd1bWVudHNbbl07KHQ9Y29uc29sZSkuZGVidWcuYXBwbHkodCxbdGhpcy5fcHJlZml4XS5jb25jYXQoYSkpfX19LHtrZXk6ImxvZyIsdmFsdWU6ZnVuY3Rpb24oKXt2YXIgdDtpZighZS5kaXNhYmxlZCl7Zm9yKHZhciByPWFyZ3VtZW50cy5sZW5ndGgsYT1uZXcgQXJyYXkociksbj0wO248cjtuKyspYVtuXT1hcmd1bWVudHNbbl07KHQ9Y29uc29sZSkubG9nLmFwcGx5KHQsW3RoaXMuX3ByZWZpeF0uY29uY2F0KGEpKX19fSx7a2V5OiJ3YXJuIix2YWx1ZTpmdW5jdGlvbigpe3ZhciB0O2lmKCFlLmRpc2FibGVkKXtmb3IodmFyIHI9YXJndW1lbnRzLmxlbmd0aCxhPW5ldyBBcnJheShyKSxuPTA7bjxyO24rKylhW25dPWFyZ3VtZW50c1tuXTsodD1jb25zb2xlKS53YXJuLmFwcGx5KHQsW3RoaXMuX3ByZWZpeF0uY29uY2F0KGEpKX19fSx7a2V5OiJlcnJvciIsdmFsdWU6ZnVuY3Rpb24oKXt2YXIgdDtpZighZS5kaXNhYmxlZCl7Zm9yKHZhciByPWFyZ3VtZW50cy5sZW5ndGgsYT1uZXcgQXJyYXkociksbj0wO248cjtuKyspYVtuXT1hcmd1bWVudHNbbl07KHQ9Y29uc29sZSkuZXJyb3IuYXBwbHkodCxbdGhpcy5fcHJlZml4XS5jb25jYXQoYSkpfX19LHtrZXk6InRhYmxlIix2YWx1ZTpmdW5jdGlvbigpe3ZhciB0O2UuZGlzYWJsZWR8fChjb25zb2xlLmdyb3VwKHRoaXMuX3ByZWZpeCksKHQ9Y29uc29sZSkudGFibGUuYXBwbHkodCxhcmd1bWVudHMpLGNvbnNvbGUuZ3JvdXBFbmQoKSl9fV0sW3trZXk6ImVuYWJsZSIsdmFsdWU6ZnVuY3Rpb24oKXtlLmRpc2FibGVkPSExfX0se2tleToiZGlzYWJsZSIsdmFsdWU6ZnVuY3Rpb24oKXtlLmRpc2FibGVkPSEwfX1dKSxlfSgpO2koQWUsImRpc2FibGVkIiwhMCk7Zm9yKHZhciBEZT1mdW5jdGlvbigpe2Z1bmN0aW9uIGUodCxhLG4pe3IodGhpcyxlKSx0aGlzLnZpZGVvVHJhY2s9dCx0aGlzLmF1ZGlvVHJhY2s9YTt2YXIgaT0vQ2hyb21lXC8oW14uXSspLy5leGVjKG5hdmlnYXRvci51c2VyQWdlbnQpO3RoaXMuZm9yY2VGaXJzdElEUj1pJiZOdW1iZXIoaVsxXSk8NTAsdGhpcy5sb2c9bmV3IEFlKCJGTVA0UmVtdXhlciIsIW58fCFuLm9wZW5Mb2d8fCFuLm9wZW5Mb2cpfXJldHVybiBuKGUsW3trZXk6InJlbXV4Iix2YWx1ZTpmdW5jdGlvbigpe3ZhciBlLHQscixhLG4saT1hcmd1bWVudHMubGVuZ3RoPjAmJnZvaWQgMCE9PWFyZ3VtZW50c1swXSYmYXJndW1lbnRzWzBdLHM9YXJndW1lbnRzLmxlbmd0aD4xJiZ2b2lkIDAhPT1hcmd1bWVudHNbMV0/YXJndW1lbnRzWzFdOnt9LG89dGhpcy52aWRlb1RyYWNrLHU9dGhpcy5hdWRpb1RyYWNrLGM9by5leGlzdCgpLGw9dS5leGlzdCgpLGY9W107cmV0dXJuIGkmJihzJiZzLmluaXRNZXJnZT8oYyYmZi5wdXNoKHRoaXMudmlkZW9UcmFjayksbCYmZi5wdXNoKHRoaXMuYXVkaW9UcmFjaykscj1TZS5pbml0U2VnbWVudChmKSk6KGMmJihlPVNlLmluaXRTZWdtZW50KFt0aGlzLnZpZGVvVHJhY2tdKSksbCYmKHQ9U2UuaW5pdFNlZ21lbnQoW3RoaXMuYXVkaW9UcmFja10pKSkpLGMmJm8uaGFzU2FtcGxlKCkmJihhPXRoaXMuX3JlbXV4VmlkZW8oKSksbCYmdS5oYXNTYW1wbGUoKSYmKG49dGhpcy5fcmVtdXhBdWRpbygpKSxvLnNhbXBsZXM9W10sdS5zYW1wbGVzPVtdLHtpbml0U2VnbWVudDpyLHZpZGVvSW5pdFNlZ21lbnQ6ZSxhdWRpb0luaXRTZWdtZW50OnQsdmlkZW9TZWdtZW50OmEsYXVkaW9TZWdtZW50Om59fX0se2tleToiX3JlbXV4VmlkZW8iLHZhbHVlOmZ1bmN0aW9uKCl7dmFyIGU9dGhpcy52aWRlb1RyYWNrO3RoaXMuZm9yY2VGaXJzdElEUiYmKGUuc2FtcGxlc1swXS5mbGFnPXtkZXBlbmRzT246Mixpc05vblN5bmNTYW1wbGU6MH0pO3ZhciB0PWUuc2FtcGxlcyxyPTA7dC5mb3JFYWNoKChmdW5jdGlvbihlKXtyKz1lLnVuaXRzLnJlZHVjZSgoZnVuY3Rpb24oZSx0KXtyZXR1cm4gZSt0LmJ5dGVMZW5ndGh9KSwwKSxyKz00KmUudW5pdHMubGVuZ3RofSkpO2Zvcih2YXIgYSxuPW5ldyBVaW50OEFycmF5KHIpLGk9bmV3IERhdGFWaWV3KG4uYnVmZmVyKSxzPWZ1bmN0aW9uKGUscil7cj10W29dO3ZhciBzPTA7ci51bml0cy5mb3JFYWNoKChmdW5jdGlvbih0KXtpLnNldFVpbnQzMihlLHQuYnl0ZUxlbmd0aCksZSs9NCxuLnNldCh0LGUpLGUrPXQuYnl0ZUxlbmd0aCxzKz00K3QuYnl0ZUxlbmd0aH0pKSxyLnNpemU9cyxjPWUsYT1yfSxvPTAsdT10Lmxlbmd0aCxjPTA7bzx1O28rKylzKGMsYSk7dmFyIGw9U2UubWRhdChuKTtyZXR1cm4gWihTZS5tb29mKFtlXSksbCl9fSx7a2V5OiJfcmVtdXhBdWRpbyIsdmFsdWU6ZnVuY3Rpb24oKXt2YXIgZT10aGlzLmF1ZGlvVHJhY2ssdD1uZXcgVWludDhBcnJheShlLnNhbXBsZXMucmVkdWNlKChmdW5jdGlvbihlLHQpe3JldHVybiBlK3Quc2l6ZX0pLDApKTtlLnNhbXBsZXMucmVkdWNlKChmdW5jdGlvbihlLHIpe3JldHVybiB0LnNldChyLmRhdGEsZSksZStyLnNpemV9KSwwKTt2YXIgcj1TZS5tZGF0KHQpO3JldHVybiBaKFNlLm1vb2YoW2VdKSxyKX19LHtrZXk6InJlc2V0Iix2YWx1ZTpmdW5jdGlvbigpe3RoaXMudmlkZW9UcmFjay5yZXNldCgpLHRoaXMuYXVkaW9UcmFjay5yZXNldCgpfX1dKSxlfSgpLEVlPWZ1bmN0aW9uKCl7ZnVuY3Rpb24gZSgpe3IodGhpcyxlKX1yZXR1cm4gbihlLFt7a2V5OiJtaXhJbiIsdmFsdWU6ZnVuY3Rpb24oZSl7cmV0dXJuIE9iamVjdC5hc3NpZ24odGhpcyxlKX19LHtrZXk6ImNsb25lIix2YWx1ZTpmdW5jdGlvbigpe3ZhciBlPW5ldyB0aGlzLmNvbnN0cnVjdG9yO3JldHVybiBPYmplY3QuYXNzaWduKGUsdGhpcyksZX19XSxbe2tleToiY3JlYXRlIix2YWx1ZTpmdW5jdGlvbigpe2Zvcih2YXIgZT1hcmd1bWVudHMubGVuZ3RoLHQ9bmV3IEFycmF5KGUpLHI9MDtyPGU7cisrKXRbcl09YXJndW1lbnRzW3JdO3JldHVybiBsKHRoaXMsdCl9fV0pLGV9KCksQmU9ZnVuY3Rpb24oZSl7cyhhLGUpO3ZhciB0PWQoYSk7ZnVuY3Rpb24gYSgpe3ZhciBlLG49YXJndW1lbnRzLmxlbmd0aD4wJiZ2b2lkIDAhPT1hcmd1bWVudHNbMF0/YXJndW1lbnRzWzBdOltdLGk9YXJndW1lbnRzLmxlbmd0aD4xJiZ2b2lkIDAhPT1hcmd1bWVudHNbMV0/YXJndW1lbnRzWzFdOjQqbi5sZW5ndGg7cih0aGlzLGEpLGU9dC5jYWxsKHRoaXMpO3ZhciBzPW47aWYocyBpbnN0YW5jZW9mIEFycmF5QnVmZmVyJiYocz1uZXcgVWludDhBcnJheShzKSksKHMgaW5zdGFuY2VvZiBJbnQ4QXJyYXl8fHMgaW5zdGFuY2VvZiBVaW50OENsYW1wZWRBcnJheXx8cyBpbnN0YW5jZW9mIEludDE2QXJyYXl8fHMgaW5zdGFuY2VvZiBVaW50MTZBcnJheXx8cyBpbnN0YW5jZW9mIEludDMyQXJyYXl8fHMgaW5zdGFuY2VvZiBVaW50MzJBcnJheXx8cyBpbnN0YW5jZW9mIEZsb2F0MzJBcnJheXx8cyBpbnN0YW5jZW9mIEZsb2F0NjRBcnJheSkmJihzPW5ldyBVaW50OEFycmF5KHMuYnVmZmVyLHMuYnl0ZU9mZnNldCxzLmJ5dGVMZW5ndGgpKSxzIGluc3RhbmNlb2YgVWludDhBcnJheSl7Zm9yKHZhciBvPXMuYnl0ZUxlbmd0aCx1PVtdLGM9MDtjPG87Yys9MSl1W2M+Pj4yXXw9c1tjXTw8MjQtYyU0Kjg7ZS53b3Jkcz11LGUuc2lnQnl0ZXM9b31lbHNlIGUud29yZHM9bixlLnNpZ0J5dGVzPWk7cmV0dXJuIGV9cmV0dXJuIG4oYSxbe2tleToidG9TdHJpbmciLHZhbHVlOmZ1bmN0aW9uKCl7dmFyIGU9YXJndW1lbnRzLmxlbmd0aD4wJiZ2b2lkIDAhPT1hcmd1bWVudHNbMF0/YXJndW1lbnRzWzBdOlRlO3JldHVybiBlLnN0cmluZ2lmeSh0aGlzKX19LHtrZXk6ImNvbmNhdCIsdmFsdWU6ZnVuY3Rpb24oZSl7dmFyIHQ9dGhpcy53b3JkcyxyPWUud29yZHMsYT10aGlzLnNpZ0J5dGVzLG49ZS5zaWdCeXRlcztpZih0aGlzLmNsYW1wKCksYSU0KWZvcih2YXIgaT0wO2k8bjtpKz0xKXt2YXIgcz1yW2k+Pj4yXT4+PjI0LWklNCo4JjI1NTt0W2EraT4+PjJdfD1zPDwyNC0oYStpKSU0Kjh9ZWxzZSBmb3IodmFyIG89MDtvPG47bys9NCl0W2Erbz4+PjJdPXJbbz4+PjJdO3JldHVybiB0aGlzLnNpZ0J5dGVzKz1uLHRoaXN9fSx7a2V5OiJjbGFtcCIsdmFsdWU6ZnVuY3Rpb24oKXt2YXIgZT10aGlzLndvcmRzLHQ9dGhpcy5zaWdCeXRlcztlW3Q+Pj4yXSY9NDI5NDk2NzI5NTw8MzItdCU0KjgsZS5sZW5ndGg9TWF0aC5jZWlsKHQvNCl9fSx7a2V5OiJjbG9uZSIsdmFsdWU6ZnVuY3Rpb24oKXt2YXIgZT1wKG8oYS5wcm90b3R5cGUpLCJjbG9uZSIsdGhpcykuY2FsbCh0aGlzKTtyZXR1cm4gZS53b3Jkcz10aGlzLndvcmRzLnNsaWNlKDApLGV9fV0sW3trZXk6InJhbmRvbSIsdmFsdWU6ZnVuY3Rpb24oZSl7Zm9yKHZhciB0LHI9W10sbj1mdW5jdGlvbihlKXt2YXIgdD1lLHI9OTg3NjU0MzIxLGE9NDI5NDk2NzI5NTtyZXR1cm4gZnVuY3Rpb24oKXt2YXIgZT0oKHI9MzY5NjkqKDY1NTM1JnIpKyhyPj4xNikmYSk8PDE2KSsodD0xOGUzKig2NTUzNSZ0KSsodD4+MTYpJmEpJmE7cmV0dXJuIGUvPTQyOTQ5NjcyOTYsKGUrPS41KSooTWF0aC5yYW5kb20oKT4uNT8xOi0xKX19LGk9MDtpPGU7aSs9NCl7dmFyIHM9big0Mjk0OTY3Mjk2Kih0fHxNYXRoLnJhbmRvbSgpKSk7dD05ODc2NTQwNzEqcygpLHIucHVzaCg0Mjk0OTY3Mjk2KnMoKXwwKX1yZXR1cm4gbmV3IGEocixlKX19XSksYX0oRWUpLFRlPXtzdHJpbmdpZnk6ZnVuY3Rpb24oZSl7Zm9yKHZhciB0PWUud29yZHMscj1lLnNpZ0J5dGVzLGE9W10sbj0wO248cjtuKz0xKXt2YXIgaT10W24+Pj4yXT4+PjI0LW4lNCo4JjI1NTthLnB1c2goKGk+Pj40KS50b1N0cmluZygxNikpLGEucHVzaCgoMTUmaSkudG9TdHJpbmcoMTYpKX1yZXR1cm4gYS5qb2luKCIiKX0scGFyc2U6ZnVuY3Rpb24oZSl7Zm9yKHZhciB0PWUubGVuZ3RoLHI9W10sYT0wO2E8dDthKz0yKXJbYT4+PjNdfD1wYXJzZUludChlLnN1YnN0cihhLDIpLDE2KTw8MjQtYSU4KjQ7cmV0dXJuIG5ldyBCZShyLHQvMil9fSxDZT1mdW5jdGlvbihlKXtmb3IodmFyIHQ9ZS5sZW5ndGgscj1bXSxhPTA7YTx0O2ErPTEpclthPj4+Ml18PSgyNTUmZS5jaGFyQ29kZUF0KGEpKTw8MjQtYSU0Kjg7cmV0dXJuIG5ldyBCZShyLHQpfSxVZT1mdW5jdGlvbihlKXtyZXR1cm4gQ2UodW5lc2NhcGUoZW5jb2RlVVJJQ29tcG9uZW50KGUpKSl9LFBlPWZ1bmN0aW9uKGUpe3MoYSxlKTt2YXIgdD1kKGEpO2Z1bmN0aW9uIGEoKXt2YXIgZTtyZXR1cm4gcih0aGlzLGEpLChlPXQuY2FsbCh0aGlzKSkuX21pbkJ1ZmZlclNpemU9MCxlfXJldHVybiBuKGEsW3trZXk6InJlc2V0Iix2YWx1ZTpmdW5jdGlvbigpe3RoaXMuX2RhdGE9bmV3IEJlLHRoaXMuX25EYXRhQnl0ZXM9MH19LHtrZXk6Il9hcHBlbmQiLHZhbHVlOmZ1bmN0aW9uKGUpe3ZhciB0PWU7InN0cmluZyI9PXR5cGVvZiB0JiYodD1VZSh0KSksdGhpcy5fZGF0YS5jb25jYXQodCksdGhpcy5fbkRhdGFCeXRlcys9dC5zaWdCeXRlc319LHtrZXk6Il9wcm9jZXNzIix2YWx1ZTpmdW5jdGlvbihlKXt2YXIgdCxyPXRoaXMuX2RhdGEsYT10aGlzLmJsb2NrU2l6ZSxuPXIud29yZHMsaT1yLnNpZ0J5dGVzLHM9aS8oNCphKSxvPShzPWU/TWF0aC5jZWlsKHMpOk1hdGgubWF4KCgwfHMpLXRoaXMuX21pbkJ1ZmZlclNpemUsMCkpKmEsdT1NYXRoLm1pbig0Km8saSk7aWYobyl7Zm9yKHZhciBjPTA7YzxvO2MrPWEpdGhpcy5fZG9Qcm9jZXNzQmxvY2sobixjKTt0PW4uc3BsaWNlKDAsbyksci5zaWdCeXRlcy09dX1yZXR1cm4gbmV3IEJlKHQsdSl9fSx7a2V5OiJjbG9uZSIsdmFsdWU6ZnVuY3Rpb24oKXt2YXIgZT1wKG8oYS5wcm90b3R5cGUpLCJjbG9uZSIsdGhpcykuY2FsbCh0aGlzKTtyZXR1cm4gZS5fZGF0YT10aGlzLl9kYXRhLmNsb25lKCksZX19XSksYX0oRWUpLEllPWZ1bmN0aW9uKGUpe3MoYSxlKTt2YXIgdD1kKGEpO2Z1bmN0aW9uIGEoZSl7dmFyIG47cmV0dXJuIHIodGhpcyxhKSwobj10LmNhbGwodGhpcykpLmJsb2NrU2l6ZT0xNixuLmNmZz1PYmplY3QuYXNzaWduKG5ldyBFZSxlKSxuLnJlc2V0KCksbn1yZXR1cm4gbihhLFt7a2V5OiJyZXNldCIsdmFsdWU6ZnVuY3Rpb24oKXtwKG8oYS5wcm90b3R5cGUpLCJyZXNldCIsdGhpcykuY2FsbCh0aGlzKSx0aGlzLl9kb1Jlc2V0KCl9fSx7a2V5OiJ1cGRhdGUiLHZhbHVlOmZ1bmN0aW9uKGUpe3JldHVybiB0aGlzLl9hcHBlbmQoZSksdGhpcy5fcHJvY2VzcygpLHRoaXN9fSx7a2V5OiJmaW5hbGl6ZSIsdmFsdWU6ZnVuY3Rpb24oZSl7cmV0dXJuIGUmJnRoaXMuX2FwcGVuZChlKSx0aGlzLl9kb0ZpbmFsaXplKCl9fV0sW3trZXk6Il9jcmVhdGVIZWxwZXIiLHZhbHVlOmZ1bmN0aW9uKGUpe3JldHVybiBmdW5jdGlvbih0LHIpe3JldHVybiBuZXcgZShyKS5maW5hbGl6ZSh0KX19fSx7a2V5OiJfY3JlYXRlSG1hY0hlbHBlciIsdmFsdWU6ZnVuY3Rpb24oZSl7cmV0dXJuIGZ1bmN0aW9uKHQscil7cmV0dXJuIG5ldyB6ZShlLHIpLmZpbmFsaXplKHQpfX19XSksYX0oUGUpLHplPWZ1bmN0aW9uKGUpe3MoYSxlKTt2YXIgdD1kKGEpO2Z1bmN0aW9uIGEoZSxuKXt2YXIgaTtyKHRoaXMsYSksaT10LmNhbGwodGhpcyk7dmFyIHM9bmV3IGU7aS5faGFzaGVyPXM7dmFyIG89bjsic3RyaW5nIj09dHlwZW9mIG8mJihvPVVlKG8pKTt2YXIgdT1zLmJsb2NrU2l6ZSxjPTQqdTtvLnNpZ0J5dGVzPmMmJihvPXMuZmluYWxpemUobikpLG8uY2xhbXAoKTt2YXIgbD1vLmNsb25lKCk7aS5fb0tleT1sO3ZhciBmPW8uY2xvbmUoKTtpLl9pS2V5PWY7Zm9yKHZhciBkPWwud29yZHMsaD1mLndvcmRzLHA9MDtwPHU7cCs9MSlkW3BdXj0xNTQ5NTU2ODI4LGhbcF1ePTkwOTUyMjQ4NjtyZXR1cm4gbC5zaWdCeXRlcz1jLGYuc2lnQnl0ZXM9YyxpLnJlc2V0KCksaX1yZXR1cm4gbihhLFt7a2V5OiJyZXNldCIsdmFsdWU6ZnVuY3Rpb24oKXt2YXIgZT10aGlzLl9oYXNoZXI7ZS5yZXNldCgpLGUudXBkYXRlKHRoaXMuX2lLZXkpfX0se2tleToidXBkYXRlIix2YWx1ZTpmdW5jdGlvbihlKXtyZXR1cm4gdGhpcy5faGFzaGVyLnVwZGF0ZShlKSx0aGlzfX0se2tleToiZmluYWxpemUiLHZhbHVlOmZ1bmN0aW9uKGUpe3ZhciB0PXRoaXMuX2hhc2hlcixyPXQuZmluYWxpemUoZSk7cmV0dXJuIHQucmVzZXQoKSx0LmZpbmFsaXplKHRoaXMuX29LZXkuY2xvbmUoKS5jb25jYXQocikpfX1dKSxhfShFZSksTWU9e3N0cmluZ2lmeTpmdW5jdGlvbihlKXt2YXIgdD1lLndvcmRzLHI9ZS5zaWdCeXRlcyxhPXRoaXMuX21hcDtlLmNsYW1wKCk7Zm9yKHZhciBuPVtdLGk9MDtpPHI7aSs9Mylmb3IodmFyIHM9KHRbaT4+PjJdPj4+MjQtaSU0KjgmMjU1KTw8MTZ8KHRbaSsxPj4+Ml0+Pj4yNC0oaSsxKSU0KjgmMjU1KTw8OHx0W2krMj4+PjJdPj4+MjQtKGkrMiklNCo4JjI1NSxvPTA7bzw0JiZpKy43NSpvPHI7bys9MSluLnB1c2goYS5jaGFyQXQocz4+PjYqKDMtbykmNjMpKTt2YXIgdT1hLmNoYXJBdCg2NCk7aWYodSlmb3IoO24ubGVuZ3RoJTQ7KW4ucHVzaCh1KTtyZXR1cm4gbi5qb2luKCIiKX0scGFyc2U6ZnVuY3Rpb24oZSl7dmFyIHQ9ZS5sZW5ndGgscj10aGlzLl9tYXAsYT10aGlzLl9yZXZlcnNlTWFwO2lmKCFhKXt0aGlzLl9yZXZlcnNlTWFwPVtdLGE9dGhpcy5fcmV2ZXJzZU1hcDtmb3IodmFyIG49MDtuPHIubGVuZ3RoO24rPTEpYVtyLmNoYXJDb2RlQXQobildPW59dmFyIGk9ci5jaGFyQXQoNjQpO2lmKGkpe3ZhciBzPWUuaW5kZXhPZihpKTstMSE9PXMmJih0PXMpfXJldHVybiBmdW5jdGlvbihlLHQscil7Zm9yKHZhciBhPVtdLG49MCxpPTA7aTx0O2krPTEpaWYoaSU0KXt2YXIgcz1yW2UuY2hhckNvZGVBdChpLTEpXTw8aSU0KjJ8cltlLmNoYXJDb2RlQXQoaSldPj4+Ni1pJTQqMjthW24+Pj4yXXw9czw8MjQtbiU0Kjgsbis9MX1yZXR1cm4gQmUuY3JlYXRlKGEsbil9KGUsdCxhKX0sX21hcDoiQUJDREVGR0hJSktMTU5PUFFSU1RVVldYWVphYmNkZWZnaGlqa2xtbm9wcXJzdHV2d3h5ejAxMjM0NTY3ODkrLz0ifSxSZT1bXSxPZT0wO09lPDY0O09lKz0xKVJlW09lXT00Mjk0OTY3Mjk2Kk1hdGguYWJzKE1hdGguc2luKE9lKzEpKXwwO3ZhciBMZT1mdW5jdGlvbihlLHQscixhLG4saSxzKXt2YXIgbz1lKyh0JnJ8fnQmYSkrbitzO3JldHVybihvPDxpfG8+Pj4zMi1pKSt0fSxWZT1mdW5jdGlvbihlLHQscixhLG4saSxzKXt2YXIgbz1lKyh0JmF8ciZ+YSkrbitzO3JldHVybihvPDxpfG8+Pj4zMi1pKSt0fSxGZT1mdW5jdGlvbihlLHQscixhLG4saSxzKXt2YXIgbz1lKyh0XnJeYSkrbitzO3JldHVybihvPDxpfG8+Pj4zMi1pKSt0fSxOZT1mdW5jdGlvbihlLHQscixhLG4saSxzKXt2YXIgbz1lKyhyXih0fH5hKSkrbitzO3JldHVybihvPDxpfG8+Pj4zMi1pKSt0fSxqZT1mdW5jdGlvbihlKXtzKGEsZSk7dmFyIHQ9ZChhKTtmdW5jdGlvbiBhKCl7cmV0dXJuIHIodGhpcyxhKSx0LmFwcGx5KHRoaXMsYXJndW1lbnRzKX1yZXR1cm4gbihhLFt7a2V5OiJfZG9SZXNldCIsdmFsdWU6ZnVuY3Rpb24oKXt0aGlzLl9oYXNoPW5ldyBCZShbMTczMjU4NDE5Myw0MDIzMjMzNDE3LDI1NjIzODMxMDIsMjcxNzMzODc4XSl9fSx7a2V5OiJfZG9Qcm9jZXNzQmxvY2siLHZhbHVlOmZ1bmN0aW9uKGUsdCl7Zm9yKHZhciByPWUsYT0wO2E8MTY7YSs9MSl7dmFyIG49dCthLGk9ZVtuXTtyW25dPTE2NzExOTM1JihpPDw4fGk+Pj4yNCl8NDI3ODI1NTM2MCYoaTw8MjR8aT4+PjgpfXZhciBzPXRoaXMuX2hhc2gud29yZHMsbz1yW3QrMF0sdT1yW3QrMV0sYz1yW3QrMl0sbD1yW3QrM10sZj1yW3QrNF0sZD1yW3QrNV0saD1yW3QrNl0scD1yW3QrN10sdj1yW3QrOF0seT1yW3QrOV0sbT1yW3QrMTBdLGc9clt0KzExXSxrPXJbdCsxMl0sYj1yW3QrMTNdLF89clt0KzE0XSx3PXJbdCsxNV0seD1zWzBdLFM9c1sxXSxBPXNbMl0sRD1zWzNdO3g9TGUoeCxTLEEsRCxvLDcsUmVbMF0pLEQ9TGUoRCx4LFMsQSx1LDEyLFJlWzFdKSxBPUxlKEEsRCx4LFMsYywxNyxSZVsyXSksUz1MZShTLEEsRCx4LGwsMjIsUmVbM10pLHg9TGUoeCxTLEEsRCxmLDcsUmVbNF0pLEQ9TGUoRCx4LFMsQSxkLDEyLFJlWzVdKSxBPUxlKEEsRCx4LFMsaCwxNyxSZVs2XSksUz1MZShTLEEsRCx4LHAsMjIsUmVbN10pLHg9TGUoeCxTLEEsRCx2LDcsUmVbOF0pLEQ9TGUoRCx4LFMsQSx5LDEyLFJlWzldKSxBPUxlKEEsRCx4LFMsbSwxNyxSZVsxMF0pLFM9TGUoUyxBLEQseCxnLDIyLFJlWzExXSkseD1MZSh4LFMsQSxELGssNyxSZVsxMl0pLEQ9TGUoRCx4LFMsQSxiLDEyLFJlWzEzXSksQT1MZShBLEQseCxTLF8sMTcsUmVbMTRdKSxTPUxlKFMsQSxELHgsdywyMixSZVsxNV0pLHg9VmUoeCxTLEEsRCx1LDUsUmVbMTZdKSxEPVZlKEQseCxTLEEsaCw5LFJlWzE3XSksQT1WZShBLEQseCxTLGcsMTQsUmVbMThdKSxTPVZlKFMsQSxELHgsbywyMCxSZVsxOV0pLHg9VmUoeCxTLEEsRCxkLDUsUmVbMjBdKSxEPVZlKEQseCxTLEEsbSw5LFJlWzIxXSksQT1WZShBLEQseCxTLHcsMTQsUmVbMjJdKSxTPVZlKFMsQSxELHgsZiwyMCxSZVsyM10pLHg9VmUoeCxTLEEsRCx5LDUsUmVbMjRdKSxEPVZlKEQseCxTLEEsXyw5LFJlWzI1XSksQT1WZShBLEQseCxTLGwsMTQsUmVbMjZdKSxTPVZlKFMsQSxELHgsdiwyMCxSZVsyN10pLHg9VmUoeCxTLEEsRCxiLDUsUmVbMjhdKSxEPVZlKEQseCxTLEEsYyw5LFJlWzI5XSksQT1WZShBLEQseCxTLHAsMTQsUmVbMzBdKSxTPVZlKFMsQSxELHgsaywyMCxSZVszMV0pLHg9RmUoeCxTLEEsRCxkLDQsUmVbMzJdKSxEPUZlKEQseCxTLEEsdiwxMSxSZVszM10pLEE9RmUoQSxELHgsUyxnLDE2LFJlWzM0XSksUz1GZShTLEEsRCx4LF8sMjMsUmVbMzVdKSx4PUZlKHgsUyxBLEQsdSw0LFJlWzM2XSksRD1GZShELHgsUyxBLGYsMTEsUmVbMzddKSxBPUZlKEEsRCx4LFMscCwxNixSZVszOF0pLFM9RmUoUyxBLEQseCxtLDIzLFJlWzM5XSkseD1GZSh4LFMsQSxELGIsNCxSZVs0MF0pLEQ9RmUoRCx4LFMsQSxvLDExLFJlWzQxXSksQT1GZShBLEQseCxTLGwsMTYsUmVbNDJdKSxTPUZlKFMsQSxELHgsaCwyMyxSZVs0M10pLHg9RmUoeCxTLEEsRCx5LDQsUmVbNDRdKSxEPUZlKEQseCxTLEEsaywxMSxSZVs0NV0pLEE9RmUoQSxELHgsUyx3LDE2LFJlWzQ2XSksUz1GZShTLEEsRCx4LGMsMjMsUmVbNDddKSx4PU5lKHgsUyxBLEQsbyw2LFJlWzQ4XSksRD1OZShELHgsUyxBLHAsMTAsUmVbNDldKSxBPU5lKEEsRCx4LFMsXywxNSxSZVs1MF0pLFM9TmUoUyxBLEQseCxkLDIxLFJlWzUxXSkseD1OZSh4LFMsQSxELGssNixSZVs1Ml0pLEQ9TmUoRCx4LFMsQSxsLDEwLFJlWzUzXSksQT1OZShBLEQseCxTLG0sMTUsUmVbNTRdKSxTPU5lKFMsQSxELHgsdSwyMSxSZVs1NV0pLHg9TmUoeCxTLEEsRCx2LDYsUmVbNTZdKSxEPU5lKEQseCxTLEEsdywxMCxSZVs1N10pLEE9TmUoQSxELHgsUyxoLDE1LFJlWzU4XSksUz1OZShTLEEsRCx4LGIsMjEsUmVbNTldKSx4PU5lKHgsUyxBLEQsZiw2LFJlWzYwXSksRD1OZShELHgsUyxBLGcsMTAsUmVbNjFdKSxBPU5lKEEsRCx4LFMsYywxNSxSZVs2Ml0pLFM9TmUoUyxBLEQseCx5LDIxLFJlWzYzXSksc1swXT1zWzBdK3h8MCxzWzFdPXNbMV0rU3wwLHNbMl09c1syXStBfDAsc1szXT1zWzNdK0R8MH19LHtrZXk6Il9kb0ZpbmFsaXplIix2YWx1ZTpmdW5jdGlvbigpe3ZhciBlPXRoaXMuX2RhdGEsdD1lLndvcmRzLHI9OCp0aGlzLl9uRGF0YUJ5dGVzLGE9OCplLnNpZ0J5dGVzO3RbYT4+PjVdfD0xMjg8PDI0LWElMzI7dmFyIG49TWF0aC5mbG9vcihyLzQyOTQ5NjcyOTYpLGk9cjt0WzE1KyhhKzY0Pj4+OTw8NCldPTE2NzExOTM1JihuPDw4fG4+Pj4yNCl8NDI3ODI1NTM2MCYobjw8MjR8bj4+PjgpLHRbMTQrKGErNjQ+Pj45PDw0KV09MTY3MTE5MzUmKGk8PDh8aT4+PjI0KXw0Mjc4MjU1MzYwJihpPDwyNHxpPj4+OCksZS5zaWdCeXRlcz00Kih0Lmxlbmd0aCsxKSx0aGlzLl9wcm9jZXNzKCk7Zm9yKHZhciBzPXRoaXMuX2hhc2gsbz1zLndvcmRzLHU9MDt1PDQ7dSs9MSl7dmFyIGM9b1t1XTtvW3VdPTE2NzExOTM1JihjPDw4fGM+Pj4yNCl8NDI3ODI1NTM2MCYoYzw8MjR8Yz4+PjgpfXJldHVybiBzfX0se2tleToiY2xvbmUiLHZhbHVlOmZ1bmN0aW9uKCl7dmFyIGU9cChvKGEucHJvdG90eXBlKSwiY2xvbmUiLHRoaXMpLmNhbGwodGhpcyk7cmV0dXJuIGUuX2hhc2g9dGhpcy5faGFzaC5jbG9uZSgpLGV9fV0pLGF9KEllKTtJZS5fY3JlYXRlSGVscGVyKGplKSxJZS5fY3JlYXRlSG1hY0hlbHBlcihqZSk7dmFyIEdlPWZ1bmN0aW9uKGUpe3MoYSxlKTt2YXIgdD1kKGEpO2Z1bmN0aW9uIGEoZSl7dmFyIG47cmV0dXJuIHIodGhpcyxhKSwobj10LmNhbGwodGhpcykpLmNmZz1PYmplY3QuYXNzaWduKG5ldyBFZSx7a2V5U2l6ZTo0LGhhc2hlcjpqZSxpdGVyYXRpb25zOjF9LGUpLG59cmV0dXJuIG4oYSxbe2tleToiY29tcHV0ZSIsdmFsdWU6ZnVuY3Rpb24oZSx0KXtmb3IodmFyIHIsYT10aGlzLmNmZyxuPWEuaGFzaGVyLmNyZWF0ZSgpLGk9QmUuY3JlYXRlKCkscz1pLndvcmRzLG89YS5rZXlTaXplLHU9YS5pdGVyYXRpb25zO3MubGVuZ3RoPG87KXtyJiZuLnVwZGF0ZShyKSxyPW4udXBkYXRlKGUpLmZpbmFsaXplKHQpLG4ucmVzZXQoKTtmb3IodmFyIGM9MTtjPHU7Yys9MSlyPW4uZmluYWxpemUociksbi5yZXNldCgpO2kuY29uY2F0KHIpfXJldHVybiBpLnNpZ0J5dGVzPTQqbyxpfX1dKSxhfShFZSksSGU9ZnVuY3Rpb24oZSl7cyhhLGUpO3ZhciB0PWQoYSk7ZnVuY3Rpb24gYShlLG4saSl7dmFyIHM7cmV0dXJuIHIodGhpcyxhKSwocz10LmNhbGwodGhpcykpLmNmZz1PYmplY3QuYXNzaWduKG5ldyBFZSxpKSxzLl94Zm9ybU1vZGU9ZSxzLl9rZXk9bixzLnJlc2V0KCksc31yZXR1cm4gbihhLFt7a2V5OiJyZXNldCIsdmFsdWU6ZnVuY3Rpb24oKXtwKG8oYS5wcm90b3R5cGUpLCJyZXNldCIsdGhpcykuY2FsbCh0aGlzKSx0aGlzLl9kb1Jlc2V0KCl9fSx7a2V5OiJwcm9jZXNzIix2YWx1ZTpmdW5jdGlvbihlKXtyZXR1cm4gdGhpcy5fYXBwZW5kKGUpLHRoaXMuX3Byb2Nlc3MoKX19LHtrZXk6ImZpbmFsaXplIix2YWx1ZTpmdW5jdGlvbihlKXtyZXR1cm4gZSYmdGhpcy5fYXBwZW5kKGUpLHRoaXMuX2RvRmluYWxpemUoKX19XSxbe2tleToiY3JlYXRlRW5jcnlwdG9yIix2YWx1ZTpmdW5jdGlvbihlLHQpe3JldHVybiB0aGlzLmNyZWF0ZSh0aGlzLl9FTkNfWEZPUk1fTU9ERSxlLHQpfX0se2tleToiY3JlYXRlRGVjcnlwdG9yIix2YWx1ZTpmdW5jdGlvbihlLHQpe3JldHVybiB0aGlzLmNyZWF0ZSh0aGlzLl9ERUNfWEZPUk1fTU9ERSxlLHQpfX0se2tleToiX2NyZWF0ZUhlbHBlciIsdmFsdWU6ZnVuY3Rpb24oZSl7dmFyIHQ9ZnVuY3Rpb24oZSl7cmV0dXJuInN0cmluZyI9PXR5cGVvZiBlP2V0OkplfTtyZXR1cm57ZW5jcnlwdDpmdW5jdGlvbihyLGEsbil7cmV0dXJuIHQoYSkuZW5jcnlwdChlLHIsYSxuKX0sZGVjcnlwdDpmdW5jdGlvbihyLGEsbil7cmV0dXJuIHQoYSkuZGVjcnlwdChlLHIsYSxuKX19fX1dKSxhfShQZSk7SGUuX0VOQ19YRk9STV9NT0RFPTEsSGUuX0RFQ19YRk9STV9NT0RFPTIsSGUua2V5U2l6ZT00LEhlLml2U2l6ZT00O3ZhciBLZT1mdW5jdGlvbihlKXtzKGEsZSk7dmFyIHQ9ZChhKTtmdW5jdGlvbiBhKGUsbil7dmFyIGk7cmV0dXJuIHIodGhpcyxhKSwoaT10LmNhbGwodGhpcykpLl9jaXBoZXI9ZSxpLl9pdj1uLGl9cmV0dXJuIG4oYSxudWxsLFt7a2V5OiJjcmVhdGVFbmNyeXB0b3IiLHZhbHVlOmZ1bmN0aW9uKGUsdCl7cmV0dXJuIHRoaXMuRW5jcnlwdG9yLmNyZWF0ZShlLHQpfX0se2tleToiY3JlYXRlRGVjcnlwdG9yIix2YWx1ZTpmdW5jdGlvbihlLHQpe3JldHVybiB0aGlzLkRlY3J5cHRvci5jcmVhdGUoZSx0KX19XSksYX0oRWUpO2Z1bmN0aW9uIHFlKGUsdCxyKXt2YXIgYSxuPWUsaT10aGlzLl9pdjtpPyhhPWksdGhpcy5faXY9dm9pZCAwKTphPXRoaXMuX3ByZXZCbG9jaztmb3IodmFyIHM9MDtzPHI7cys9MSluW3Qrc11ePWFbc119dmFyIFdlPWZ1bmN0aW9uKGUpe3MoYSxlKTt2YXIgdD1kKGEpO2Z1bmN0aW9uIGEoKXtyZXR1cm4gcih0aGlzLGEpLHQuYXBwbHkodGhpcyxhcmd1bWVudHMpfXJldHVybiBuKGEpfShLZSk7V2UuRW5jcnlwdG9yPWZ1bmN0aW9uKGUpe3MoYSxlKTt2YXIgdD1kKGEpO2Z1bmN0aW9uIGEoKXtyZXR1cm4gcih0aGlzLGEpLHQuYXBwbHkodGhpcyxhcmd1bWVudHMpfXJldHVybiBuKGEsW3trZXk6InByb2Nlc3NCbG9jayIsdmFsdWU6ZnVuY3Rpb24oZSx0KXt2YXIgcj10aGlzLl9jaXBoZXIsYT1yLmJsb2NrU2l6ZTtxZS5jYWxsKHRoaXMsZSx0LGEpLHIuZW5jcnlwdEJsb2NrKGUsdCksdGhpcy5fcHJldkJsb2NrPWUuc2xpY2UodCx0K2EpfX1dKSxhfShXZSksV2UuRGVjcnlwdG9yPWZ1bmN0aW9uKGUpe3MoYSxlKTt2YXIgdD1kKGEpO2Z1bmN0aW9uIGEoKXtyZXR1cm4gcih0aGlzLGEpLHQuYXBwbHkodGhpcyxhcmd1bWVudHMpfXJldHVybiBuKGEsW3trZXk6InByb2Nlc3NCbG9jayIsdmFsdWU6ZnVuY3Rpb24oZSx0KXt2YXIgcj10aGlzLl9jaXBoZXIsYT1yLmJsb2NrU2l6ZSxuPWUuc2xpY2UodCx0K2EpO3IuZGVjcnlwdEJsb2NrKGUsdCkscWUuY2FsbCh0aGlzLGUsdCxhKSx0aGlzLl9wcmV2QmxvY2s9bn19XSksYX0oV2UpO3ZhciBYZT17cGFkOmZ1bmN0aW9uKGUsdCl7Zm9yKHZhciByPTQqdCxhPXItZS5zaWdCeXRlcyVyLG49YTw8MjR8YTw8MTZ8YTw8OHxhLGk9W10scz0wO3M8YTtzKz00KWkucHVzaChuKTt2YXIgbz1CZS5jcmVhdGUoaSxhKTtlLmNvbmNhdChvKX0sdW5wYWQ6ZnVuY3Rpb24oZSl7dmFyIHQ9ZSxyPTI1NSZ0LndvcmRzW3Quc2lnQnl0ZXMtMT4+PjJdO3Quc2lnQnl0ZXMtPXJ9fSxZZT1mdW5jdGlvbihlKXtzKGEsZSk7dmFyIHQ9ZChhKTtmdW5jdGlvbiBhKGUsbixpKXt2YXIgcztyZXR1cm4gcih0aGlzLGEpLChzPXQuY2FsbCh0aGlzLGUsbixPYmplY3QuYXNzaWduKHttb2RlOldlLHBhZGRpbmc6WGV9LGkpKSkuYmxvY2tTaXplPTQsc31yZXR1cm4gbihhLFt7a2V5OiJyZXNldCIsdmFsdWU6ZnVuY3Rpb24oKXt2YXIgZTtwKG8oYS5wcm90b3R5cGUpLCJyZXNldCIsdGhpcykuY2FsbCh0aGlzKTt2YXIgdD10aGlzLmNmZyxyPXQuaXYsbj10Lm1vZGU7dGhpcy5feGZvcm1Nb2RlPT09dGhpcy5jb25zdHJ1Y3Rvci5fRU5DX1hGT1JNX01PREU/ZT1uLmNyZWF0ZUVuY3J5cHRvcjooZT1uLmNyZWF0ZURlY3J5cHRvcix0aGlzLl9taW5CdWZmZXJTaXplPTEpLHRoaXMuX21vZGU9ZS5jYWxsKG4sdGhpcyxyJiZyLndvcmRzKSx0aGlzLl9tb2RlLl9fY3JlYXRvcj1lfX0se2tleToiX2RvUHJvY2Vzc0Jsb2NrIix2YWx1ZTpmdW5jdGlvbihlLHQpe3RoaXMuX21vZGUucHJvY2Vzc0Jsb2NrKGUsdCl9fSx7a2V5OiJfZG9GaW5hbGl6ZSIsdmFsdWU6ZnVuY3Rpb24oKXt2YXIgZSx0PXRoaXMuY2ZnLnBhZGRpbmc7cmV0dXJuIHRoaXMuX3hmb3JtTW9kZT09PXRoaXMuY29uc3RydWN0b3IuX0VOQ19YRk9STV9NT0RFPyh0LnBhZCh0aGlzLl9kYXRhLHRoaXMuYmxvY2tTaXplKSxlPXRoaXMuX3Byb2Nlc3MoITApKTooZT10aGlzLl9wcm9jZXNzKCEwKSx0LnVucGFkKGUpKSxlfX1dKSxhfShIZSksWmU9ZnVuY3Rpb24oZSl7cyhhLGUpO3ZhciB0PWQoYSk7ZnVuY3Rpb24gYShlKXt2YXIgbjtyZXR1cm4gcih0aGlzLGEpLChuPXQuY2FsbCh0aGlzKSkubWl4SW4oZSksbn1yZXR1cm4gbihhLFt7a2V5OiJ0b1N0cmluZyIsdmFsdWU6ZnVuY3Rpb24oZSl7cmV0dXJuKGV8fHRoaXMuZm9ybWF0dGVyKS5zdHJpbmdpZnkodGhpcyl9fV0pLGF9KEVlKSxRZT17c3RyaW5naWZ5OmZ1bmN0aW9uKGUpe3ZhciB0PWUuY2lwaGVydGV4dCxyPWUuc2FsdDtyZXR1cm4ocj9CZS5jcmVhdGUoWzEzOTg4OTM2ODQsMTcwMTA3NjgzMV0pLmNvbmNhdChyKS5jb25jYXQodCk6dCkudG9TdHJpbmcoTWUpfSxwYXJzZTpmdW5jdGlvbihlKXt2YXIgdCxyPU1lLnBhcnNlKGUpLGE9ci53b3JkcztyZXR1cm4gMTM5ODg5MzY4ND09PWFbMF0mJjE3MDEwNzY4MzE9PT1hWzFdJiYodD1CZS5jcmVhdGUoYS5zbGljZSgyLDQpKSxhLnNwbGljZSgwLDQpLHIuc2lnQnl0ZXMtPTE2KSxaZS5jcmVhdGUoe2NpcGhlcnRleHQ6cixzYWx0OnR9KX19LEplPWZ1bmN0aW9uKGUpe3MoYSxlKTt2YXIgdD1kKGEpO2Z1bmN0aW9uIGEoKXtyZXR1cm4gcih0aGlzLGEpLHQuYXBwbHkodGhpcyxhcmd1bWVudHMpfXJldHVybiBuKGEsbnVsbCxbe2tleToiZW5jcnlwdCIsdmFsdWU6ZnVuY3Rpb24oZSx0LHIsYSl7dmFyIG49T2JqZWN0LmFzc2lnbihuZXcgRWUsdGhpcy5jZmcsYSksaT1lLmNyZWF0ZUVuY3J5cHRvcihyLG4pLHM9aS5maW5hbGl6ZSh0KSxvPWkuY2ZnO3JldHVybiBaZS5jcmVhdGUoe2NpcGhlcnRleHQ6cyxrZXk6cixpdjpvLml2LGFsZ29yaXRobTplLG1vZGU6by5tb2RlLHBhZGRpbmc6by5wYWRkaW5nLGJsb2NrU2l6ZTppLmJsb2NrU2l6ZSxmb3JtYXR0ZXI6bi5mb3JtYXR9KX19LHtrZXk6ImRlY3J5cHQiLHZhbHVlOmZ1bmN0aW9uKGUsdCxyLGEpe3ZhciBuPXQsaT1PYmplY3QuYXNzaWduKG5ldyBFZSx0aGlzLmNmZyxhKTtyZXR1cm4gbj10aGlzLl9wYXJzZShuLGkuZm9ybWF0KSxlLmNyZWF0ZURlY3J5cHRvcihyLGkpLmZpbmFsaXplKG4uY2lwaGVydGV4dCl9fSx7a2V5OiJfcGFyc2UiLHZhbHVlOmZ1bmN0aW9uKGUsdCl7cmV0dXJuInN0cmluZyI9PXR5cGVvZiBlP3QucGFyc2UoZSx0aGlzKTplfX1dKSxhfShFZSk7SmUuY2ZnPU9iamVjdC5hc3NpZ24obmV3IEVlLHtmb3JtYXQ6UWV9KTt2YXIgJGU9e2V4ZWN1dGU6ZnVuY3Rpb24oZSx0LHIsYSl7dmFyIG49YTtufHwobj1CZS5yYW5kb20oOCkpO3ZhciBpPUdlLmNyZWF0ZSh7a2V5U2l6ZTp0K3J9KS5jb21wdXRlKGUsbikscz1CZS5jcmVhdGUoaS53b3Jkcy5zbGljZSh0KSw0KnIpO3JldHVybiBpLnNpZ0J5dGVzPTQqdCxaZS5jcmVhdGUoe2tleTppLGl2OnMsc2FsdDpufSl9fSxldD1mdW5jdGlvbihlKXtzKGEsZSk7dmFyIHQ9ZChhKTtmdW5jdGlvbiBhKCl7cmV0dXJuIHIodGhpcyxhKSx0LmFwcGx5KHRoaXMsYXJndW1lbnRzKX1yZXR1cm4gbihhLG51bGwsW3trZXk6ImVuY3J5cHQiLHZhbHVlOmZ1bmN0aW9uKGUsdCxyLGEpe3ZhciBuPU9iamVjdC5hc3NpZ24obmV3IEVlLHRoaXMuY2ZnLGEpLGk9bi5rZGYuZXhlY3V0ZShyLGUua2V5U2l6ZSxlLml2U2l6ZSk7bi5pdj1pLml2O3ZhciBzPUplLmVuY3J5cHQuY2FsbCh0aGlzLGUsdCxpLmtleSxuKTtyZXR1cm4gcy5taXhJbihpKSxzfX0se2tleToiZGVjcnlwdCIsdmFsdWU6ZnVuY3Rpb24oZSx0LHIsYSl7dmFyIG49dCxpPU9iamVjdC5hc3NpZ24obmV3IEVlLHRoaXMuY2ZnLGEpO249dGhpcy5fcGFyc2UobixpLmZvcm1hdCk7dmFyIHM9aS5rZGYuZXhlY3V0ZShyLGUua2V5U2l6ZSxlLml2U2l6ZSxuLnNhbHQpO3JldHVybiBpLml2PXMuaXYsSmUuZGVjcnlwdC5jYWxsKHRoaXMsZSxuLHMua2V5LGkpfX1dKSxhfShKZSk7ZXQuY2ZnPU9iamVjdC5hc3NpZ24oSmUuY2ZnLHtrZGY6JGV9KTtmb3IodmFyIHR0PVtdLHJ0PVtdLGF0PVtdLG50PVtdLGl0PVtdLHN0PVtdLG90PVtdLHV0PVtdLGN0PVtdLGx0PVtdLGZ0PVtdLGR0PTA7ZHQ8MjU2O2R0Kz0xKWZ0W2R0XT1kdDwxMjg/ZHQ8PDE6ZHQ8PDFeMjgzO2Zvcih2YXIgaHQ9MCxwdD0wLHZ0PTA7dnQ8MjU2O3Z0Kz0xKXt2YXIgeXQ9cHRecHQ8PDFecHQ8PDJecHQ8PDNecHQ8PDQ7eXQ9eXQ+Pj44XjI1NSZ5dF45OSx0dFtodF09eXQscnRbeXRdPWh0O3ZhciBtdD1mdFtodF0sZ3Q9ZnRbbXRdLGt0PWZ0W2d0XSxidD0yNTcqZnRbeXRdXjE2ODQzMDA4Knl0O2F0W2h0XT1idDw8MjR8YnQ+Pj44LG50W2h0XT1idDw8MTZ8YnQ+Pj4xNixpdFtodF09YnQ8PDh8YnQ+Pj4yNCxzdFtodF09YnQsYnQ9MTY4NDMwMDkqa3ReNjU1MzcqZ3ReMjU3Km10XjE2ODQzMDA4Kmh0LG90W3l0XT1idDw8MjR8YnQ+Pj44LHV0W3l0XT1idDw8MTZ8YnQ+Pj4xNixjdFt5dF09YnQ8PDh8YnQ+Pj4yNCxsdFt5dF09YnQsaHQ/KGh0PW10XmZ0W2Z0W2Z0W2t0Xm10XV1dLHB0Xj1mdFtmdFtwdF1dKTpodD1wdD0xfXZhciBfdD1bMCwxLDIsNCw4LDE2LDMyLDY0LDEyOCwyNyw1NF0sd3Q9ZnVuY3Rpb24oZSl7cyhhLGUpO3ZhciB0PWQoYSk7ZnVuY3Rpb24gYSgpe3JldHVybiByKHRoaXMsYSksdC5hcHBseSh0aGlzLGFyZ3VtZW50cyl9cmV0dXJuIG4oYSxbe2tleToiX2RvUmVzZXQiLHZhbHVlOmZ1bmN0aW9uKCl7dmFyIGU7aWYoIXRoaXMuX25Sb3VuZHN8fHRoaXMuX2tleVByaW9yUmVzZXQhPT10aGlzLl9rZXkpe3RoaXMuX2tleVByaW9yUmVzZXQ9dGhpcy5fa2V5O3ZhciB0PXRoaXMuX2tleVByaW9yUmVzZXQscj10LndvcmRzLGE9dC5zaWdCeXRlcy80O3RoaXMuX25Sb3VuZHM9YSs2O3ZhciBuPTQqKHRoaXMuX25Sb3VuZHMrMSk7dGhpcy5fa2V5U2NoZWR1bGU9W107Zm9yKHZhciBpPXRoaXMuX2tleVNjaGVkdWxlLHM9MDtzPG47cys9MSlzPGE/aVtzXT1yW3NdOihlPWlbcy0xXSxzJWE/YT42JiZzJWE9PTQmJihlPXR0W2U+Pj4yNF08PDI0fHR0W2U+Pj4xNiYyNTVdPDwxNnx0dFtlPj4+OCYyNTVdPDw4fHR0WzI1NSZlXSk6KGU9dHRbKGU9ZTw8OHxlPj4+MjQpPj4+MjRdPDwyNHx0dFtlPj4+MTYmMjU1XTw8MTZ8dHRbZT4+PjgmMjU1XTw8OHx0dFsyNTUmZV0sZV49X3Rbcy9hfDBdPDwyNCksaVtzXT1pW3MtYV1eZSk7dGhpcy5faW52S2V5U2NoZWR1bGU9W107Zm9yKHZhciBvPXRoaXMuX2ludktleVNjaGVkdWxlLHU9MDt1PG47dSs9MSl7dmFyIGM9bi11O2U9dSU0P2lbY106aVtjLTRdLG9bdV09dTw0fHxjPD00P2U6b3RbdHRbZT4+PjI0XV1edXRbdHRbZT4+PjE2JjI1NV1dXmN0W3R0W2U+Pj44JjI1NV1dXmx0W3R0WzI1NSZlXV19fX19LHtrZXk6ImVuY3J5cHRCbG9jayIsdmFsdWU6ZnVuY3Rpb24oZSx0KXt0aGlzLl9kb0NyeXB0QmxvY2soZSx0LHRoaXMuX2tleVNjaGVkdWxlLGF0LG50LGl0LHN0LHR0KX19LHtrZXk6ImRlY3J5cHRCbG9jayIsdmFsdWU6ZnVuY3Rpb24oZSx0KXt2YXIgcj1lLGE9clt0KzFdO3JbdCsxXT1yW3QrM10sclt0KzNdPWEsdGhpcy5fZG9DcnlwdEJsb2NrKHIsdCx0aGlzLl9pbnZLZXlTY2hlZHVsZSxvdCx1dCxjdCxsdCxydCksYT1yW3QrMV0sclt0KzFdPXJbdCszXSxyW3QrM109YX19LHtrZXk6Il9kb0NyeXB0QmxvY2siLHZhbHVlOmZ1bmN0aW9uKGUsdCxyLGEsbixpLHMsbyl7Zm9yKHZhciB1PWUsYz10aGlzLl9uUm91bmRzLGw9dVt0XV5yWzBdLGY9dVt0KzFdXnJbMV0sZD11W3QrMl1eclsyXSxoPXVbdCszXV5yWzNdLHA9NCx2PTE7djxjO3YrPTEpe3ZhciB5PWFbbD4+PjI0XV5uW2Y+Pj4xNiYyNTVdXmlbZD4+PjgmMjU1XV5zWzI1NSZoXV5yW3BdO3ArPTE7dmFyIG09YVtmPj4+MjRdXm5bZD4+PjE2JjI1NV1eaVtoPj4+OCYyNTVdXnNbMjU1JmxdXnJbcF07cCs9MTt2YXIgZz1hW2Q+Pj4yNF1ebltoPj4+MTYmMjU1XV5pW2w+Pj44JjI1NV1ec1syNTUmZl1ecltwXTtwKz0xO3ZhciBrPWFbaD4+PjI0XV5uW2w+Pj4xNiYyNTVdXmlbZj4+PjgmMjU1XV5zWzI1NSZkXV5yW3BdO3ArPTEsbD15LGY9bSxkPWcsaD1rfXZhciBiPShvW2w+Pj4yNF08PDI0fG9bZj4+PjE2JjI1NV08PDE2fG9bZD4+PjgmMjU1XTw8OHxvWzI1NSZoXSlecltwXTtwKz0xO3ZhciBfPShvW2Y+Pj4yNF08PDI0fG9bZD4+PjE2JjI1NV08PDE2fG9baD4+PjgmMjU1XTw8OHxvWzI1NSZsXSlecltwXTtwKz0xO3ZhciB3PShvW2Q+Pj4yNF08PDI0fG9baD4+PjE2JjI1NV08PDE2fG9bbD4+PjgmMjU1XTw8OHxvWzI1NSZmXSlecltwXTtwKz0xO3ZhciB4PShvW2g+Pj4yNF08PDI0fG9bbD4+PjE2JjI1NV08PDE2fG9bZj4+PjgmMjU1XTw8OHxvWzI1NSZkXSlecltwXTtwKz0xLHVbdF09Yix1W3QrMV09Xyx1W3QrMl09dyx1W3QrM109eH19XSksYX0oWWUpO3d0LmtleVNpemU9ODt2YXIgeHQ9WWUuX2NyZWF0ZUhlbHBlcih3dCksU3Q9ZnVuY3Rpb24oZSl7cyhhLGUpO3ZhciB0PWQoYSk7ZnVuY3Rpb24gYSgpe3JldHVybiByKHRoaXMsYSksdC5hcHBseSh0aGlzLGFyZ3VtZW50cyl9cmV0dXJuIG4oYSl9KEtlKTtTdC5FbmNyeXB0b3I9ZnVuY3Rpb24oZSl7cyhhLGUpO3ZhciB0PWQoYSk7ZnVuY3Rpb24gYSgpe3JldHVybiByKHRoaXMsYSksdC5hcHBseSh0aGlzLGFyZ3VtZW50cyl9cmV0dXJuIG4oYSxbe2tleToicHJvY2Vzc0Jsb2NrIix2YWx1ZTpmdW5jdGlvbihlLHQpe3ZhciByPWUsYT10aGlzLl9jaXBoZXIsbj1hLmJsb2NrU2l6ZSxpPXRoaXMuX2l2LHM9dGhpcy5fY291bnRlcjtpJiYodGhpcy5fY291bnRlcj1pLnNsaWNlKDApLHM9dGhpcy5fY291bnRlcix0aGlzLl9pdj12b2lkIDApO3ZhciBvPXMuc2xpY2UoMCk7YS5lbmNyeXB0QmxvY2sobywwKSxzW24tMV09c1tuLTFdKzF8MDtmb3IodmFyIHU9MDt1PG47dSs9MSlyW3QrdV1ePW9bdV19fV0pLGF9KFN0KSxTdC5EZWNyeXB0b3I9U3QuRW5jcnlwdG9yO3ZhciBBdD17cGFkOmZ1bmN0aW9uKCl7fSx1bnBhZDpmdW5jdGlvbigpe319LER0PXtkZWNyeXB0V29yZEFycmF5OmZ1bmN0aW9uKGUsdCxyKXt2YXIgYT1UZS5wYXJzZSh0KSxuPVRlLnBhcnNlKHJlKHIpKSxpPUJlLmNyZWF0ZShuZXcgVWludDhBcnJheShlKSkscz14dC5kZWNyeXB0KFplLmNyZWF0ZSh7Y2lwaGVydGV4dDppfSksYSx7aXY6bixtb2RlOlN0LHBhZGRpbmc6QXR9KTtyZXR1cm4gRHQud29yZEFycmF5VG9VaW50OEFycmF5KHMpfSx3b3JkQXJyYXlUb1VpbnQ4QXJyYXk6ZnVuY3Rpb24oZSl7Zm9yKHZhciB0PWUuc2lnQnl0ZXMscj1lLndvcmRzLGE9bmV3IFVpbnQ4QXJyYXkodCksbj0wLGk9MDtuIT09dDspe3ZhciBzPXJbaSsrXTtpZihhW24rK109KDQyNzgxOTAwODAmcyk+Pj4yNCxuPT09dClicmVhaztpZihhW24rK109KDE2NzExNjgwJnMpPj4+MTYsbj09PXQpYnJlYWs7aWYoYVtuKytdPSg2NTI4MCZzKT4+Pjgsbj09PXQpYnJlYWs7YVtuKytdPTI1NSZzfXJldHVybiBhfSxkZWNvZGVyQUVTQ1RSRGF0YTpmdW5jdGlvbihlLHQscil7aWYoZS52aWRlb1NlbmMpe3ZhciBhPWUua2lkVmFsdWUsbj1lLnZpZGVvU2VuYztlLnNhbXBsZXMuZm9yRWFjaCgoZnVuY3Rpb24odCxpKXt2YXIgcz1uW2ldLG89dC5kYXRhLHU9W10sYz1bXSxsPXMuSW5pdGlhbGl6YXRpb25WZWN0b3I7aWYocy5zdWJzYW1wbGVzJiZzLnN1YnNhbXBsZXMubGVuZ3RoKXMuc3Vic2FtcGxlcy5mb3JFYWNoKChmdW5jdGlvbihlKXt2YXIgdD1lLkJ5dGVzT2ZDbGVhckRhdGErZS5CeXRlc09mUHJvdGVjdGVkRGF0YSxyPW8uc2xpY2UoMCx0KTt1LnB1c2goci5zbGljZSgwLGUuQnl0ZXNPZkNsZWFyRGF0YSkpLGMucHVzaChyLnNsaWNlKGUuQnl0ZXNPZkNsZWFyRGF0YSkpLG89by5zbGljZSh0KX0pKTtlbHNle3ZhciBmPXQuc2l6ZTt1LnB1c2goby5zbGljZSgwLDApKSxjLnB1c2goby5zbGljZSgwLGYpKSxvPW8uc2xpY2UoZil9dmFyIGQ9bmV3IHdlO2Qud3JpdGUuYXBwbHkoZCxjKTt2YXIgaD1yP3IoZC5idWZmZXIsYSxsKTpEdC5kZWNyeXB0V29yZEFycmF5KGQuYnVmZmVyLGEsbCkscD1uZXcgd2U7dS5mb3JFYWNoKChmdW5jdGlvbihlLHQpe3ZhciByPWNbdF0ubGVuZ3RoLGE9aC5zbGljZSgwLHIpO3Aud3JpdGUoZSkscC53cml0ZShhKSxoPWguc2xpY2Uocil9KSksZS5zYW1wbGVzW2ldLmRhdGE9cC5idWZmZXJ9KSl9aWYodC5hdWRpb1NlbmMpe3ZhciBpPXQua2lkVmFsdWUscz10LmF1ZGlvU2VuYzt0LnNhbXBsZXMuZm9yRWFjaCgoZnVuY3Rpb24oZSxhKXt2YXIgbj1zW2FdLG89cj9yKGUuZGF0YSxpLG4uSW5pdGlhbGl6YXRpb25WZWN0b3IpOkR0LmRlY3J5cHRXb3JkQXJyYXkoZS5kYXRhLGksbi5Jbml0aWFsaXphdGlvblZlY3Rvcik7dC5zYW1wbGVzW2FdLmRhdGE9b30pKX19fSxFdD1mdW5jdGlvbigpe2Z1bmN0aW9uIGUodCxhLG4scyl7dmFyIG89dGhpcztyKHRoaXMsZSksaSh0aGlzLCJfdmlkZW9TYW1wbGVzIixbXSksaSh0aGlzLCJfYXVkaW9TYW1wbGVzIixbXSksaSh0aGlzLCJfbGFzdFJlbWFpbkJ1ZmZlciIsW10pLGkodGhpcywiX2xhc3RSZW1haW5CdWZmZXJTdGFydFBvcyIsMCksdGhpcy52aWRlb1RyYWNrPW5ldyB6LHRoaXMuYXVkaW9UcmFjaz1uZXcgTSx0aGlzLm1ldGFkYXRhVHJhY2s9bnx8bmV3IE4sdGhpcy5sb2c9bmV3IEFlKCJNUDREZW11eGVyIiwhc3x8IXMub3BlbkxvZ3x8IXMub3BlbkxvZyksdCYmdC5mb3JFYWNoKChmdW5jdGlvbihlKXt2YXIgdDsodD1vLl92aWRlb1NhbXBsZXMpLnB1c2guYXBwbHkodCx5KGUuZnJhbWVzKSl9KSksYSYmYS5mb3JFYWNoKChmdW5jdGlvbihlKXt2YXIgdDsodD1vLl9hdWRpb1NhbXBsZXMpLnB1c2guYXBwbHkodCx5KGUuZnJhbWVzKSl9KSl9cmV0dXJuIG4oZSxbe2tleToicGFyc2VTYW1wbGVzIix2YWx1ZTpmdW5jdGlvbihlKXtpZighZSl0aHJvdyBuZXcgRXJyb3IoIm1vb3YgaXMgcmVxdWlyZWQiKTtpZih0aGlzLnZpZGVvVHJhY2suY29kZWN8fHRoaXMuYXVkaW9UcmFjay5jb2RlY3x8KHBlLm1vb3ZUb1RyYWNrKGUsdGhpcy52aWRlb1RyYWNrLHRoaXMuYXVkaW9UcmFjayksdGhpcy52aWRlb1NlbmM9dGhpcy52aWRlb1RyYWNrLnZpZGVvU2VuYyx0aGlzLmF1ZGlvU2VuYz10aGlzLmF1ZGlvVHJhY2suYXVkaW9TZW5jKSwhdGhpcy5fYXVkaW9TYW1wbGVzLmxlbmd0aCYmIXRoaXMuX3ZpZGVvU2FtcGxlcy5sZW5ndGgpe3ZhciB0PXBlLm1vb3ZUb1NhbXBsZXMoZSk7aWYoIXQpdGhyb3cgbmV3IEVycm9yKCJjYW5ub3QgcGFyc2Ugc2FtcGxlcyBmcm9tIG1vb3YgYm94Iik7dGhpcy5fdmlkZW9TYW1wbGVzPXQudmlkZW9TYW1wbGVzfHxbXSx0aGlzLl9hdWRpb1NhbXBsZXM9dC5hdWRpb1NhbXBsZXN8fFtdfX19LHtrZXk6ImRlbXV4Iix2YWx1ZTpmdW5jdGlvbihlLHQscixhLG4pe3RoaXMucGFyc2VTYW1wbGVzKG4pO3ZhciBpLHMsbyx1PXRoaXMudmlkZW9UcmFjayxjPXRoaXMuYXVkaW9UcmFjaztpZih1LnNhbXBsZXM9W10sYy5zYW1wbGVzPVtdLHIpe2Zvcih2YXIgbCxmPTAsZD1yWzBdLGg9clsxXTtkPD1oO2QrKyl7aWYoIShpPXRoaXMuX3ZpZGVvU2FtcGxlc1tkXSkpdGhyb3cgbmV3IEVycm9yKCJjYW5ub3QgZm91bmQgdmlkZW8gZnJhbWUgIyIuY29uY2F0KGQpKTtvPWkub2Zmc2V0LXQscz1lLnN1YmFycmF5KG8sbytpLnNpemUpLChsPW5ldyBSKGkucHRzfHxpLmR0cyxpLmR0cykpLmR1cmF0aW9uPWkuZHVyYXRpb24sbC5nb3BJZD1pLmdvcElkLGkua2V5ZnJhbWUmJmwuc2V0VG9LZXlmcmFtZSgpO2Zvcih2YXIgcD0wLHY9cy5sZW5ndGgtMTtwPHY7KWY9JChzLHApLHArPTQsbC51bml0cy5wdXNoKHMuc3ViYXJyYXkocCxwK2YpKSxwKz1mO3Uuc2FtcGxlcy5wdXNoKGwpfXUuYmFzZU1lZGlhRGVjb2RlVGltZT11LnNhbXBsZXNbMF0uZHRzfWlmKGEpe2Zvcih2YXIgeT1hWzBdLG09YVsxXTt5PD1tO3krKyl7aWYoIShpPXRoaXMuX2F1ZGlvU2FtcGxlc1t5XSkpdGhyb3cgbmV3IEVycm9yKCJjYW5ub3QgZm91bmQgdmlkZW8gZnJhbWUgIyIuY29uY2F0KHkpKTtvPWkub2Zmc2V0LXQscz1lLnN1YmFycmF5KG8sbytpLnNpemUpLGMuc2FtcGxlcy5wdXNoKG5ldyBPKGkuZHRzLHMsaS5kdXJhdGlvbikpfWMuYmFzZU1lZGlhRGVjb2RlVGltZT1jLnNhbXBsZXNbMF0uZHRzfXJldHVybnt2aWRlb1RyYWNrOnUsYXVkaW9UcmFjazpjLG1ldGFkYXRhVHJhY2s6dGhpcy5tZXRhZGF0YVRyYWNrfX19LHtrZXk6ImRlbXV4UGFydCIsdmFsdWU6ZnVuY3Rpb24oZSx0LHIsYSxuLGkscyxvKXtpZih0aGlzLnBhcnNlU2FtcGxlcyhuKSx0aGlzLnZpZGVvVHJhY2sudXNlRU1FPWksdGhpcy5hdWRpb1RyYWNrLnVzZUVNRT1pLHRoaXMuX2xhc3RSZW1haW5CdWZmZXImJnRoaXMuX2xhc3RSZW1haW5CdWZmZXIuYnl0ZUxlbmd0aD4wJiZ0PnRoaXMuX2xhc3RSZW1haW5CdWZmZXJTdGFydFBvcyYmdDw9dGhpcy5fbGFzdFJlbWFpbkJ1ZmZlclN0YXJ0UG9zK3RoaXMuX2xhc3RSZW1haW5CdWZmZXIuYnl0ZUxlbmd0aClmb3IodmFyIHU9MDt1PDIwOyl0cnl7dmFyIGM9dGhpcy5fbGFzdFJlbWFpbkJ1ZmZlci5zdWJhcnJheSgwLHQtdGhpcy5fbGFzdFJlbWFpbkJ1ZmZlclN0YXJ0UG9zKSxsPW5ldyBVaW50OEFycmF5KGUuYnl0ZUxlbmd0aCtjLmJ5dGVMZW5ndGgpO2wuc2V0KGMsMCksbC5zZXQobmV3IFVpbnQ4QXJyYXkoZSksYy5ieXRlTGVuZ3RoKSxlPWwsdC09Yy5ieXRlTGVuZ3RoLHRoaXMuX2xhc3RSZW1haW5CdWZmZXI9bnVsbCx0aGlzLl9sYXN0UmVtYWluQnVmZmVyU3RhcnRQb3M9MDticmVha31jYXRjaChFKXtpZighKHU8MjApKXRocm93IG5ldyBFcnJvcigibmV3IFVpbnQ4QXJyYXkgZXJyb3I6LCIrRS5lcnJvck1lc3NhZ2UpO3UrK312YXIgZixkLGgscD10aGlzLnZpZGVvVHJhY2ssdj10aGlzLmF1ZGlvVHJhY2s7cC5zYW1wbGVzPVtdLHYuc2FtcGxlcz1bXSxwLnZpZGVvU2VuYz1udWxsLHYuYXVkaW9TZW5jPW51bGw7dmFyIHk9MCxtPTA7aWYodGhpcy5fdmlkZW9TYW1wbGVzLmxlbmd0aD4wJiZyLmxlbmd0aD4wKXtmb3IodmFyIGcsaz1lLmJ5dGVMZW5ndGgrdCxiPXJbMF07Yjw9clsxXTtiKyspe2lmKCEoZj10aGlzLl92aWRlb1NhbXBsZXNbYl0pKXRocm93IG5ldyBFcnJvcigiY2Fubm90IGZvdW5kIHZpZGVvIGZyYW1lICMiLmNvbmNhdChiKSk7Zi5vZmZzZXQ+PXQmJmYub2Zmc2V0K2Yuc2l6ZTw9ayYmKHk9KGg9Zi5vZmZzZXQtdCkrZi5zaXplLGQ9ZS5zdWJhcnJheShoLHkpLChnPW5ldyBSKGYucHRzfHxmLmR0cyxmLmR0cykpLmR1cmF0aW9uPWYuZHVyYXRpb24sZy5nb3BJZD1mLmdvcElkLGcuc2FtcGxlT2Zmc2V0PWYuaW5kZXgsZi5rZXlmcmFtZSYmZy5zZXRUb0tleWZyYW1lKCksZy5kYXRhPWQsZy5zaXplPWYuc2l6ZSxwLnNhbXBsZXMucHVzaChnKSl9cC5zYW1wbGVzLmxlbmd0aD4wJiYocC5nb3BJZD1wLnNhbXBsZXNbMF0uZ29wSWQscC5iYXNlTWVkaWFEZWNvZGVUaW1lPXAuc2FtcGxlc1swXS5kdHMscC5zdGFydFB0cz1wLnNhbXBsZXNbMF0ucHRzL3AudGltZXNjYWxlLHAuZW5kUHRzPXAuc2FtcGxlc1twLnNhbXBsZXMubGVuZ3RoLTFdLnB0cy9wLnRpbWVzY2FsZSx0aGlzLnZpZGVvU2VuYyYmKHAudmlkZW9TZW5jPXRoaXMudmlkZW9TZW5jLnNsaWNlKHAuc2FtcGxlc1swXS5zYW1wbGVPZmZzZXQscC5zYW1wbGVzWzBdLnNhbXBsZU9mZnNldCtwLnNhbXBsZXMubGVuZ3RoKSxwLmtpZFZhbHVlPXMpKX1pZih0aGlzLl9hdWRpb1NhbXBsZXMubGVuZ3RoPjAmJmEubGVuZ3RoPjApe2Zvcih2YXIgXz1hWzBdO188PWFbMV07XysrKXtpZighKGY9dGhpcy5fYXVkaW9TYW1wbGVzW19dKSl0aHJvdyBuZXcgRXJyb3IoImNhbm5vdCBmb3VuZCB2aWRlbyBmcmFtZSAjIi5jb25jYXQoXykpO2Yub2Zmc2V0Pj10JiZmLm9mZnNldCtmLnNpemU8PWUuYnl0ZUxlbmd0aCt0JiYobT0oaD1mLm9mZnNldC10KStmLnNpemUsZD1lLnN1YmFycmF5KGgsbSksdi5zYW1wbGVzLnB1c2gobmV3IE8oZi5kdHMsZCxmLmR1cmF0aW9uLGYuaW5kZXgpKSl9di5zYW1wbGVzLmxlbmd0aD4wJiYodi5nb3BJZD12LnNhbXBsZXNbMF0uZ29wSWR8fHAuZ29wSWQsdi5iYXNlTWVkaWFEZWNvZGVUaW1lPXYuc2FtcGxlc1swXS5kdHMsdi5zdGFydFB0cz12LnNhbXBsZXNbMF0ucHRzL3YudGltZXNjYWxlLHYuZW5kUHRzPXYuc2FtcGxlc1t2LnNhbXBsZXMubGVuZ3RoLTFdLnB0cy92LnRpbWVzY2FsZSx0aGlzLmF1ZGlvU2VuYyYmKHYuYXVkaW9TZW5jPXRoaXMuYXVkaW9TZW5jLnNsaWNlKHYuc2FtcGxlc1swXS5zYW1wbGVPZmZzZXQsdi5zYW1wbGVzWzBdLnNhbXBsZU9mZnNldCt2LnNhbXBsZXMubGVuZ3RoKSx2LmtpZFZhbHVlPXMpKX10aGlzLmRlY29kZXJEYXRhKHAsdixvKTtmb3IodmFyIHc9MCx4PTA7eDxwLnNhbXBsZXMubGVuZ3RoO3grKylmb3IodmFyIFM9MCxBPXAuc2FtcGxlc1t4XS5kYXRhLEQ9QS5sZW5ndGgtMTtTPEQ7KXc9JChBLFMpLFMrPTQscC5zYW1wbGVzW3hdLnVuaXRzLnB1c2goQS5zdWJhcnJheShTLFMrdykpLFMrPXc7cmV0dXJuIHRoaXMuX2xhc3RSZW1haW5CdWZmZXI9ZS5zdWJhcnJheShNYXRoLm1heCh5LG0pKSx0aGlzLl9sYXN0UmVtYWluQnVmZmVyLmJ5dGVMZW5ndGg+MD90aGlzLl9sYXN0UmVtYWluQnVmZmVyU3RhcnRQb3M9dCtlLmJ5dGVMZW5ndGgtdGhpcy5fbGFzdFJlbWFpbkJ1ZmZlci5ieXRlTGVuZ3RoOnRoaXMuX2xhc3RSZW1haW5CdWZmZXJTdGFydFBvcz0wLHt2aWRlb1RyYWNrOnAsYXVkaW9UcmFjazp2LG1ldGFkYXRhVHJhY2s6dGhpcy5tZXRhZGF0YVRyYWNrfX19LHtrZXk6InJlc2V0Iix2YWx1ZTpmdW5jdGlvbigpe3RoaXMuX3ZpZGVvU2FtcGxlcz1bXSx0aGlzLl9hdWRpb1NhbXBsZXM9W10sdGhpcy5fbGFzdFJlbWFpbkJ1ZmZlcj1udWxsLHRoaXMuX2xhc3RSZW1haW5CdWZmZXJTdGFydFBvcz0wLHRoaXMudmlkZW9UcmFjay5yZXNldCgpLHRoaXMuYXVkaW9UcmFjay5yZXNldCgpLHRoaXMubWV0YWRhdGFUcmFjay5yZXNldCgpfX0se2tleToiZGVjb2RlckRhdGEiLHZhbHVlOmZ1bmN0aW9uKGUsdCxyKXtlLnVzZUVNRXx8dC51c2VFTUV8fER0LmRlY29kZXJBRVNDVFJEYXRhKGUsdCxyKX19XSxbe2tleToicHJvYmUiLHZhbHVlOmZ1bmN0aW9uKGUpe3JldHVybiBwZS5wcm9iZShlKX19XSksZX0oKSxCdD17bm93VGltZTpmdW5jdGlvbigpe3RyeXtyZXR1cm4gcGFyc2VJbnQocGVyZm9ybWFuY2Uubm93KCksMTApfWNhdGNoKGUpe3JldHVybihuZXcgRGF0ZSkuZ2V0VGltZSgpfX0sY29uY2F0RGF0YTpmdW5jdGlvbihlLHQpe3ZhciByPVtdLGE9MDtlJiZyLnB1c2goZSksdCYmci5wdXNoKHQpLHIuZXZlcnkoKGZ1bmN0aW9uKGUpe3JldHVybiBlJiYoYSs9ZS5ieXRlTGVuZ3RoKSwhMH0pKTt2YXIgbj1uZXcgVWludDhBcnJheShhKSxpPTA7cmV0dXJuIHIuZXZlcnkoKGZ1bmN0aW9uKGUpe3JldHVybiBlJiYobi5zZXQoZSxpKSxpKz1lLmJ5dGVMZW5ndGgpLCEwfSkpLG59fTtvbm1lc3NhZ2U9ZnVuY3Rpb24oZSl7dmFyIHI9ZS5kYXRhO3N3aXRjaChyLm1ldGhvZCl7Y2FzZSJpbml0Ijp0aGlzLmNvZGVjVHlwZT1yLmFyZ3MuY29kZWNUeXBlLHRoaXMub3BlbmxvZz1yLmFyZ3Mub3BlbkxvZyx0aGlzLk1QNERlbXV4ZXI9bnVsbCx0aGlzLkZNUDRSZW11eGVyPW51bGwsdGhpcy5fbmVlZEluaXRTZWdtZW50PSEwLHRoaXMuc3VwcG9ydEhldmM9ci5hcmdzLnN1cHBvcnRIZXZjO2JyZWFrO2Nhc2UidHJhbnNtdXgiOnZhciBhPWUuZGF0YS5hcmdzLG49bmV3IFVpbnQ4QXJyYXkoZS5kYXRhLmJ1ZmZlcik7dGhpcy5NUDREZW11eGVyfHwodGhpcy5NUDREZW11eGVyPW5ldyBFdChudWxsLG51bGwsbnVsbCx7b3BlbmxvZzp0aGlzLm9wZW5sb2d9KSk7dmFyIGkscz10aGlzLk1QNERlbXV4ZXIuZGVtdXhQYXJ0KG4sYS5zdGFydCxhLnZpZGVvSWR4LGEuYXVkaW9JZHgsYS5tb292LGEudXNlRU1FLGEua2lkVmFsdWUpO2lmKHRoaXMuRk1QNFJlbXV4ZXJ8fCJoMjY1Ij09PXRoaXMuY29kZWNUeXBlJiYhdGhpcy5zdXBwb3J0SGV2Y3x8KHRoaXMuRk1QNFJlbXV4ZXI9bmV3IERlKHRoaXMuTVA0RGVtdXhlci52aWRlb1RyYWNrLHRoaXMuTVA0RGVtdXhlci5hdWRpb1RyYWNrLHtvcGVuTG9nOnRoaXMub3BlbmxvZ30pKSx0aGlzLkZNUDRSZW11eGVyKXt2YXIgbz10aGlzLkZNUDRSZW11eGVyLnJlbXV4KHRoaXMuX25lZWRJbml0U2VnbWVudCx7aW5pdE1lcmdlOiEwfSk7by5pbml0U2VnbWVudCYmKHRoaXMuX25lZWRJbml0U2VnbWVudD0hMSksaT17YnVmZmVyOkJ0LmNvbmNhdERhdGEoby5hdWRpb1NlZ21lbnQsby52aWRlb1NlZ21lbnQpLHJhbmdlOmEuY29udGV4dC5yYW5nZSxzdGF0ZTphLmNvbnRleHQuc3RhdGUsY29udGV4dDp7cmFuZ2U6YS5jb250ZXh0LnJhbmdlLGZyYWdJbmRleDphLmNvbnRleHQuZnJhZ0luZGV4LHN0YXJ0UHRzOk1hdGgubWluKHMudmlkZW9UcmFjay5zdGFydFB0cyxzLmF1ZGlvVHJhY2suc3RhcnRQdHMpLGVuZFB0czpNYXRoLm1heChzLnZpZGVvVHJhY2suZW5kUHRzLHMuYXVkaW9UcmFjay5lbmRQdHMpfSxpbml0U2VnOm8uaW5pdFNlZ21lbnR9fXRoaXMucG9zdE1lc3NhZ2Uoe21ldGhvZDoidHJhbnNtdXgiLGlkOmUuZGF0YS5pZCxhcmdzOnQoe30saSl9KTticmVhaztjYXNlInJlc2V0Ijp0aGlzLkZNUDRSZW11eGVyJiZ0aGlzLkZNUDRSZW11eGVyLnJlc2V0KCksdGhpcy5NUDREZW11eGVyJiZ0aGlzLk1QNERlbXV4ZXIucmVzZXQoKSx0aGlzLkZNUDRSZW11eGVyPW51bGwsdGhpcy5NUDREZW11eGVyPW51bGwsdGhpcy5fbmVlZEluaXRTZWdtZW50PSEwfX19KCk7Cg==";
var blob = typeof window !== "undefined" && window.Blob && new Blob([atob(encodedJs)], {
  type: "text/javascript;charset=utf-8"
});
function WorkerWrapper() {
  var objURL = blob && (window.URL || window.webkitURL).createObjectURL(blob);
  try {
    return objURL ? new Worker(objURL, {}) : new Worker("data:application/javascript;base64," + encodedJs, {
      type: "module"
    });
  } finally {
    objURL && (window.URL || window.webkitURL).revokeObjectURL(objURL);
  }
}

// node_modules/xgplayer-mp4/es/worker/index.js
var TransmuxerWorkerControl = function(_EventEmitter) {
  _inherits(TransmuxerWorkerControl2, _EventEmitter);
  var _super = _createSuper(TransmuxerWorkerControl2);
  function TransmuxerWorkerControl2(options) {
    var _this;
    _classCallCheck(this, TransmuxerWorkerControl2);
    _this = _super.call(this);
    _this.openlog = options.openLog;
    _this.codecType = options.codecType;
    _this.supportHevc = options.supportHevc;
    _this.worker = new WorkerWrapper();
    _this.worker.onmessage = function(e) {
      _this.emit(e.data.method, e.data);
    };
    _this.worker.postMessage({
      method: "init",
      id: options.id || 0,
      args: {
        openlog: _this.openlog,
        supportHevc: _this.supportHevc,
        codecType: _this.codecType
      }
    });
    return _this;
  }
  _createClass(TransmuxerWorkerControl2, [{
    key: "transmux",
    value: function transmux(id, data, start, videoIdx, audioIdx, moov, useEME, kidValue, context) {
      var buffer = data.buffer;
      this.worker && this.worker.postMessage({
        method: "transmux",
        id,
        buffer,
        args: {
          start,
          videoIdx,
          audioIdx,
          moov,
          useEME,
          kidValue,
          context
        }
      }, [buffer]);
    }
  }, {
    key: "reset",
    value: function reset() {
      this.worker && this.worker.postMessage({
        method: "reset"
      });
    }
  }, {
    key: "destroy",
    value: function destroy() {
      this.worker && this.worker.terminate();
    }
  }]);
  return TransmuxerWorkerControl2;
}(import_eventemitter36.default);

// node_modules/xgplayer-mp4/es/mp4.js
var MP4_EVENTS = {
  ERROR: "error",
  META_READY: "metaReady",
  MOOV_REQ_PROGRESS: "moov_request_Progress",
  UPDATE_LOAD_IDX: "update_load_fragmentIdx"
};
var MP42 = function(_EventEmitter) {
  _inherits(MP422, _EventEmitter);
  var _super = _createSuper(MP422);
  function MP422(url, _options) {
    var _this;
    _classCallCheck(this, MP422);
    _this = _super.call(this);
    _defineProperty(_assertThisInitialized(_this), "onprogressDataArrive", function() {
      var _ref = _asyncToGenerator(_regeneratorRuntime().mark(function _callee(data, state, options) {
        var curSegRange;
        return _regeneratorRuntime().wrap(function _callee$(_context) {
          while (1)
            switch (_context.prev = _context.next) {
              case 0:
                if (data && data.byteLength > 0) {
                  curSegRange = _this.timeRange[options.index].range;
                  if (curSegRange && options.range[1] >= curSegRange[1] && !state) {
                    state = true;
                  }
                  _this.log("[mp4.loadFragment onprogressDataArrive ] receive data, >>> index,", options.index, ",range,", JSON.stringify(options.range), ", dataLen,", data.byteLength);
                  _this._mux(data, options.range[0], options.index, state);
                }
                if (state) {
                  _this.timeRange[options.index].downloaded = true;
                  _this.bufferLoadedPos = -1;
                  _this.log("[FragLoadDowned],fragmentIdx,", options.index, ",rangeEnd,", options.range[1]);
                }
              case 2:
              case "end":
                return _context.stop();
            }
        }, _callee);
      }));
      return function(_x, _x2, _x3) {
        return _ref.apply(this, arguments);
      };
    }());
    _this.url = url;
    _this.options = MP422.getDefaultConfig();
    Object.keys(_options).map(function(key) {
      _options[key] !== void 0 && _options[key] !== null && (_this.options[key] = _options[key]);
    });
    _this.timeRange = [];
    _this.CHUNK_SIZE = _this.options.chunkSize;
    _this.bufferLoaded = new Uint8Array(0);
    _this.bufferLoadedPos = 0;
    _this.meta = null;
    _this.videoTrak = null;
    _this.audioTrak = null;
    _this.canDownload = true;
    _this._loadSuccessCallBack = null;
    _this._isPending = false;
    _this._metaLoading = false;
    _this.MP4Loader = new MP4Loader(_objectSpread2(_objectSpread2({
      segmentDuration: _this.options.segmentDuration,
      url,
      vid: _options.vid,
      retry: _this.options.retryCount,
      retryDelay: _this.options.retryDelay,
      timeout: _this.options.timeout
    }, _options.reqOptions), {}, {
      openLog: checkOpenLog()
    }));
    _this.MP4Demuxer = null;
    _this.FMP4Remuxer = null;
    _this._needInitSegment = true;
    _this._switchBitRate = false;
    _this.enableWorker = _this.options.enableWorker;
    if (_this.enableWorker && typeof Worker !== "undefined") {
      try {
        _this.workerSequence = 0;
        _this.transmuxerWorkerControl = new TransmuxerWorkerControl({
          id: _this.workerSequence,
          codecType: _options.codecType,
          supportHevc: _this.options.supportHevc,
          openLog: checkOpenLog()
        });
        _this.transmuxerWorkerControl.on("transmux", function(muxRes) {
          var res = muxRes.args;
          _this.log("[transmuxerworker end] ,range, ", JSON.stringify(res.range), ",dataLen,", res.buffer.byteLength, res.context);
          _this._loadSuccessCallBack && _this._loadSuccessCallBack(res);
        });
      } catch (error) {
        _this.log("Error in worker:", error);
        _this.enableWorker = false;
        _this.transmuxerWorkerControl = null;
      }
    }
    if (!_this.enableWorker) {
      _this.MP4Demuxer = null;
      _this.FMP4Remuxer = null;
    }
    _this.seekTime = -1;
    _this.changeBitRateTime = -1;
    return _this;
  }
  _createClass(MP422, [{
    key: "changeBitRate",
    value: function() {
      var _changeBitRate = _asyncToGenerator(_regeneratorRuntime().mark(function _callee2(bitRateInfo) {
        return _regeneratorRuntime().wrap(function _callee2$(_context2) {
          while (1)
            switch (_context2.prev = _context2.next) {
              case 0:
                this.url = bitRateInfo.url;
                _context2.next = 3;
                return this.MP4Loader.changeUrl(this.url, this.options.vid + Date.now(), this.CHUNK_SIZE);
              case 3:
                this._switchBitRate = true;
                this.log("[switchBitrate] changeUrl, bitRate,", this.url);
              case 5:
              case "end":
                return _context2.stop();
            }
        }, _callee2, this);
      }));
      function changeBitRate(_x4) {
        return _changeBitRate.apply(this, arguments);
      }
      return changeBitRate;
    }()
  }, {
    key: "log",
    value: function log$1(message) {
      var options = this.options;
      var newMessage = options && options.vid ? "[MP4] ".concat(options.vid, " ").concat(message) : "[MP4] ".concat(message);
      for (var _len = arguments.length, optionalParams = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
        optionalParams[_key - 1] = arguments[_key];
      }
      log.apply(void 0, [newMessage].concat(optionalParams));
    }
  }, {
    key: "errorHandler",
    value: function() {
      var _errorHandler = _asyncToGenerator(_regeneratorRuntime().mark(function _callee3(error, state) {
        var response, message, vid, _error;
        return _regeneratorRuntime().wrap(function _callee3$(_context3) {
          while (1)
            switch (_context3.prev = _context3.next) {
              case 0:
                response = error.response, message = error.message;
                vid = this.options ? this.options.vid : "";
                _error = null;
                this._isPending = true;
                if (response) {
                  _error = new NetWorkError("network", response.status, {
                    httpText: response.httpText,
                    message,
                    url: response.url
                  });
                  this.emit(MP4_EVENTS.ERROR, _error);
                } else {
                  console.log("[MP4] [".concat(vid, "] errorHandler,"), error);
                  _error = error;
                  this.emit(MP4_EVENTS.ERROR, _error);
                }
              case 6:
              case "end":
                return _context3.stop();
            }
        }, _callee3, this);
      }));
      function errorHandler(_x5, _x6) {
        return _errorHandler.apply(this, arguments);
      }
      return errorHandler;
    }()
  }, {
    key: "init",
    value: function() {
      var _init = _asyncToGenerator(_regeneratorRuntime().mark(function _callee4() {
        return _regeneratorRuntime().wrap(function _callee4$(_context4) {
          while (1)
            switch (_context4.prev = _context4.next) {
              case 0:
                if (!this.url) {
                  _context4.next = 3;
                  break;
                }
                _context4.next = 3;
                return this.MP4Loader.changeUrl(this.url, this.options.vid + Date.now(), this.CHUNK_SIZE);
              case 3:
                _context4.next = 5;
                return this.getMetaInfo();
              case 5:
              case "end":
                return _context4.stop();
            }
        }, _callee4, this);
      }));
      function init() {
        return _init.apply(this, arguments);
      }
      return init;
    }()
  }, {
    key: "getTimeRange",
    value: function getTimeRange() {
      var range = [];
      var timeRange = null;
      for (var i = 0; this.videoTrak && i < this.videoTrak.length; i++) {
        timeRange = {
          startTime: this.videoTrak[i].startTime,
          endTime: this.videoTrak[i].endTime,
          downloaded: false,
          isLoading: false
        };
        range.push(timeRange);
      }
      if (this.audioTrak && this.audioTrak.length > range.length) {
        for (var j = range.length; j < this.audioTrak.length; j++) {
          timeRange = {
            startTime: Math.max(this.audioTrak[j].startTime, timeRange ? timeRange.endTime : 0),
            endTime: Math.max(this.audioTrak[j].endTime, timeRange ? timeRange.endTime : 0),
            downloaded: false,
            isLoading: false
          };
          range.push(timeRange);
        }
      }
      return range;
    }
  }, {
    key: "getMetaInfo",
    value: function() {
      var _getMetaInfo = _asyncToGenerator(_regeneratorRuntime().mark(function _callee6() {
        var _this2 = this;
        var isEmitMetaEvent, startPos, onProgressHandle, _args6 = arguments;
        return _regeneratorRuntime().wrap(function _callee6$(_context6) {
          while (1)
            switch (_context6.prev = _context6.next) {
              case 0:
                isEmitMetaEvent = _args6.length > 0 && _args6[0] !== void 0 ? _args6[0] : true;
                _context6.prev = 1;
                this._metaLoading = true;
                this.log("getMetaInfo start");
                this.bufferLoaded = new Uint8Array(0);
                startPos = 0;
                onProgressHandle = function() {
                  var _ref2 = _asyncToGenerator(_regeneratorRuntime().mark(function _callee5(data, state, options) {
                    var metaInfo;
                    return _regeneratorRuntime().wrap(function _callee5$(_context5) {
                      while (1)
                        switch (_context5.prev = _context5.next) {
                          case 0:
                            _this2.log("getMetaInfo onProgressHandle, dataLen,", data ? data.byteLength : -1, ", state,", state, ",range,", JSON.stringify(options.range));
                            if (data) {
                              if (options.range[0] === startPos) {
                                _this2.bufferLoaded = (0, import_concat_typed_array.default)(Uint8Array, _this2.bufferLoaded, new Uint8Array(data));
                                startPos += data.byteLength;
                              }
                            }
                            if (options.meta && !_this2.meta) {
                              metaInfo = options.meta;
                              _this2.videoTrak = metaInfo.videoSegments;
                              _this2.audioTrak = metaInfo.audioSegments;
                              _this2.timeRange = _this2.getTimeRange();
                              _this2.meta = _objectSpread2(_objectSpread2({}, metaInfo.meta), {}, {
                                ext: {
                                  videoTrak: _this2.videoTrak,
                                  audioTrak: _this2.audioTrak
                                }
                              });
                              metaInfo.bufferLoaded = _this2.bufferLoaded;
                              _this2.log("meta reach");
                              if (isEmitMetaEvent) {
                                _this2.emit(MP4_EVENTS.META_READY, _this2.meta);
                              }
                            }
                            if (_this2.meta && state) {
                              _this2.log("[getMetaInfo req end]");
                              _this2._metaLoading = false;
                            }
                            if (_this2.meta && (data || state)) {
                              _this2.log("emit moov_req_progress");
                              _this2.emit(MP4_EVENTS.MOOV_REQ_PROGRESS);
                            }
                          case 5:
                          case "end":
                            return _context5.stop();
                        }
                    }, _callee5);
                  }));
                  return function onProgressHandle2(_x7, _x8, _x9) {
                    return _ref2.apply(this, arguments);
                  };
                }();
                _context6.next = 9;
                return this.MP4Loader.loadMetaProcess(this.MP4Loader.cache, [0, this.CHUNK_SIZE], onProgressHandle);
              case 9:
                _context6.next = 15;
                break;
              case 11:
                _context6.prev = 11;
                _context6.t0 = _context6["catch"](1);
                console.error("[MP4] trigger errorHandler getMetaInfo", _context6.t0 === null || _context6.t0 === void 0 ? void 0 : _context6.t0.message);
                this.loadError(_context6.t0, "getMetaInfo");
              case 15:
              case "end":
                return _context6.stop();
            }
        }, _callee6, this, [[1, 11]]);
      }));
      function getMetaInfo() {
        return _getMetaInfo.apply(this, arguments);
      }
      return getMetaInfo;
    }()
  }, {
    key: "getFragmentIdx",
    value: function getFragmentIdx(time) {
      var video;
      var audio;
      if (!this.videoTrak.length) {
        audio = this.audioTrak.find(function(x2) {
          return x2.startTime <= time && x2.endTime > time;
        });
        return audio ? audio.index : 0;
      } else {
        video = this.videoTrak.find(function(x2) {
          return x2.startTime <= time && x2.endTime > time;
        });
        audio = this.audioTrak.find(function(x2) {
          return x2.startTime <= time && x2.endTime > time;
        });
        if (video && audio) {
          return Math.min(video.index, audio.index);
        } else if (video || audio) {
          return video ? video.index : audio.index;
        } else {
          var last = Number.MAX_VALUE;
          if (this.videoTrak && this.videoTrak.length > 0) {
            last = this.videoTrak.length - 1;
          }
          if (this.audioTrak && this.audioTrak.length > 0) {
            last = Math.min(this.audioTrak.length - 1, last);
          }
          return last;
        }
      }
    }
  }, {
    key: "_checkHasMeta",
    value: function() {
      var _checkHasMeta2 = _asyncToGenerator(_regeneratorRuntime().mark(function _callee7() {
        var metaInfo;
        return _regeneratorRuntime().wrap(function _callee7$(_context7) {
          while (1)
            switch (_context7.prev = _context7.next) {
              case 0:
                this.log(" loadMeta start");
                this._metaLoading = true;
                _context7.next = 4;
                return this.MP4Loader.loadMeta(this.MP4Loader.cache, Math.round(this.CHUNK_SIZE / 2));
              case 4:
                metaInfo = _context7.sent;
                this._metaLoading = false;
                this.videoTrak = metaInfo.videoSegments;
                this.audioTrak = metaInfo.audioSegments;
                this.meta = _objectSpread2(_objectSpread2({}, metaInfo.meta), {}, {
                  ext: {
                    videoTrak: this.videoTrak,
                    audioTrak: this.audioTrak
                  }
                });
                this.timeRange = this.getTimeRange();
                this.bufferLoaded = new Uint8Array(0);
                metaInfo.bufferLoaded = this.bufferLoaded;
                return _context7.abrupt("return", true);
              case 13:
              case "end":
                return _context7.stop();
            }
        }, _callee7, this);
      }));
      function _checkHasMeta() {
        return _checkHasMeta2.apply(this, arguments);
      }
      return _checkHasMeta;
    }()
  }, {
    key: "resetFragmentLoadState",
    value: function resetFragmentLoadState(fragIndex) {
      for (var i = 0; i < this.timeRange.length; i++) {
        if (i < fragIndex) {
          this.timeRange[i].downloaded = true;
          this.timeRange[i].isLoading = true;
        } else {
          this.timeRange[i].downloaded = false;
          this.timeRange[i].isLoading = false;
        }
      }
    }
  }, {
    key: "getFragRange",
    value: function getFragRange(fragIndex) {
      var _videoSeg, _audioSeg, _videoSeg2, _audioSeg2;
      var videoSeg = null;
      if (this.videoTrak) {
        videoSeg = fragIndex < this.videoTrak.length ? this.videoTrak[fragIndex] : this.videoTrak[this.videoTrak.length - 1];
      }
      var audioSeg = null;
      if (this.audioTrak) {
        audioSeg = fragIndex < this.audioTrak.length ? this.audioTrak[fragIndex] : this.audioTrak[this.audioTrak.length - 1];
      }
      var videodiff = 0, audiodiff = 0;
      if (this.videoTrak && fragIndex >= this.videoTrak.length - 1) {
        videodiff = -1;
      }
      if (this.audioTrak && fragIndex >= this.audioTrak.length - 1) {
        audiodiff = -1;
      }
      var range = [Math.min(((_videoSeg = videoSeg) === null || _videoSeg === void 0 ? void 0 : _videoSeg.range[0]) || Infinity, ((_audioSeg = audioSeg) === null || _audioSeg === void 0 ? void 0 : _audioSeg.range[0]) || Infinity), Math.max(((_videoSeg2 = videoSeg) === null || _videoSeg2 === void 0 ? void 0 : _videoSeg2.range[1]) + videodiff || 0, ((_audioSeg2 = audioSeg) === null || _audioSeg2 === void 0 ? void 0 : _audioSeg2.range[1]) + audiodiff || 0)];
      if (fragIndex < this.timeRange.length) {
        this.timeRange[fragIndex].range = range;
      }
      return range;
    }
  }, {
    key: "load",
    value: function() {
      var _load = _asyncToGenerator(_regeneratorRuntime().mark(function _callee8(fragIndex, successCallback) {
        var metaReady, range, subRange;
        return _regeneratorRuntime().wrap(function _callee8$(_context8) {
          while (1)
            switch (_context8.prev = _context8.next) {
              case 0:
                this._loadSuccessCallBack = successCallback;
                if (!(this._switchBitRate && !this._metaLoading)) {
                  _context8.next = 12;
                  break;
                }
                this.log("[switchBitrate], switch bitRate start load, time,", fragIndex >= this.videoTrak.length ? this.audioTrak[fragIndex].startTime : this.videoTrak[fragIndex].startTime, ", fragIndex,", fragIndex);
                _context8.next = 5;
                return this._checkHasMeta();
              case 5:
                metaReady = _context8.sent;
                if (this.changeBitRateTime > 0) {
                  if (this.timeRange[fragIndex].startTime <= this.changeBitRateTime && this.changeBitRateTime < this.timeRange[fragIndex].endTime) {
                    this.log("[switchBitrate], not need update load fragIndex", fragIndex, ",stTime,", this.changeBitRateTime);
                  } else {
                    fragIndex = this.getFragmentIdx(this.changeBitRateTime);
                    this.log("[switchBitrate], need update load fragIndex", fragIndex, ",stTime,", this.changeBitRateTime, ",newBitrateTimeRange,", this.timeRange[fragIndex].startTime, "-", this.timeRange[fragIndex].endTime);
                    this.emit(MP4_EVENTS.UPDATE_LOAD_IDX, fragIndex);
                  }
                  this.seekTime = this.changeBitRateTime;
                  this.changeBitRateTime = -1;
                }
                this.resetFragmentLoadState(fragIndex);
                this.log("[switchBitrate], reset timerange state,", fragIndex);
                this._needInitSegment = true;
                this.resetTansmuxer();
                if (metaReady) {
                  this._switchBitRate = false;
                }
              case 12:
                if (!(this._switchBitRate && this._metaLoading)) {
                  _context8.next = 14;
                  break;
                }
                return _context8.abrupt("return");
              case 14:
                range = this.getFragRange(fragIndex);
                this.log("loadFragment,", fragIndex, ",range,", JSON.stringify(range));
                if (this.seekTime > 0) {
                  subRange = this.getSubRange(fragIndex, this.seekTime, range);
                  this.loadFragment(fragIndex, subRange);
                  this.seekTime = -1;
                } else {
                  this.loadFragment(fragIndex, range);
                }
              case 17:
              case "end":
                return _context8.stop();
            }
        }, _callee8, this);
      }));
      function load(_x10, _x11) {
        return _load.apply(this, arguments);
      }
      return load;
    }()
  }, {
    key: "getSubRange",
    value: function getSubRange(fragIndex, time, range) {
      var videoStartRange = range[0];
      var audioStartRange = range[0];
      var i = 1;
      var find = false;
      this.log(">>>>>getSubRange time,", time, JSON.stringify(range));
      if (this.videoTrak) {
        var videoSeg = fragIndex < this.videoTrak.length ? this.videoTrak[fragIndex] : this.videoTrak[this.videoTrak.length - 1];
        var keyFrameList = videoSeg.frames.filter(getKeyFrameList);
        var videoTimescale = this.meta.videoTimescale;
        var startTime = keyFrameList[0].startTime / videoTimescale;
        this.log(">>>>>getSubRange video, startTime,", videoSeg.startTime, ",endTime,", videoSeg.endTime);
        for (var j = 0; j < keyFrameList.length; j++) {
          this.log(">>>>>getSubRange video keyFrameList, startTime,", keyFrameList[j].startTime / videoTimescale, ",range,", keyFrameList[j].offset);
        }
        for (; i < keyFrameList.length; i++) {
          var endTime = keyFrameList[i].startTime / videoTimescale;
          if (startTime <= time && time < endTime && range[0] < keyFrameList[i - 1].offset) {
            videoStartRange = keyFrameList[i - 1].offset;
            find = true;
            this.log(">>>>>getSubRange video end, startTime,", startTime, ",endTime,", endTime, ",startRange,", videoStartRange, ", keyFrameIndex,", i - 1);
            break;
          }
          startTime = endTime;
        }
        if (!find && startTime <= time && time < videoSeg.endTime + 0.8) {
          videoStartRange = keyFrameList[i - 1].offset;
          this.log(">>>>>getSubRange video last, startTime,", startTime, ",endTime,", videoSeg.endTime, ",startRange,", videoStartRange);
        }
      }
      i = 1;
      if (this.audioTrak) {
        var audioSeg = fragIndex < this.audioTrak.length ? this.audioTrak[fragIndex] : this.audioTrak[this.audioTrak.length - 1];
        var frameList = audioSeg.frames;
        var audioTimescale = this.meta.audioTimescale;
        i = Math.floor((time * audioTimescale - frameList[0].startTime) / audioSeg.frames[0].duration);
        i = Math.min(frameList.length - 1, i);
        var starttime = i > 0 ? frameList[i - 1].startTime / audioTimescale : frameList[0].startTime / audioTimescale;
        for (; i >= 0 && i < frameList.length; ) {
          if (i > 0 && starttime > time) {
            i -= 1;
            starttime = frameList[i].startTime / audioTimescale;
            continue;
          }
          var endtime = (frameList[i].startTime + frameList[i].duration) / audioTimescale;
          if (starttime <= time && time < endtime && range[0] < frameList[i].offset) {
            audioStartRange = frameList[i].offset;
            find = true;
            this.log(">>>>>getSubRange audio end, startTime,", starttime, ",endTime,", endtime, ",startRange,", audioStartRange, ", index,", i);
            break;
          }
          starttime = endtime;
          i++;
        }
      }
      var finalRange = [Math.min(audioStartRange, videoStartRange), range[1]];
      this.log(">>>>>getSubRange finalRange ", JSON.stringify(finalRange), ",oldRange,", JSON.stringify(range));
      return finalRange;
    }
  }, {
    key: "_mux",
    value: function _mux(buffer, start, fragIndex, state) {
      var videoIndexRange = this.getSamplesRange(fragIndex, "video");
      var audioIndexRange = this.getSamplesRange(fragIndex, "audio");
      var range = [start, start + buffer.byteLength];
      if (this.transmuxerWorkerControl) {
        var context = {
          range,
          state,
          fragIndex
        };
        this.log("[transmuxerworker start] ,range, ", JSON.stringify(range), ",dataLen,", buffer.byteLength, context);
        this.transmuxerWorkerControl.transmux(this.workerSequence, buffer, start, videoIndexRange, audioIndexRange, this.meta.moov, this.useEME, this.kidValue, context);
      } else {
        try {
          if (!this.MP4Demuxer) {
            this.MP4Demuxer = new MP4Demuxer(this.videoTrak, this.audioTrak, null, {
              openLog: checkOpenLog()
            });
          }
          var demuxRet = this.MP4Demuxer.demuxPart(buffer, start, videoIndexRange, audioIndexRange, this.meta.moov, this.useEME, this.kidValue);
          if (!this.FMP4Remuxer && (!this.checkCodecH265() || this.options.supportHevc)) {
            this.FMP4Remuxer = new FMP4Remuxer(this.MP4Demuxer.videoTrack, this.MP4Demuxer.audioTrack, {
              openLog: checkOpenLog()
            });
          }
          var res;
          this.log("[mux], videoTimeRange,", demuxRet.videoTrack ? [demuxRet.videoTrack.startPts, demuxRet.videoTrack.endPts] : null, ",audioTimeRange,", demuxRet.audioTrack ? [demuxRet.audioTrack.startPts, demuxRet.audioTrack.endPts] : null);
          var startPts = Math.min(demuxRet.videoTrack.startPts, demuxRet.audioTrack.startPts);
          var endPts = Math.max(demuxRet.videoTrack.endPts, demuxRet.audioTrack.endPts);
          var timeRange = [startPts, endPts];
          if (this.FMP4Remuxer) {
            var remuxRes = this.FMP4Remuxer.remux(this._needInitSegment, {
              initMerge: true,
              range
            });
            remuxRes.initSegment && (this._needInitSegment = false);
            var data = util2.concatData(remuxRes.audioSegment, remuxRes.videoSegment);
            res = {
              buffer: data,
              range,
              state,
              context: {
                range,
                fragIndex,
                timeRange
              },
              initSeg: remuxRes.initSegment
            };
          } else {
            res = {
              videoTrack: demuxRet.videoTrack,
              audioTrack: demuxRet.audioTrack,
              buffer: null,
              range,
              state,
              context: {
                range,
                fragIndex,
                timeRange
              }
            };
          }
          this._loadSuccessCallBack && this._loadSuccessCallBack(res);
        } catch (e) {
          console.error("mux err:", e);
          var err = new ParserError(ERROR_TYPES.remux, ERROR_CODES.muxError, {
            msg: JSON.stringify(e)
          });
          this.errorHandler(err, "mux", {
            fragIndex,
            range: [start, start + buffer.byteLength]
          });
        }
      }
    }
  }, {
    key: "getSamplesRange",
    value: function getSamplesRange(fragmentIdx, type) {
      var range = [];
      switch (type) {
        case "video":
          if (this.videoTrak && fragmentIdx < this.videoTrak.length) {
            var frames = this.videoTrak[fragmentIdx].frames;
            range.push(frames[0].index);
            range.push(frames[frames.length - 1].index);
          }
          break;
        case "audio":
          if (this.audioTrak && fragmentIdx < this.audioTrak.length) {
            var _frames = this.audioTrak[fragmentIdx].frames;
            range.push(_frames[0].index);
            range.push(_frames[_frames.length - 1].index);
          }
          break;
        default:
          console.warn("[getSamplesRange] type ", type, " is invalid");
          break;
      }
      return range;
    }
  }, {
    key: "loadFragment",
    value: function() {
      var _loadFragment = _asyncToGenerator(_regeneratorRuntime().mark(function _callee9(fragIndex, range) {
        var start, buffer, _start, _buffer;
        return _regeneratorRuntime().wrap(function _callee9$(_context9) {
          while (1)
            switch (_context9.prev = _context9.next) {
              case 0:
                if (!(this._isPending || range.length > 0 && range[0] === 0 && range[1] === 0 || this.timeRange[fragIndex].isLoading)) {
                  _context9.next = 2;
                  break;
                }
                return _context9.abrupt("return");
              case 2:
                this.log("[MP4.loadFragment] ,fragIndex,", fragIndex, ",range ", range, ",len ,", range[1] - range[0], ", bufferLoaded_Len,", this.bufferLoaded.byteLength);
                if (!(range.length >= 2 && range[1] && range[1] > 0 && range[1] <= this.bufferLoaded.byteLength)) {
                  _context9.next = 13;
                  break;
                }
                this.timeRange[fragIndex].isLoading = true;
                start = Math.max(range[0], this.bufferLoadedPos);
                buffer = new Uint8Array(this.bufferLoaded.slice(start, range[1]));
                this.log("[mp4.loadFragment] has all data: ", start, range[1]);
                this.timeRange[fragIndex].downloaded = true;
                this.bufferLoadedPos = -1;
                this._mux(buffer, start, fragIndex, true);
                _context9.next = 34;
                break;
              case 13:
                if (!(range.length >= 2 && range[0] && range[0] <= this.bufferLoaded.byteLength)) {
                  _context9.next = 29;
                  break;
                }
                if (this.timeRange[fragIndex].isLoading) {
                  _context9.next = 27;
                  break;
                }
                _start = Math.max(range[0], this.bufferLoadedPos);
                _buffer = new Uint8Array(this.bufferLoaded.slice(_start, range[1]));
                if (!(_buffer.byteLength > 0)) {
                  _context9.next = 22;
                  break;
                }
                this.bufferLoadedPos = _start + _buffer.byteLength;
                this.log("[mp4.loadFragment] has part data: ", _start, _start + _buffer.byteLength);
                this._mux(_buffer, _start, fragIndex, range[1] <= this.bufferLoadedPos);
                return _context9.abrupt("return");
              case 22:
                if (!(!this._metaLoading && !this.timeRange[fragIndex].isLoading)) {
                  _context9.next = 27;
                  break;
                }
                this.log("[mp4.loadFragment] ready to load part data >>> ", this.bufferLoaded.byteLength, range[1]);
                this.timeRange[fragIndex].isLoading = true;
                _context9.next = 27;
                return this.startLoad([this.bufferLoaded.byteLength, range[1]], fragIndex);
              case 27:
                _context9.next = 34;
                break;
              case 29:
                if (!((!this._metaLoading || range[0] >= this.CHUNK_SIZE) && !this.timeRange[fragIndex].isLoading)) {
                  _context9.next = 34;
                  break;
                }
                this.timeRange[fragIndex].isLoading = true;
                this.log("[mp4.loadFragment],ready to load all data ,segmentIdx, ", fragIndex, ",range >>> ", JSON.stringify(range));
                _context9.next = 34;
                return this.startLoad(range, fragIndex);
              case 34:
              case "end":
                return _context9.stop();
            }
        }, _callee9, this);
      }));
      function loadFragment(_x12, _x13) {
        return _loadFragment.apply(this, arguments);
      }
      return loadFragment;
    }()
  }, {
    key: "startLoad",
    value: function() {
      var _startLoad = _asyncToGenerator(_regeneratorRuntime().mark(function _callee10(range, fragIndex) {
        return _regeneratorRuntime().wrap(function _callee10$(_context10) {
          while (1)
            switch (_context10.prev = _context10.next) {
              case 0:
                _context10.prev = 0;
                _context10.next = 3;
                return this.MP4Loader.loadData(range, this.MP4Loader.cache, {
                  index: fragIndex,
                  onProgress: this.onprogressDataArrive,
                  onProcessMinLen: this.options.onProcessMinLen
                });
              case 3:
                _context10.next = 9;
                break;
              case 5:
                _context10.prev = 5;
                _context10.t0 = _context10["catch"](0);
                console.error("[MP4] trigger errorHandler getMetaInfo", _context10.t0 === null || _context10.t0 === void 0 ? void 0 : _context10.t0.message);
                this.loadError(_context10.t0, "loadFragment", {
                  range,
                  fragIndex
                });
              case 9:
              case "end":
                return _context10.stop();
            }
        }, _callee10, this, [[0, 5]]);
      }));
      function startLoad(_x14, _x15) {
        return _startLoad.apply(this, arguments);
      }
      return startLoad;
    }()
  }, {
    key: "loadError",
    value: function loadError(e, loadState, context) {
      var _e$response;
      !e.response && (e.response = {});
      if (e.isTimeout) {
        e.response.status = "timeout";
      } else if (!(e !== null && e !== void 0 && (_e$response = e.response) !== null && _e$response !== void 0 && _e$response.status)) {
        e.response.status = "networkError";
      }
      this.errorHandler(e, loadState, context);
    }
  }, {
    key: "cancelLoading",
    value: function() {
      var _cancelLoading = _asyncToGenerator(_regeneratorRuntime().mark(function _callee11() {
        return _regeneratorRuntime().wrap(function _callee11$(_context11) {
          while (1)
            switch (_context11.prev = _context11.next) {
              case 0:
                _context11.next = 2;
                return this.MP4Loader;
              case 2:
                _context11.t0 = _context11.sent;
                if (!_context11.t0) {
                  _context11.next = 5;
                  break;
                }
                this.MP4Loader.cancel();
              case 5:
              case "end":
                return _context11.stop();
            }
        }, _callee11, this);
      }));
      function cancelLoading() {
        return _cancelLoading.apply(this, arguments);
      }
      return cancelLoading;
    }()
  }, {
    key: "update",
    value: function update(url) {
      this.url = url;
    }
  }, {
    key: "checkCodecH265",
    value: function checkCodecH265() {
      var isHvc = this.meta && (this.meta.videoCodec.indexOf("hvc1") > -1 || this.meta.videoCodec.indexOf("hev1") > -1);
      return isHvc;
    }
  }, {
    key: "destroy",
    value: function destroy() {
      if (this.hasDestroyed) {
        return;
      }
      this.resetTansmuxer();
      this.transmuxerWorkerControl && this.transmuxerWorkerControl.destroy();
      this._isPending = false;
      this._metaLoading = false;
      this.bufferLoadedPos = 0;
      this.bufferLoaded = new Uint8Array(0);
      if (this.MP4Loader) {
        this.MP4Loader.cancel();
        this.MP4Loader.destroy();
      }
      this.hasDestroyed = true;
    }
  }, {
    key: "resetTansmuxer",
    value: function resetTansmuxer() {
      this.MP4Demuxer && this.MP4Demuxer.reset();
      this.MP4Demuxer = null;
      this.FMP4Remuxer && this.FMP4Remuxer.reset();
      this.FMP4Remuxer = null;
      this.transmuxerWorkerControl && this.transmuxerWorkerControl.reset();
    }
  }], [{
    key: "getDefaultConfig",
    value: function getDefaultConfig() {
      return {
        segmentDuration: 5,
        onProcessMinLen: 1024,
        chunkSize: 8e5,
        retryCount: 3,
        retryDelay: 1e3,
        timeout: 3e3,
        enableWorker: false,
        playerId: "",
        vid: "",
        ext: {}
      };
    }
  }]);
  return MP422;
}(import_eventemitter37.default);
function getKeyFrameList(frame) {
  if (frame.keyframe)
    return frame;
}

// node_modules/xgplayer-mp4/es/util/timer.js
var Timer = function() {
  function Timer2(onTick) {
    _classCallCheck(this, Timer2);
    this.onTick_ = onTick;
    this.cancelPending_ = null;
  }
  _createClass(Timer2, [{
    key: "tickAfter",
    value: function tickAfter(delayInSeconds) {
      var _this = this;
      var callback = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : null;
      this.stop();
      var alive = true;
      var timeoutId = null;
      this.cancelPending_ = function() {
        window.clearTimeout(timeoutId);
        alive = false;
      };
      var onTick = function onTick2() {
        if (alive) {
          _this.onTick_();
          if (callback) {
            callback();
          }
        }
      };
      timeoutId = window.setTimeout(onTick, delayInSeconds * 1e3);
      return this;
    }
  }, {
    key: "tickEvery",
    value: function tickEvery(seconds) {
      var _this2 = this;
      this.tickAfter(seconds, function() {
        _this2.tickEvery(seconds);
      });
    }
  }, {
    key: "stop",
    value: function stop() {
      if (this.cancelPending_) {
        this.cancelPending_();
        this.cancelPending_ = null;
      }
    }
  }]);
  return Timer2;
}();

// node_modules/xgplayer-mp4/es/util/proxy-promise.js
var ProxyPromise = function() {
  function ProxyPromise2() {
    _classCallCheck(this, ProxyPromise2);
    var resolvePromise;
    var rejectPromise;
    var promise = new Promise(function(resolve, reject) {
      resolvePromise = resolve;
      rejectPromise = reject;
    });
    var publicPromise = promise;
    publicPromise.resolve = function(data) {
      resolvePromise(data);
      publicPromise.state = "fulfilled";
    };
    publicPromise.reject = function(error) {
      rejectPromise(error);
      publicPromise.state = "rejected";
      publicPromise.isBreak = error === "DESTROYED";
    };
    publicPromise.state = "pending";
    return publicPromise;
  }
  _createClass(ProxyPromise2, [{
    key: "resolve",
    value: function resolve(value) {
    }
  }, {
    key: "reject",
    value: function reject(reason) {
    }
  }]);
  return ProxyPromise2;
}();

// node_modules/xgplayer-mp4/es/mp4Plugin.js
var DESTROYED = "DESTROYED";
var _playerPlayNext = null;
var _playerStartInit2 = null;
var _playerChangeDefinition = null;
var _playerSwitchUrl = null;
var Mp4Plugin = function(_BasePlugin) {
  _inherits(Mp4Plugin2, _BasePlugin);
  var _super = _createSuper(Mp4Plugin2);
  function Mp4Plugin2(options) {
    var _this;
    _classCallCheck(this, Mp4Plugin2);
    _this = _super.call(this, options);
    _defineProperty(_assertThisInitialized(_this), "_onMp4DataCallBack", function() {
      if (_this._isMseInit) {
        _this._onTimeUpdate();
      }
    });
    _defineProperty(_assertThisInitialized(_this), "_onMp4MetaReady", function(meta) {
      var _assertThisInitialize = _assertThisInitialized(_this), config = _assertThisInitialize.config;
      var isH265 = _this.mp4.checkCodecH265();
      try {
        if (isH265 && !_this.config.supportHevc) {
          var message = "browser not support HEVC";
          var _err = new Errors(_this.player, {
            errorType: "runtime",
            errorTypeCode: ERROR_TYPES.runtime,
            errorCode: ERROR_CODES.h265Error,
            errorMessage: message,
            vid: config.vid,
            mediaError: {
              code: ERROR_CODES.h265Error,
              message
            }
          });
          _this._errorHandler(_err);
        } else {
          _this._initMse(meta);
          _this._initPromise.resolve();
        }
      } catch (e) {
        var _err2 = new Errors(_this.player, {
          errorType: "runtime",
          errorTypeCode: ERROR_TYPES.runtime,
          errorCode: ERROR_CODES.mse,
          errorMessage: e === null || e === void 0 ? void 0 : e.message,
          vid: config.vid,
          mediaError: {
            code: ERROR_CODES.other1,
            message: e === null || e === void 0 ? void 0 : e.message
          }
        });
        _this._errorHandler(_err2);
        return;
      }
      _this._loadData();
    });
    _defineProperty(_assertThisInitialized(_this), "_onMp4Error", function(err) {
      var vid = _this.playerConfig.vid;
      console.error("[Index] _onMp4Error", vid, err);
      _this._errorHandler(err);
    });
    _defineProperty(_assertThisInitialized(_this), "_loadDataSuccess", function(data) {
      if (_this.isDestroy || !_this.mse) {
        return;
      }
      _this.log("[loadFragment] _loadDataSuccess ", JSON.stringify(data.context.range), ",dataLen,", data.buffer ? data.buffer.byteLength : 0, data.state);
      try {
        if (data.initSeg) {
          _this._appendInitSeg(data.initSeg);
          if (!data.buffer || data.buffer.byteLength < 1) {
            _this.log("no data, must load data");
            _this._onTimeUpdate();
          }
        }
        var buffer = data.buffer, state = data.state, context = data.context;
        if (_this.mse && state && (!buffer || buffer.byteLength <= 0) && context.fragIndex === _this.mp4.timeRange.length - 1) {
          var buffered = _this.player.buffered;
          if (buffered && buffered.length > 0) {
            _this.bufferEndTime = buffered.end(buffered.length - 1);
          }
          _this._isEnded();
          _this.log("loaded ended !!!==>>>", JSON.stringify(context.range), ", fragIndex,", context.fragIndex, ", bufferEndTime,", _this.bufferEndTime, ",meta_duration,", _this.mp4.meta.duration);
        }
        if (_this.mse && state && context.fragIndex === _this.mp4.timeRange.length - 1 && (!buffer || buffer.byteLength <= 0)) {
          var _buffered = _this.player.buffered;
          if (_buffered && _buffered.length > 0) {
            _this.bufferEndTime = _buffered.end(_buffered.length - 1);
          }
          _this._isEnded();
          _this.log("load ended !!!==>>>", _this.playerConfig.vid, JSON.stringify(context.range), ", fragIndex,", context.fragIndex, ", bufferEndTime,", _this.bufferEndTime, ",meta_duration,", _this.mp4.meta.duration);
        }
        if (buffer && _this.mse) {
          if (buffer && buffer.byteLength > 0) {
            _this._appendBuffer(MSE.VIDEO, buffer, context, state);
          }
        }
      } catch (e) {
        _this.log("appendBuffer error", e);
        var _err = new Errors(_this.player, {
          errorType: "runtime",
          errorTypeCode: ERROR_TYPES.runtime,
          errorCode: ERROR_CODES.mse,
          vid: _this.player.config.vid,
          errorMessage: e.message,
          mediaError: {
            code: ERROR_CODES.mse,
            message: e.message
          }
        });
        _this._errorHandler(_err);
      }
      if (data !== null && data !== void 0 && data.state) {
        _this._onTimeUpdate();
      }
    });
    _defineProperty(_assertThisInitialized(_this), "_onWaiting", function() {
      var _assertThisInitialize2 = _assertThisInitialized(_this), player = _assertThisInitialize2.player, config = _assertThisInitialize2.config;
      clearTimeout(_this._waitInBufferTimer);
      _this._waitInBufferTimer = null;
      var curTime = player.currentTime;
      var buffer = player.bufferedPoint;
      if (buffer.end > 0 && buffer.end - player.currentTime >= 2) {
        if (_this._waitAdjustTimeCnt < config.waitJampBufferMaxCnt) {
          _this._waitInBufferTimer = setTimeout(function() {
            _this._waitAdjustTimeCnt++;
            player.currentTime = player.currentTime + 0.5;
            _this.log("[waitInBufferTimeout], waitAdjustTimeCnt,", _this._waitAdjustTimeCnt, ",curtime,", curTime, util2.nowTime());
          }, config.waitingInBufferTimeOut);
        }
      }
    });
    _defineProperty(_assertThisInitialized(_this), "_onSeeking", _asyncToGenerator(_regeneratorRuntime().mark(function _callee() {
      var _assertThisInitialize3, player, mp4, curTime, buffered, hasBuffered, fragIndex, _assertThisInitialize4, mse, bufferList, bufferRange;
      return _regeneratorRuntime().wrap(function _callee$(_context) {
        while (1)
          switch (_context.prev = _context.next) {
            case 0:
              _assertThisInitialize3 = _assertThisInitialized(_this), player = _assertThisInitialize3.player, mp4 = _assertThisInitialize3.mp4;
              curTime = player.currentTime;
              _this.log("[seekTime], curTime,", curTime, ",buffer,", player.buffered2.bufferedList);
              if (!(!mp4 || !mp4.meta)) {
                _context.next = 5;
                break;
              }
              return _context.abrupt("return");
            case 5:
              _this.endofstream = false;
              mp4.bufferLoadedPos = -1;
              mp4._metaLoading = false;
              buffered = player.bufferedPoint;
              hasBuffered = false;
              fragIndex = 0;
              if (!(buffered.end > 0)) {
                _context.next = 25;
                break;
              }
              hasBuffered = true;
              if (!(mp4.meta.duration - buffered.end < 0.5)) {
                _context.next = 17;
                break;
              }
              _this._startProgress();
              _this.log("[seeking in buffered range], buffer end,", buffered.end, ", duration,", mp4.meta.duration);
              return _context.abrupt("return");
            case 17:
              fragIndex = mp4.getFragmentIdx(buffered.end);
              if (!(_this._curLoadSegmentIdx === fragIndex)) {
                _context.next = 22;
                break;
              }
              _this._startProgress();
              _this.log("[seeking in buffered range], seek fragIndex is current load segmentIdx", fragIndex);
              return _context.abrupt("return");
            case 22:
              mp4.seekTime = buffered.end;
              fragIndex < 0 && (fragIndex = _this._curLoadSegmentIdx);
              _this.log("[seeking in buffered range], seekTime ", curTime, ",bufferRange,", buffered.start, "-", buffered.end, ", fragIndex,", fragIndex);
            case 25:
              if (!hasBuffered) {
                mp4.seekTime = curTime;
                fragIndex = mp4.getFragmentIdx(curTime);
                fragIndex < 0 && (fragIndex = _this._curLoadSegmentIdx);
                _this.log("[seekTime out buffer range], curTime,", curTime, ", Idx,", fragIndex);
                _assertThisInitialize4 = _assertThisInitialized(_this), mse = _assertThisInitialize4.mse;
                if (mse && mse.isFull()) {
                  bufferList = player.buffered2.bufferedList;
                  bufferRange = bufferList[bufferList.length - 1];
                  mse.clearOpQueues(MSE.VIDEO);
                  _this._checkRemoveSourceBuffer([bufferRange.start, bufferRange.end], player.currentTime, true, true);
                }
              }
              _context.next = 28;
              return mp4.cancelLoading();
            case 28:
              mp4.resetFragmentLoadState(fragIndex);
              _this._curLoadSegmentIdx = fragIndex;
              _this._onTimeUpdate();
              _this._startProgress();
              _this._isEnded();
            case 33:
            case "end":
              return _context.stop();
          }
      }, _callee);
    })));
    _defineProperty(_assertThisInitialized(_this), "changeDefineCanPlay", function(currentTime, paused, from, to) {
      var _assertThisInitialize5 = _assertThisInitialized(_this), player = _assertThisInitialize5.player;
      if (player.ended) {
        player.currentTime = 0;
        return;
      }
      _this.log("[oldChangeDefinition],this._changeDefState,", _this._changeDefState);
      player.currentTime = _this._changeDefState ? _this._changeDefState.currentTime : currentTime;
      var isPause = _this._changeDefState ? _this._changeDefState.paused : paused;
      if (isPause) {
        player.pause();
      } else {
        player.play();
      }
      _this._changeDefState = null;
      player.emit(events_exports.AFTER_DEFINITION_CHANGE, {
        from,
        to
      });
    });
    _defineProperty(_assertThisInitialized(_this), "changeDefinition", function() {
      var _ref2 = _asyncToGenerator(_regeneratorRuntime().mark(function _callee2(to, from) {
        var _assertThisInitialize6, player, config, mp4, timeStart, fragIndex, buffered;
        return _regeneratorRuntime().wrap(function _callee2$(_context2) {
          while (1)
            switch (_context2.prev = _context2.next) {
              case 0:
                _assertThisInitialize6 = _assertThisInitialized(_this), player = _assertThisInitialize6.player, config = _assertThisInitialize6.config, mp4 = _assertThisInitialize6.mp4;
                if (!from) {
                  from = player.curDefinition;
                }
                _this._MSEError = false;
                if (!config.witchBitRateWay) {
                  _context2.next = 6;
                  break;
                }
                _this.oldChangeDefinition(to, from);
                return _context2.abrupt("return");
              case 6:
                player.emit(events_exports.DEFINITION_CHANGE, {
                  from,
                  to
                });
                timeStart = player.currentTime;
                fragIndex = mp4.getFragmentIdx(timeStart);
                fragIndex < 0 && (fragIndex = _this._curLoadSegmentIdx);
                _this.log("switchBitrate:point,fragIndex,", fragIndex, ",startTime,", mp4.timeRange[fragIndex].startTime, ",currentTime,", player.currentTime);
                if (!mp4) {
                  _context2.next = 16;
                  break;
                }
                _this.mp4.changeBitRateTime = timeStart;
                _context2.next = 15;
                return mp4.cancelLoading();
              case 15:
                mp4._metaLoading && (mp4._metaLoading = false);
              case 16:
                _this._removeBuffeEndTime = mp4.timeRange[fragIndex].startTime;
                _this._isChangeDefinition = true;
                buffered = player.getBufferedRange(player.buffered);
                if (buffered[1] > 0 && buffered[1] - player.currentTime > 5) {
                  _this.mse.clearOpQueues(MSE.VIDEO);
                  _this.mse.remove(MSE.VIDEO, player.currentTime + 5, buffered[1]);
                }
                _this.log("switchBitrate: resetFragmentLoadState,", fragIndex);
                mp4.resetFragmentLoadState(fragIndex);
                _this._curLoadSegmentIdx = fragIndex;
                _context2.next = 25;
                return _this.mp4.changeBitRate(to);
              case 25:
                _this._onTimeUpdate();
                player.emit("RESOLUTION_UPDATE", to);
              case 27:
              case "end":
                return _context2.stop();
            }
        }, _callee2);
      }));
      return function(_x, _x2) {
        return _ref2.apply(this, arguments);
      };
    }());
    _defineProperty(_assertThisInitialized(_this), "_replayHook", function() {
      var _this$player;
      (_this$player = _this.player) === null || _this$player === void 0 ? void 0 : _this$player.play();
      return false;
    });
    _defineProperty(_assertThisInitialized(_this), "_retryHook", function() {
      _this.beforePlayerInit();
      return false;
    });
    _this.mp4 = null;
    _this.mse = null;
    _this._waitAdjustTimeCnt = 0;
    _this._lastCheckTime = util2.nowTime();
    _this._removeBuffeEndTime = 0;
    _this._pendingPromises = [];
    return _this;
  }
  _createClass(Mp4Plugin2, [{
    key: "afterCreate",
    value: function afterCreate() {
      var _this2 = this;
      window.__mp4player = this;
      try {
        BasePlugin.defineGetterOrSetter(this.player, {
          __url: {
            get: function get() {
              try {
                return _this2.mse ? _this2.mse.url : _this2.config.url;
              } catch (error) {
                return null;
              }
            }
          }
        });
      } catch (e) {
      }
      this._proxyPlayer();
    }
  }, {
    key: "attachEvents",
    value: function attachEvents() {
      this.off(events_exports.SEEKING, this._onSeeking);
      this.on(events_exports.SEEKING, this._onSeeking);
      this.on(events_exports.WAITING, this._onWaiting);
      this.off(events_exports.URL_CHANGE, this.switchURL);
      this.on(events_exports.URL_CHANGE, this.switchURL);
    }
  }, {
    key: "detachEvents",
    value: function detachEvents() {
      this.off(events_exports.SEEKING, this._onSeeking);
      this.off(events_exports.WAITING, this._onWaiting);
      this.off(events_exports.URL_CHANGE, this.switchURL);
    }
  }, {
    key: "_proxyPlayer",
    value: function _proxyPlayer() {
      var _this3 = this;
      if (typeof this.player.playNext === "function") {
        _playerPlayNext = this.player.playNext;
      }
      this.player.playNext = function() {
        _this3.playNext.apply(_this3, arguments);
      };
      _playerStartInit2 = this.player._startInit;
      _playerSwitchUrl = this.player.switchURL;
      _playerChangeDefinition = this.player.changeDefinition;
      this.player._startInit = this._playerStartInit.bind(this);
      this.player.switchURL = this.switchURL.bind(this);
      this.player.changeDefinition = this.changeDefinition.bind(this);
      this.player.removeHooks("replay", this._replayHook);
      this.player.removeHooks("retry", this._retryHook);
    }
  }, {
    key: "_playerStartInit",
    value: function _playerStartInit(url) {
      var _this4 = this;
      var config = this.config, playerConfig = this.playerConfig;
      if (config.supportHevc === void 0) {
        if (sniffer !== null && sniffer !== void 0 && sniffer.isHevcSupported && sniffer.isHevcSupported()) {
          config.supportHevc = true;
        }
      }
      var ret = this.initMp4();
      this._initPromise = ret;
      this._addPendingPromise(this._initPromise);
      if (this.mse && util.typeOf(url) === "String" && /^blob/.test(url) && url !== this.mse.url) {
        url = playerConfig.url;
      }
      ret.then(function() {
        if (_this4.mse) {
          url = _this4.mse.url;
        }
        _this4.attachEvents();
        _this4._startProgress();
      }).catch(function(e) {
        var isBreak = _this4._initPromise ? _this4._initPromise.isBreak : false;
        if (_this4.isDestroy || isBreak) {
          return;
        }
        var err = e;
        if (!err.errorCode) {
          err = new Errors(_this4.player, {
            errorType: ERROR_TYPES.RUNTIME,
            errorCode: (e === null || e === void 0 ? void 0 : e.errorCode) || ERROR_CODES.other,
            vid: _this4.playerConfig.vid,
            errorMessage: (e === null || e === void 0 ? void 0 : e.errorMessage) || (e === null || e === void 0 ? void 0 : e.message),
            mediaError: {
              code: (e === null || e === void 0 ? void 0 : e.httpCode) || ERROR_CODES.other,
              message: (e === null || e === void 0 ? void 0 : e.errorMessage) || (e === null || e === void 0 ? void 0 : e.message),
              errorType: e === null || e === void 0 ? void 0 : e.errorType
            }
          });
          err.url = url;
        }
        _this4.useVideoLoad = true;
        _this4.player.vtype = "MP4_1";
        _this4.player.emit("playCatch", _this4.player.vtype, err);
      }).finally(function() {
        if (!_this4._initPromise) {
          return;
        }
        var isBreak = _this4._initPromise.isBreak;
        if (isBreak) {
          return;
        }
        _this4._initPromise && _this4._removePendingPromise(_this4._initPromise);
        _this4._initPromise = null;
        !_this4.isDestroy && !isBreak && _playerStartInit2.call(_this4.player, url);
      });
    }
  }, {
    key: "initMp4",
    value: function initMp4() {
      var _this5 = this;
      var player = this.player;
      if (!player.config.vid) {
        player.config.vid = Date.now();
      }
      var _promise = new ProxyPromise();
      if (this.mp4) {
        this.mp4.off(MP4_EVENTS.META_READY, this._onMp4MetaReady);
        this.mp4.off(MP4_EVENTS.ERROR, this._onMp4Error);
        this.mp4.off(MP4_EVENTS.MOOV_REQ_PROGRESS, this._onMp4DataCallBack);
        this.mp4.destroy();
        this.mp4 = null;
      }
      this.mp4 = new MP42(player.config.url, _objectSpread2(_objectSpread2({}, this.config), {}, {
        vid: player.config.vid
      }));
      this.mp4.on(MP4_EVENTS.META_READY, this._onMp4MetaReady);
      this.mp4.on(MP4_EVENTS.ERROR, this._onMp4Error);
      this.mp4.on(MP4_EVENTS.MOOV_REQ_PROGRESS, this._onMp4DataCallBack);
      this.mp4.on(MP4_EVENTS.UPDATE_LOAD_IDX, function(fragment) {
        _this5._curLoadSegmentIdx = fragment;
        _this5.log("[update curLoadSegmentIdx]", fragment);
      });
      this.mp4.init();
      return _promise;
    }
  }, {
    key: "setConfig",
    value: function setConfig(newConfig) {
      this.config = Object.assign(this.config, newConfig);
    }
  }, {
    key: "playNext",
    value: function playNext(newConfig) {
      var player = this.player;
      this._defInited = false;
      player.resetState();
      player._currentTime = 0;
      player._duration = 0;
      player.isPlaying = false;
      this._MSEError = false;
      player.pause();
      this._reset();
      player.setConfig(newConfig);
      this.log("[Index] playNext", newConfig);
      player.play();
      this.emit("playnext");
    }
  }, {
    key: "checkDegrade",
    value: function checkDegrade(error) {
      var closeDowngrade = this.config.closeDowngrade;
      return !closeDowngrade || error.httpCode === "networkError";
    }
  }, {
    key: "_errorHandler",
    value: function _errorHandler(err) {
      var _this$mp;
      var player = this.player, config = this.config;
      if (!player || this.useVideoLoad) {
        return;
      }
      if (!err.url && (_this$mp = this.mp4) !== null && _this$mp !== void 0 && _this$mp.url) {
        err.url = this.mp4.url;
      }
      var preState = player.paused;
      console.error("final error !!!!, ", config.vid, err);
      this.player.vtype = "MP4_2";
      this.player.emit("playCatch", this.player.vtype, err);
      var isDegrade = this.checkDegrade(err);
      if (isDegrade) {
        if (this._initPromise) {
          this._removeAndRejectInitPromise(err);
        } else {
          this._startDegradedPlayback(err, preState);
        }
      } else {
        this.player.pause();
        this._reset();
        var currentTime = player.currentTime;
        this.destroyMSE();
        player.currentTime = currentTime;
        this.emit("error", err);
      }
    }
  }, {
    key: "_startDegradedPlayback",
    value: function _startDegradedPlayback(err, preState) {
      var _this6 = this;
      console.log(">>>_startDegradedPlayback");
      var player = this.player, playerConfig = this.playerConfig;
      this.useVideoLoad = true;
      this.destroyMSE();
      this._currentTime = player.currentTime;
      this.__onmetadataHandle = function() {
        if (_this6._currentTime) {
          player.currentTime = _this6._currentTime;
        }
        if (preState) {
          _this6.player.pause();
        } else {
          _this6.player.play();
        }
        player.media.removeEventListener("loadedmetadata", _this6.__onmetadataHandle);
        _this6.__onmetadataHandle = null;
      };
      player.media.addEventListener("loadedmetadata", this.__onmetadataHandle);
      var _url = playerConfig.url;
      player.media.src = _url;
    }
  }, {
    key: "_addPendingPromise",
    value: function _addPendingPromise(p) {
      this._pendingPromises.push(p);
    }
  }, {
    key: "_removePendingPromise",
    value: function _removePendingPromise(p) {
      var idx = this._pendingPromises.indexOf(p);
      if (idx > -1) {
        this._pendingPromises.splice(idx, 1);
      }
    }
  }, {
    key: "_cancelPendingPromises",
    value: function _cancelPendingPromises() {
      if (this._pendingPromises.length > 0) {
        this._pendingPromises.forEach(function(promise) {
          promise.reject(DESTROYED);
        });
      }
      this._pendingPromises = [];
    }
  }, {
    key: "_removeAndRejectInitPromise",
    value: function _removeAndRejectInitPromise(error) {
      if (this._initPromise) {
        this._removePendingPromise(this._initPromise);
        this._initPromise.reject(error);
      }
    }
  }, {
    key: "_initMse",
    value: function() {
      var _initMse2 = _asyncToGenerator(_regeneratorRuntime().mark(function _callee3(meta) {
        var _this7 = this;
        var isHvc, hasVideo, hasAudio, codec, contentTypes, openPromise;
        return _regeneratorRuntime().wrap(function _callee3$(_context3) {
          while (1)
            switch (_context3.prev = _context3.next) {
              case 0:
                if (!this.mse) {
                  _context3.next = 4;
                  break;
                }
                _context3.next = 3;
                return this.mse.unbindMedia();
              case 3:
                this.mse = null;
              case 4:
                isHvc = this.mp4 && this.mp4.checkCodecH265();
                hasVideo = !!meta.videoCodec;
                hasAudio = !!meta.audioCodec;
                if (hasVideo && hasAudio) {
                  codec = isHvc ? 'video/mp4; codecs="hev1.1.6.L93.B0, mp4a.40.5"' : 'video/mp4; codecs="avc1.64001E, mp4a.40.5"';
                } else if (hasVideo) {
                  codec = isHvc ? 'video/mp4; codecs="hev1.1.6.L93.B0"' : 'video/mp4; codecs="avc1.64001E"';
                } else {
                  codec = 'video/mp4; codecs="mp4a.40.5"';
                }
                contentTypes = _defineProperty({}, MSE.VIDEO, {
                  mimeType: "video/mp4",
                  codec
                });
                this.mse = new MSE();
                openPromise = this.mse.bindMedia(this.player.video);
                openPromise.then(function() {
                  var contentTypesLocal = Object.keys(contentTypes);
                  try {
                    for (var i = 0; i < contentTypesLocal.length; i++) {
                      var type = contentTypesLocal[i];
                      _this7.mse.createSource(type, contentTypes[type].codec);
                    }
                  } catch (e) {
                    console.error("MSE error: ", e);
                    _this7._errorHandler(e);
                  }
                  _this7._isMseInit = true;
                  _this7._onTimeUpdate();
                });
              case 12:
              case "end":
                return _context3.stop();
            }
        }, _callee3, this);
      }));
      function _initMse(_x3) {
        return _initMse2.apply(this, arguments);
      }
      return _initMse;
    }()
  }, {
    key: "destroyMSE",
    value: function() {
      var _destroyMSE = _asyncToGenerator(_regeneratorRuntime().mark(function _callee4() {
        var _this$mse;
        return _regeneratorRuntime().wrap(function _callee4$(_context4) {
          while (1)
            switch (_context4.prev = _context4.next) {
              case 0:
                _context4.next = 2;
                return (_this$mse = this.mse) === null || _this$mse === void 0 ? void 0 : _this$mse.unbindMedia();
              case 2:
                this.mse = null;
              case 3:
              case "end":
                return _context4.stop();
            }
        }, _callee4, this);
      }));
      function destroyMSE() {
        return _destroyMSE.apply(this, arguments);
      }
      return destroyMSE;
    }()
  }, {
    key: "_onTimeUpdate",
    value: function _onTimeUpdate() {
      var _this8 = this;
      var mse = this.mse, mp4 = this.mp4, player = this.player, config = this.config;
      if (!mp4)
        return;
      var timeRange = mp4.timeRange;
      var range = player.getBufferedRange(player.buffered2);
      if (mse && mp4 && mp4.canDownload) {
        if (util2.nowTime() - this._lastCheckTime > 1e3) {
          this._lastCheckTime = util2.nowTime();
          this._loadStuckCheck();
          this._checkRemoveSourceBuffer(range, player.currentTime);
        }
        var cacheMaxTime = player.paused ? player.currentTime + config.minBufferLength : player.currentTime + config.maxBufferLength;
        if (range[1] - cacheMaxTime < 0) {
          timeRange.every(function(item, idx) {
            if (item.downloaded) {
              return true;
            }
            if (!_this8._isChangeDefinition && item.endTime - item.startTime > 1 && _this8._isInBuffer(item)) {
              item.downloaded = true;
              item.isLoading = true;
              _this8.log("onTimeUpdate, ".concat(idx, " download segment, has buffer"), item.startTime, item.endTime);
              return true;
            }
            if (item.startTime - player.currentTime < config.maxBufferLength) {
              _this8._curLoadSegmentIdx = idx;
              _this8.log("[onTimeUpdate],load index==>>>, ", idx, ",IdxTimeRange, ", item.startTime, "-", item.endTime, ",buffEnd, ", range[1], ",playCurTime,", player.currentTime, ", bufferLen,", range[1] - player.currentTime, ",bufferRangeList,", _this8.player.buffered2 ? _this8.player.buffered2.bufferedList : null);
              _this8._loadData();
            }
          });
        }
        this._isEnded();
      }
      this.checkRemoveOldBitrateBuffer();
    }
  }, {
    key: "checkRemoveOldBitrateBuffer",
    value: function checkRemoveOldBitrateBuffer() {
      var mse = this.mse, player = this.player;
      if (mse && this._removeBuffeEndTime > 0 && player.currentTime > this._removeBuffeEndTime + 1) {
        this.log("remove old bitrate buffer", this._removeBuffeEndTime);
        mse.remove(MSE.VIDEO, 0, this._removeBuffeEndTime - 1);
        this._removeBuffeEndTime = 0;
      }
    }
  }, {
    key: "_isInBuffer",
    value: function _isInBuffer(item) {
      var gap = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 0;
      var inbuffer = false;
      var buffered = this.player.video.buffered;
      for (var i = 0; i < buffered.length; i++) {
        var start = buffered.start(i) - gap;
        var end = buffered.end(i) + gap;
        if (start <= item.startTime && item.endTime <= end) {
          inbuffer = true;
          break;
        }
      }
      return inbuffer;
    }
  }, {
    key: "_loadData",
    value: function() {
      var _loadData2 = _asyncToGenerator(_regeneratorRuntime().mark(function _callee5() {
        return _regeneratorRuntime().wrap(function _callee5$(_context5) {
          while (1)
            switch (_context5.prev = _context5.next) {
              case 0:
                if (!(!this.mp4 || !this._isMseInit)) {
                  _context5.next = 3;
                  break;
                }
                this.log("loadData, player.mp4 null", this._isMseInit);
                return _context5.abrupt("return");
              case 3:
                _context5.prev = 3;
                _context5.next = 6;
                return this.mp4.load(this._curLoadSegmentIdx, this._loadDataSuccess);
              case 6:
                _context5.next = 11;
                break;
              case 8:
                _context5.prev = 8;
                _context5.t0 = _context5["catch"](3);
                console.error("[Index] _loadData error", this.playerConfig.vid, _context5.t0);
              case 11:
              case "end":
                return _context5.stop();
            }
        }, _callee5, this, [[3, 8]]);
      }));
      function _loadData() {
        return _loadData2.apply(this, arguments);
      }
      return _loadData;
    }()
  }, {
    key: "_appendInitSeg",
    value: function _appendInitSeg(initSeg) {
      var _this9 = this;
      if (!this.mp4 || !this.mse)
        return;
      this.mse.append(MSE.VIDEO, initSeg, {
        vid: this.playerConfig.vid,
        range: null,
        dataLen: initSeg.byteLength,
        isinit: true
      }).then(function(data) {
        _this9.log("appendInitSeg end ==>>>", data.context ? data.context : null, ", costTime,", data.costtime);
      });
    }
  }, {
    key: "_appendBuffer",
    value: function _appendBuffer(codec, buffer) {
      var _this10 = this;
      var context = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
      var state = arguments.length > 3 ? arguments[3] : void 0;
      var mse = this.mse, config = this.config;
      mse.append(codec, buffer, {
        vid: config.vid,
        fragIndex: context.fragIndex,
        range: context.range,
        dataLen: buffer.byteLength,
        state
      }).then(function(data) {
        _this10.log("player appendBuffer end ==>>>", data.context ? data.context : null, ", costTime,", data.costtime, ", opt,", data.name, ",bufferRange,", _this10.player.getBufferedRange());
        if (_this10.mse && context.state && context.fragIndex === _this10.mp4.timeRange.length - 1) {
          var buffered = _this10.player.buffered;
          if (buffered && buffered.length > 0) {
            _this10.bufferEndTime = buffered.end(buffered.length - 1);
          }
          _this10._isEnded();
          _this10.log("loaded ended !!!==>>>", context.range, ", fragIndex,", context.fragIndex, ", bufferEndTime,", _this10.bufferEndTime, ",meta_duration,", _this10.mp4.meta.duration);
        }
      }).catch(function(error) {
        console.log("[MSE error]", error);
        if (error && mse !== null && mse !== void 0 && mse.isFull()) {
          var bufferRange = _this10.player.getBufferedRange(_this10.player.buffered2);
          _this10._checkRemoveSourceBuffer(bufferRange, _this10.player.currentTime, true);
        }
      });
    }
  }, {
    key: "_checkRemoveSourceBuffer",
    value: function _checkRemoveSourceBuffer(sourceBufferRange, currentTime, mustClear) {
      var _this11 = this;
      var mse = this.mse, mp4 = this.mp4, player = this.player;
      if (!mse || !mp4 || !player)
        return;
      if (mustClear) {
        clearTimeout(this._removeBufferTimer);
        this._removeBufferTimer = null;
      }
      if (!sourceBufferRange)
        sourceBufferRange = player.getBufferedRange(player.buffered2);
      if (!currentTime)
        currentTime = player.currentTime;
      if (!mustClear && util2.nowTime() - this._checkRemoveBufferLastTime <= this.config.removeBufferLen || this.endofstream)
        return;
      this._checkRemoveBufferLastTime = util2.nowTime();
      if (sourceBufferRange && sourceBufferRange[0] >= 0 && (currentTime - sourceBufferRange[0] > this.config.removeBufferLen || mse.isFull())) {
        var time = sourceBufferRange[1];
        var segmentIdx = mp4.getFragmentIdx(time);
        if (segmentIdx >= 0 && mp4.timeRange[segmentIdx].startTime < currentTime) {
          var clearEnd = Math.floor(Math.min(mp4.timeRange[segmentIdx].startTime, sourceBufferRange[1]));
          if (sourceBufferRange[0] < clearEnd) {
            this.log("[checkremoveSourceBuffer], remove range==>>>", sourceBufferRange[0], clearEnd);
            mse.remove(MSE.VIDEO, sourceBufferRange[0], clearEnd);
          } else if (mse.isFull() && !this._removeBufferTimer) {
            this._removeBufferTimer = setTimeout(function() {
              _this11._checkRemoveSourceBuffer(null, null, true);
            }, 10 * 1e3);
          }
        }
      }
    }
  }, {
    key: "_isEnded",
    value: function _isEnded() {
      var player = this.player, mp4 = this.mp4;
      var buffered = player.bufferedPoint;
      var _end = buffered ? buffered.end : 0;
      if (!this.endofstream && this.mse && mp4.meta.duration - player.currentTime < 0.5) {
        this.log("[check player isEnded],deal mse.endOfStream, currentTime,", player.currentTime, ", bufferend,", _end, ", duration,", mp4.meta.duration);
        this.endofstream = true;
        this.mse.endOfStream();
      }
      if (mp4 && mp4.meta && mp4.meta.duration - player.currentTime < 0.5) {
        this._stopProgress();
        this.log("[check player isEnded],stopProgress and endOfStream,currentTime, ", player.currentTime, ", bufferend,", _end, ", duration,", mp4.meta.duration);
        this.mse && this.mse.endOfStream();
        return true;
      }
      return false;
    }
  }, {
    key: "switchURL",
    value: function switchURL(definitionInfo) {
      this.changeDefinition(definitionInfo);
    }
  }, {
    key: "oldChangeDefinition",
    value: function oldChangeDefinition(to, from) {
      var _this12 = this;
      var config = this.config, player = this.player;
      this.log("[oldChangeDefinition],currentTime,", player.currentTime, ",from,", from, ",to,", to);
      var currentTime = player.currentTime, paused = player.paused;
      if (!this._changeDefState) {
        this._changeDefState = {
          currentTime,
          paused
        };
        this.log("[oldChangeDefinition],currentTime,", player.currentTime, ",pause,", paused);
      }
      player.config.url = to.url;
      config.focusUserDefinition = true;
      player.currentTime = 0;
      player.pause();
      this._reset();
      this._isMseInit = false;
      this._changeDefineCanPlay && player.off("canplay", this._changeDefineCanPlay);
      this._changeDefineCanPlay = function() {
        _this12.changeDefineCanPlay(currentTime, paused, from, to);
        _this12._changeDefineCanPlay = null;
      };
      player.once("canplay", this._changeDefineCanPlay);
      this.player.video.load();
      this.initMp4();
    }
  }, {
    key: "_loadStuckCheck",
    value: function _loadStuckCheck() {
      var _this13 = this;
      var config = this.config, player = this.player;
      if (!config.disableBufferBreakCheck) {
        if (player.currentTime - (this._lastCurrentTime || 0) > 0.1 || player.paused) {
          if (this._bufferBreakFlag === 1 || this._bufferBreakFlag === 2) {
            this.log("视频没有卡死,重置卡死标记");
            this._bufferBreakFlag = 0;
            clearTimeout(this._bufferBreakTimer);
            this._bufferBreakFlag = null;
          }
        } else {
          if (!this._bufferBreakFlag) {
            this._bufferBreakFlag = 1;
            this.log("卡死计时开始! 持续".concat(config.waitingTimeOut, "毫秒则确认卡死"));
            this._bufferBreakTimer = setTimeout(function() {
              if (_this13.isDestroy) {
                return;
              }
              if (_this13._bufferBreakFlag === 1) {
                _this13._bufferBreakFlag = 2;
                _this13.log("确认卡死!!!");
                _this13._errorHandler(new Errors(_this13.player, {
                  errorType: "runtime",
                  errorTypeCode: ERROR_TYPES.runtime,
                  errorCode: ERROR_CODES.waitTimeout,
                  errorMessage: "wait_timeout",
                  vid: config.vid
                }));
              }
              _this13._bufferBreakTimer = null;
            }, config.waitingTimeOut);
          }
        }
        this._lastCurrentTime = player.currentTime;
      }
    }
  }, {
    key: "isDestroy",
    get: function get() {
      return !this.player;
    }
  }, {
    key: "_stopProgress",
    value: function _stopProgress() {
      this._hasStartProgress = false;
      if (this._requestTimer) {
        this._requestTimer.stop();
        this._requestTimer = null;
      }
      if (this._bufferBreakTimer) {
        clearTimeout(this._bufferBreakTimer);
        this._bufferBreakTimer = null;
        this._bufferBreakFlag = void 0;
      }
    }
  }, {
    key: "_startProgress",
    value: function _startProgress() {
      var _this14 = this;
      if (this._hasStartProgress) {
        return;
      }
      this._stopProgress();
      this._requestTimer = new Timer(function() {
        if (_this14._requestTimer) {
          _this14._onTimeUpdate();
        }
      });
      this._requestTimer.tickEvery(this.config.tickInSeconds);
      this._hasStartProgress = true;
    }
  }, {
    key: "log",
    value: function log$1(message) {
      var playerConfig = this.playerConfig;
      var newMessage = playerConfig && playerConfig.vid ? "[Index]".concat(playerConfig.vid, " ").concat(message) : "[Index] ".concat(message);
      for (var _len = arguments.length, optionalParams = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
        optionalParams[_key - 1] = arguments[_key];
      }
      log.apply(void 0, [newMessage].concat(optionalParams));
    }
  }, {
    key: "_reset",
    value: function _reset() {
      this._isMseInit = false;
      this.endofstream = false;
      this._curLoadSegmentIdx = 0;
      this._removeBuffeEndTime = 0;
      this._isChangeDefinition = false;
      this._stopProgress();
      if (this.mp4) {
        this.mp4.off(MP4_EVENTS.META_READY, this._onMp4MetaReady);
        this.mp4.off(MP4_EVENTS.ERROR, this._onMp4Error);
        this.mp4.off(MP4_EVENTS.MOOV_REQ_PROGRESS, this._onMp4DataCallBack);
        this.mp4.destroy();
        this.mp4 = null;
      }
      if (this.mse) {
        this.mse.unbindMedia();
        this.mse = null;
      }
      this._unloadVideo();
    }
  }, {
    key: "_unloadVideo",
    value: function _unloadVideo() {
      var player = this.player;
      try {
        this.log("unloadVideo src ".concat(player.video.src));
        if (player.video && player.video.src) {
          player.video.removeAttribute("src");
          player.video.load();
        }
      } catch (error) {
        this.log("unloadVideo error", error);
      }
    }
  }, {
    key: "destroy",
    value: function destroy() {
      var player = this.player;
      player.removeHooks("replay", this._replayHook);
      player.removeHooks("retry", this._retryHook);
      this.detachEvents();
      this._reset();
      this.player.playNext = _playerPlayNext;
      this.player._startInit = _playerStartInit2;
      this.player.changeDefinition = _playerChangeDefinition;
      this.player.switchURL = _playerSwitchUrl;
      if (this._bufferBreakTimer) {
        clearInterval(this._bufferBreakTimer);
      }
      if (this._removeBufferTimer) {
        clearTimeout(this._removeBufferTimer);
        this._removeBufferTimer = null;
      }
      if (this._waitInBufferTimer) {
        clearTimeout(this._waitInBufferTimer);
        this._waitInBufferTimer = null;
      }
    }
  }], [{
    key: "pluginName",
    get: function get() {
      return "mp4Plugin";
    }
  }, {
    key: "defaultConfig",
    get: function get() {
      return {
        maxBufferLength: 40,
        minBufferLength: 5,
        disableBufferBreakCheck: false,
        waitingTimeOut: 15e3,
        waitingInBufferTimeOut: 5e3,
        waitJampBufferMaxCnt: 3,
        tickInSeconds: 0.1,
        reqOptions: null,
        closeDowngrade: false
      };
    }
  }, {
    key: "version",
    get: function get() {
      return "3.0.17";
    }
  }]);
  return Mp4Plugin2;
}(BasePlugin);
export {
  Mp4Plugin as default
};
//# sourceMappingURL=xgplayer-mp4.js.map
