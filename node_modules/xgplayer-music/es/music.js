import { inherits as _inherits, createSuper as _createSuper, createClass as _createClass, classCallCheck as _classCallCheck, defineProperty as _defineProperty, assertThisInitialized as _assertThisInitialized, objectSpread2 as _objectSpread2 } from "./_virtual/_rollupPluginBabelHelpers.js";
import { Util, Events, BasePlugin } from "xgplayer";
import Xhr from "./xhr.js";
var PLAY_MODES = {
  ORDER: "order",
  SLOOP: "sloop",
  LOOP: "loop",
  RANDOM: "random"
};
var CLASS_NAME = "xgplayer-music";
function _randomIndex(min, max, index) {
  var i = Math.floor(Math.random() * (max - min) + min);
  if (i === index) {
    if (i > max / 2) {
      max = max / 2;
    } else {
      min = max / 2;
    }
    return max - min > 2 ? _randomIndex(min, max, index) : i;
  } else {
    return i;
  }
}
var Music = /* @__PURE__ */ function(_BasePlugin) {
  _inherits(Music2, _BasePlugin);
  var _super = _createSuper(Music2);
  function Music2() {
    var _this;
    _classCallCheck(this, Music2);
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    _this = _super.call.apply(_super, [this].concat(args));
    _defineProperty(_assertThisInitialized(_this), "_onEnded", function() {
      if (_this.mode === "order" && _this.index + 1 >= _this.list.length) {
        _this.player.pause();
        _this.player.currentTime = 0;
        return;
      }
      switch (_this.mode) {
        case PLAY_MODES.SLOOP:
          _this.change();
          break;
        case PLAY_MODES.ORDER:
        case PLAY_MODES.LOOP:
        default:
          _this.next();
          break;
      }
    });
    _defineProperty(_assertThisInitialized(_this), "_onDurationChange", function() {
      var abCycle = _this.config.abCycle;
      _this._initABCycle(abCycle, _this.player);
    });
    _defineProperty(_assertThisInitialized(_this), "_onTimeUpdate", function() {
      var _assertThisInitialize = _assertThisInitialized(_this), config = _assertThisInitialize.config, player = _assertThisInitialize.player;
      if (!_this.halfPass && player.currentTime > player.duration / 2) {
        _this.confirmOrder();
      }
      if (config.abCycle) {
        var c = config.abCycle;
        var _end = c.end > player.duration ? player.duration : c.end;
        if (player.currentTime >= _end) {
          if (!c.loop) {
            player.pause();
            _this.emit("abCycle_ended");
          }
          player.currentTime = c.start || 0;
        } else if (player.currentTime < c.start) {
          player.currentTime = c.start || 0;
        }
      }
    });
    return _this;
  }
  _createClass(Music2, [{
    key: "afterCreate",
    value: function afterCreate() {
      var player = this.player, playerConfig = this.playerConfig;
      Util.addClass(player.root, CLASS_NAME);
      this.halfPass = false;
      this.list = this.config.list || [];
      this.nextIndex = -1;
      this.prevIndex = -1;
      this.history = [];
      this.disable = !(this.list.length > 0);
      if (this.list.length === 0) {
        return;
      }
      if (!playerConfig.url && this.list.length > 0) {
        playerConfig.url = this.list[0].src;
      }
      if (!playerConfig.poster) {
        playerConfig.poster = this.list[0].poster;
      }
      if (!playerConfig.title) {
        playerConfig.title = this.list[0].title || "";
      }
      if (!playerConfig.vid) {
        playerConfig.vid = this.list[0].vid || "";
      }
      this._curInfo = {
        src: playerConfig.url,
        poster: playerConfig.poster,
        title: playerConfig.title,
        vid: playerConfig.vid
      };
      this.index = 0;
      this.on(Events.TIME_UPDATE, this._onTimeUpdate);
      this.on(Events.ENDED, this._onEnded);
      this.on(Events.DURATION_CHANGE, this._onDurationChange);
      if (this.config.offline) {
        this.checkOffline(this._curInfo.src, this._curInfo.vid).then(function(data) {
          if (data.code === 0) {
            playerConfig.url = data.url;
            if (player.state >= 4) {
              player.src = data.url;
            }
          }
        }).catch(function(e) {
        });
      }
    }
  }, {
    key: "destroy",
    value: function destroy() {
      Util.removeClass(this.player.root, CLASS_NAME);
    }
  }, {
    key: "_nextCompute",
    value: function _nextCompute() {
      if (this.disable) {
        return;
      }
      switch (this.mode) {
        case PLAY_MODES.SLOOP:
        case PLAY_MODES.ORDER:
        case PLAY_MODES.LOOP:
          if (this.index + 1 < this.list.length) {
            this.nextIndex = this.index + 1;
          } else {
            this.nextIndex = 0;
          }
          break;
        default:
          this.nextIndex = _randomIndex(0, this.list.length, this.index);
          break;
      }
    }
  }, {
    key: "_prevCompute",
    value: function _prevCompute() {
      if (this.disable) {
        return;
      }
      switch (this.mode) {
        case PLAY_MODES.SLOOP:
        case PLAY_MODES.ORDER:
        case PLAY_MODES.LOOP:
          if (this.index - 1 >= 0) {
            this.prevIndex = this.index - 1;
          } else {
            this.prevIndex = this.list.length - 1;
          }
          break;
        default:
          this.prevIndex = _randomIndex(0, this.list.length, this.index);
          break;
      }
    }
  }, {
    key: "_emitChange",
    value: function _emitChange() {
      this.emit("change", this._curInfo);
    }
  }, {
    key: "_initABCycle",
    value: function _initABCycle(abCycle, player) {
      var _p = player.plugins.progresspreview;
      if (abCycle && player) {
        var _end = abCycle.end > this.player.duration ? this.player.duration : abCycle.end;
        var _start = abCycle.start > this.player.duration ? 0 : abCycle.start;
        var dot = {
          id: player.playerId,
          time: abCycle.start,
          duration: _end - _start,
          text: abCycle.text,
          color: abCycle.color
        };
        _p.findDot(dot.id) ? _p.updateDot(dot) : _p.createDot(dot);
      } else {
        _p.findDot(player.playerId) ? _p.deleteDot(player.playerId) : "";
      }
    }
  }, {
    key: "random",
    value: function random() {
      if (this.list.length < 0) {
        return null;
      }
      var _i = _randomIndex(0, this.list.length, this.index);
      return this.list[_i];
    }
  }, {
    key: "next",
    value: function next() {
      if (this.disable) {
        return;
      }
      if (!this.halfPass) {
        this.halfPass = true;
        this._nextCompute();
      }
      this.index = this.nextIndex;
      this.change();
    }
  }, {
    key: "prev",
    value: function prev() {
      if (this.disable) {
        return;
      }
      if (!this.halfPass) {
        this.halfPass = true;
        this._prevCompute();
      }
      this.index = this.prevIndex;
      this.change();
    }
  }, {
    key: "forward",
    value: function forward() {
      var player = this.player;
      var timeScale = this.config.timeScale;
      player.currentTime = player.currentTime + timeScale < player.duration ? player.currentTime + timeScale : player.duration - 0.1;
    }
  }, {
    key: "backward",
    value: function backward() {
      var player = this.player;
      var timeScale = this.config.timeScale;
      player.currentTime = player.currentTime - timeScale > 0 ? player.currentTime - timeScale : 0;
    }
  }, {
    key: "add",
    value: function add(meta) {
      this.list.push({
        src: meta.src,
        title: meta.title,
        vid: meta.vid,
        poster: meta.poster
      });
    }
  }, {
    key: "remove",
    value: function remove(vid) {
      var idx = -1;
      this.list.every(function(item, index) {
        if (item.vid === vid) {
          idx = index;
          return false;
        } else {
          return true;
        }
      });
      if (idx > -1) {
        this.list.splice(idx, 1);
      }
    }
  }, {
    key: "setAbCycle",
    value: function setAbCycle(start, end, loop) {
      var ext = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : {};
      if (start && Util.typeof(start) === "Object") {
        this.config.abCycle = _objectSpread2({}, start);
      } else {
        this.config.abCycle = _objectSpread2({
          start: start || 0,
          end: end || this.player.duration,
          loop
        }, ext);
      }
      this._initABCycle(this.config.abCycle, this.player);
    }
  }, {
    key: "removeAbCycle",
    value: function removeAbCycle() {
      this.config.abCycle = null;
      this._initABCycle(null, this.player);
    }
  }, {
    key: "updateList",
    value: function updateList() {
      var list = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : [];
      this.removeAbCycle();
      this.player.pause();
      this.player.currentTime = 0;
      this.list = list;
      this.nextIndex = 0;
      this.index = 0;
      this.change();
    }
  }, {
    key: "setIndex",
    value: function setIndex() {
      var index = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : 0;
      if (index < 0 || index >= this.list.length) {
        return;
      }
      this.nextIndex = index;
      this.index = index;
      this.change();
    }
  }, {
    key: "change",
    value: function change() {
      var _this2 = this;
      if (this.disable) {
        return;
      }
      var player = this.player, list = this.list, index = this.index;
      var offlineVid = list[index].vid;
      this.halfPass = false;
      this.checkOffline(list[index].src, offlineVid).then(function(data) {
        _this2._curInfo = {
          title: _this2.list[_this2.index].title || "",
          vid: _this2.list[_this2.index].vid,
          poster: _this2.list[_this2.index].poster || "",
          src: data.url
        };
        player.playNext({
          url: data.url,
          vid: _this2.list[_this2.index].vid || 0,
          poster: _this2.list[_this2.index].poster || "",
          autoplay: true
        });
        player.off("timeupdate", _this2._emitChange);
        player.once("timeupdate", _this2._emitChange);
        player.play();
      });
    }
  }, {
    key: "checkOffline",
    value: function checkOffline(url, offlineVid) {
      var _this3 = this;
      return new Promise(function(resolve, reject) {
        if (!_this3.config.offline || _this3.disable) {
          resolve({
            url,
            code: -1,
            vid: offlineVid
          });
        }
        var database = _this3.player.database;
        database.openDB(function() {
          database.getDataByKey(database.myDB.ojstore.name, offlineVid, function(result) {
            setTimeout(function() {
              database.closeDB();
            }, 5e3);
            if (result) {
              resolve({
                url: URL.createObjectURL(result.blob),
                code: 0,
                vid: result.vid
              });
            } else {
              resolve({
                url,
                code: -2,
                vid: offlineVid
              });
            }
          });
        });
      });
    }
  }, {
    key: "confirmOrder",
    value: function confirmOrder() {
      this.halfPass = true;
      this._nextCompute();
      this._prevCompute();
      if (this.config.preloadNext) {
        this.preload(this.nextIndex);
      }
    }
  }, {
    key: "preload",
    value: function preload(index) {
      if (index < 0 || index >= this.list.length) {
        return;
      }
      var _item = this.list[index];
      var player = this.player;
      this.checkOffline(_item.src, _item.vid).then(function(data) {
        if (data.code === -2) {
          var offlineVid = _item.vid;
          new Xhr(_item.src, function(res) {
            player.database.openDB(function() {
              player.database.addData(player.database.myDB.ojstore.name, [{
                vid: offlineVid,
                blob: new Blob([res], {
                  type: 'audio/mp4; codecs="mp4a.40.5"'
                })
              }]);
              setTimeout(function() {
                player.database.closeDB();
              }, 5e3);
            });
          });
        }
      });
    }
  }, {
    key: "timeScale",
    get: function get() {
      return this.config.timeScale || 15;
    },
    set: function set(scale) {
      this.config.timeScale = scale;
    }
  }, {
    key: "mode",
    get: function get() {
      return this.config.mode || PLAY_MODES.RANDOM;
    },
    set: function set(val) {
      this.config.mode = val;
    }
  }], [{
    key: "pluginName",
    get: function get() {
      return "music";
    }
  }, {
    key: "defaultConfig",
    get: function get() {
      return {
        offline: false,
        preloadNext: true,
        abCycle: null,
        timeScale: 15,
        mode: PLAY_MODES.ORDER,
        list: []
      };
    }
  }, {
    key: "ModeType",
    get: function get() {
      return Object.keys(PLAY_MODES).map(function(key) {
        return PLAY_MODES[key];
      });
    }
  }]);
  return Music2;
}(BasePlugin);
export { Music as default };
