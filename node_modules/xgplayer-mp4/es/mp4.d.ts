declare class MP4 {
    static getDefaultConfig(): {
        segmentDuration: number;
        onProcessMinLen: number;
        chunkSize: number;
        retryCount: number;
        retryDelay: number;
        timeout: number;
        enableWorker: boolean;
        playerId: string;
        vid: string;
        ext: {};
    };
    /**
     * [constructor 构造函数]
     * @param { string } url                      [视频地址]
     * @param { Object } options
     * @param { Number } [chunk_size=Math.pow(25, 4)]           [请求的数据块大小，对于长视频设置的较大些可以避免二次请求]
     * @param { any } preloader [预加载器]
     * @param { any } preloadTimeCache  [预加载信息]
     */
    constructor(url: string, options: any);
    url: string;
    options: {
        segmentDuration: number;
        onProcessMinLen: number;
        chunkSize: number;
        retryCount: number;
        retryDelay: number;
        timeout: number;
        enableWorker: boolean;
        playerId: string;
        vid: string;
        ext: {};
    };
    timeRange: any[];
    CHUNK_SIZE: number;
    bufferLoaded: Uint8Array;
    bufferLoadedPos: number;
    meta: any;
    videoTrak: any;
    audioTrak: any;
    canDownload: boolean;
    _loadSuccessCallBack: any;
    _isPending: boolean;
    _metaLoading: boolean;
    MP4Loader: MP4Loader;
    MP4Demuxer: MP4Demuxer;
    FMP4Remuxer: FMP4Remuxer;
    _needInitSegment: boolean;
    _switchBitRate: boolean;
    enableWorker: boolean;
    workerSequence: number;
    transmuxerWorkerControl: TransmuxerWorkerControl;
    seekTime: number;
    changeBitRateTime: number;
    changeBitRate(bitRateInfo: any): Promise<void>;
    log(message: any, ...optionalParams: any[]): void;
    /**
     * 错误处理
     * @param { Error } error
     * @param { string } state
     */
    errorHandler(error: Error, state: string, context?: {}): Promise<void>;
    init(): Promise<void>;
    getTimeRange(): {
        startTime: any;
        endTime: any;
        downloaded: boolean;
        isLoading: boolean;
    }[];
    getMetaInfo(isEmitMetaEvent?: boolean): Promise<void>;
    getFragmentIdx(time: any): any;
    _checkHasMeta(): Promise<boolean>;
    resetFragmentLoadState(fragIndex: any): void;
    getFragRange(fragIndex: any): number[];
    load(fragIndex: any, successCallback: any): Promise<void>;
    /**
     * 查找离time最近的左边的关键帧的开始的range
     * @param { fragIndex }
     * @param { time }
     * @param { range }
     * @return {
     *  range: array<number>,
  
     * }
     */
    getSubRange(fragIndex: any, time: any, range: any): any;
    onprogressDataArrive: (data: any, state: any, options: any) => Promise<void>;
    _mux(buffer: any, start: any, fragIndex: any, state: any): void;
    getSamplesRange(fragmentIdx: any, type: any): any[];
    loadFragment(fragIndex: any, range: any): Promise<void>;
    startLoad(range: any, fragIndex: any): Promise<void>;
    loadError(e: any, loadState: any, context: any): void;
    cancelLoading(): Promise<void>;
    update(url: any): void;
    checkCodecH265(): boolean;
    destroy(): void;
    hasDestroyed: boolean;
    resetTansmuxer(): void;
}
export namespace MP4_EVENTS {
    const ERROR: string;
    const META_READY: string;
    const MOOV_REQ_PROGRESS: string;
    const UPDATE_LOAD_IDX: string;
}
import MP4Loader from "xgplayer-mp4-loader";
import { MP4Demuxer } from "../../xgplayer-transmuxer/es/mp4";
import { FMP4Remuxer } from "../../xgplayer-transmuxer/es/mp4";
import TransmuxerWorkerControl from "./worker";
export { MP4 as default };
