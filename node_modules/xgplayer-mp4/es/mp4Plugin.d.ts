export default class Mp4Plugin extends BasePlugin {
    static get defaultConfig(): {
        maxBufferLength: number;
        minBufferLength: number;
        disableBufferBreakCheck: boolean;
        waitingTimeOut: number;
        waitingInBufferTimeOut: number;
        waitJampBufferMaxCnt: number;
        tickInSeconds: number;
        reqOptions: any;
        closeDowngrade: boolean;
    };
    static get version(): any;
    constructor(options: any);
    mp4: MP4;
    mse: MSE;
    _waitAdjustTimeCnt: number;
    _lastCheckTime: number;
    _removeBuffeEndTime: number;
    _pendingPromises: any[];
    attachEvents(): void;
    detachEvents(): void;
    /**
     * 代理播放器的相关API
     * platNext、_startInit
     */
    _proxyPlayer(): void;
    _playerStartInit(url: any): void;
    _initPromise: ProxyPromise;
    useVideoLoad: boolean;
    initMp4(): ProxyPromise;
    _curLoadSegmentIdx: any;
    _onMp4DataCallBack: () => void;
    _onMp4MetaReady: (meta: any) => void;
    setConfig(newConfig: any): void;
    /**
     * 播放下一个
     * @param { any } newConfig 播放器
     */
    playNext(newConfig: any): void;
    _defInited: boolean;
    _MSEError: boolean;
    checkDegrade(error: any): boolean;
    _onMp4Error: (err: any) => void;
    _errorHandler(err: any): void;
    /**
     * @@description 降级到video播放
     */
    _startDegradedPlayback(err: any, preState: any): void;
    _currentTime: number;
    __onmetadataHandle: any;
    _addPendingPromise(p: any): void;
    _removePendingPromise(p: any): void;
    _cancelPendingPromises(): void;
    _removeAndRejectInitPromise(error: any): void;
    /**
     * 初始化MSE信息
     * @param {*} mp4
     * @param {*} meta
     * @param {*} promise
     * @param {*} preloadTimeCache
     */
    _initMse(meta: any): Promise<void>;
    _isMseInit: boolean;
    /**
     * 销毁MSE对象 // 在重用MSE的时候，如果降级到video原生播放，单实例复用时，需要重新绑定url.所以降级到video原生的需要删除mse对象
     */
    destroyMSE(): Promise<void>;
    _onTimeUpdate(): void;
    checkRemoveOldBitrateBuffer(): void;
    _isInBuffer(item: any, gap?: number): boolean;
    _loadData(): Promise<void>;
    _loadDataSuccess: (data: any) => void;
    bufferEndTime: number;
    _onWaiting: () => void;
    _waitInBufferTimer: NodeJS.Timeout;
    _onSeeking: () => Promise<void>;
    endofstream: boolean;
    _appendInitSeg(initSeg: any): void;
    _appendBuffer(codec: any, buffer: any, context: {}, state: any): void;
    /**
     *清除sourcebuffer中播放过的数据
     */
    _checkRemoveSourceBuffer(sourceBufferRange: any, currentTime: any, mustClear: any): void;
    _removeBufferTimer: NodeJS.Timeout;
    _checkRemoveBufferLastTime: number;
    /**
     * 检查是否播放完成
     * @returns {Boolean}
     */
    _isEnded(): boolean;
    /**
     * 切换播放源，用于同一个视频的不同播放源切换
     * @param { string ||  Array<{ src: string,  [propName: string]: any; // 扩展定义}> } url
     */
    switchURL(definitionInfo: any): void;
    oldChangeDefinition(to: any, from: any): void;
    _changeDefState: {
        currentTime: number;
        paused: boolean;
    };
    _changeDefineCanPlay: any;
    changeDefineCanPlay: (currentTime: any, paused: any, from: any, to: any) => void;
    changeDefinition: (to: any, from: any) => Promise<void>;
    _isChangeDefinition: boolean;
    /**
     * 卡顿超时检查启用
     * 卡顿超过一定时间则至直接降级处理
     */
    _loadStuckCheck(): void;
    _bufferBreakFlag: number;
    _bufferBreakTimer: any;
    _lastCurrentTime: number;
    get isDestroy(): boolean;
    _replayHook: () => boolean;
    _retryHook: () => boolean;
    _stopProgress(): void;
    _hasStartProgress: boolean;
    _requestTimer: any;
    _startProgress(): void;
    log(message: any, ...optionalParams: any[]): void;
    /**
     * 重置当前插件的状态
     */
    _reset(): void;
    _unloadVideo(): void;
}
import { BasePlugin } from "xgplayer";
import MP4 from "./mp4";
import { MSE } from "../../xgplayer-streaming-shared/es/mse";
import ProxyPromise from "./util/proxy-promise";
